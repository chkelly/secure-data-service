#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Fri Sep  9 13:38:07 2011 by generateDS.py version 2.6a.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class WeeksInCycle(GeneratedsSuper):
    """The number of weeks in which the meeting time schedules repeat."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if WeeksInCycle.subclass:
            return WeeksInCycle.subclass(*args_, **kwargs_)
        else:
            return WeeksInCycle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='WeeksInCycle', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WeeksInCycle')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WeeksInCycle'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='WeeksInCycle', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='WeeksInCycle'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WeeksInCycle


class NumberOfParts(GeneratedsSuper):
    """The number of parts identified for a course."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if NumberOfParts.subclass:
            return NumberOfParts.subclass(*args_, **kwargs_)
        else:
            return NumberOfParts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='NumberOfParts', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NumberOfParts')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NumberOfParts'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NumberOfParts', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NumberOfParts'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NumberOfParts


class FinalLetterGradeEarned(GeneratedsSuper):
    """The final indicator of student performance in a class as submitted
    by the instructor."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if FinalLetterGradeEarned.subclass:
            return FinalLetterGradeEarned.subclass(*args_, **kwargs_)
        else:
            return FinalLetterGradeEarned(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='FinalLetterGradeEarned', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FinalLetterGradeEarned')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FinalLetterGradeEarned'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FinalLetterGradeEarned', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FinalLetterGradeEarned'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FinalLetterGradeEarned


class LetterGradeEarned(GeneratedsSuper):
    """A final or interim (grading period) indicator of student performance
    in a class as submitted by the instructor."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if LetterGradeEarned.subclass:
            return LetterGradeEarned.subclass(*args_, **kwargs_)
        else:
            return LetterGradeEarned(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='LetterGradeEarned', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LetterGradeEarned')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LetterGradeEarned'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LetterGradeEarned', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LetterGradeEarned'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LetterGradeEarned


class TotalInstructionalDays(GeneratedsSuper):
    """Total days available for educational instruction during the grading
    period."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if TotalInstructionalDays.subclass:
            return TotalInstructionalDays.subclass(*args_, **kwargs_)
        else:
            return TotalInstructionalDays(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='TotalInstructionalDays', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TotalInstructionalDays')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TotalInstructionalDays'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TotalInstructionalDays', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TotalInstructionalDays'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TotalInstructionalDays


class PostSecondaryEvent(GeneratedsSuper):
    """This entity captures significant postsecondary events during a
    student's high school tenure (e.g., FASFSA application, or
    college application, acceptance, and enrollment."""
    subclass = None
    superclass = None
    def __init__(self, EventDate=None, PostSecondaryEventDescriptor=None, NameOfInstitution=None, InstitutionId=None, StudentReference=None):
        self.EventDate = EventDate
        self.PostSecondaryEventDescriptor = PostSecondaryEventDescriptor
        self.NameOfInstitution = NameOfInstitution
        self.InstitutionId = InstitutionId
        self.StudentReference = StudentReference
    def factory(*args_, **kwargs_):
        if PostSecondaryEvent.subclass:
            return PostSecondaryEvent.subclass(*args_, **kwargs_)
        else:
            return PostSecondaryEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EventDate(self): return self.EventDate
    def set_EventDate(self, EventDate): self.EventDate = EventDate
    def get_PostSecondaryEventDescriptor(self): return self.PostSecondaryEventDescriptor
    def set_PostSecondaryEventDescriptor(self, PostSecondaryEventDescriptor): self.PostSecondaryEventDescriptor = PostSecondaryEventDescriptor
    def validate_PostSecondaryEventDescriptorType(self, value):
        # Validate type PostSecondaryEventDescriptorType, a restriction on xs:token.
        pass
    def get_NameOfInstitution(self): return self.NameOfInstitution
    def set_NameOfInstitution(self, NameOfInstitution): self.NameOfInstitution = NameOfInstitution
    def validate_NameOfInstitution(self, value):
        # Validate type NameOfInstitution, a restriction on xs:string.
        pass
    def get_InstitutionId(self): return self.InstitutionId
    def set_InstitutionId(self, InstitutionId): self.InstitutionId = InstitutionId
    def validate_InstitutionId(self, value):
        # Validate type InstitutionId, a restriction on xs:string.
        pass
    def get_StudentReference(self): return self.StudentReference
    def set_StudentReference(self, StudentReference): self.StudentReference = StudentReference
    def export(self, outfile, level, namespace_='', name_='PostSecondaryEvent', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PostSecondaryEvent')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PostSecondaryEvent'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PostSecondaryEvent', fromsubclass_=False):
        if self.EventDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sEventDate>%s</%sEventDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.EventDate).encode(ExternalEncoding), input_name='EventDate'), namespace_))
        if self.PostSecondaryEventDescriptor is not None:
            showIndent(outfile, level)
            outfile.write('<%sPostSecondaryEventDescriptor>%s</%sPostSecondaryEventDescriptor>\n' % (namespace_, self.gds_format_string(quote_xml(self.PostSecondaryEventDescriptor).encode(ExternalEncoding), input_name='PostSecondaryEventDescriptor'), namespace_))
        if self.NameOfInstitution is not None:
            showIndent(outfile, level)
            outfile.write('<%sNameOfInstitution>%s</%sNameOfInstitution>\n' % (namespace_, self.gds_format_string(quote_xml(self.NameOfInstitution).encode(ExternalEncoding), input_name='NameOfInstitution'), namespace_))
        if self.InstitutionId is not None:
            showIndent(outfile, level)
            outfile.write('<%sInstitutionId>%s</%sInstitutionId>\n' % (namespace_, self.gds_format_string(quote_xml(self.InstitutionId).encode(ExternalEncoding), input_name='InstitutionId'), namespace_))
        if self.StudentReference:
            self.StudentReference.export(outfile, level, namespace_, name_='StudentReference', )
    def hasContent_(self):
        if (
            self.EventDate is not None or
            self.PostSecondaryEventDescriptor is not None or
            self.NameOfInstitution is not None or
            self.InstitutionId is not None or
            self.StudentReference is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PostSecondaryEvent'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.EventDate is not None:
            showIndent(outfile, level)
            outfile.write('EventDate=%s,\n' % quote_python(self.EventDate).encode(ExternalEncoding))
        if self.PostSecondaryEventDescriptor is not None:
            showIndent(outfile, level)
            outfile.write('PostSecondaryEventDescriptor=%s,\n' % quote_python(self.PostSecondaryEventDescriptor).encode(ExternalEncoding))
        if self.NameOfInstitution is not None:
            showIndent(outfile, level)
            outfile.write('NameOfInstitution=%s,\n' % quote_python(self.NameOfInstitution).encode(ExternalEncoding))
        if self.InstitutionId is not None:
            showIndent(outfile, level)
            outfile.write('InstitutionId=%s,\n' % quote_python(self.InstitutionId).encode(ExternalEncoding))
        if self.StudentReference is not None:
            showIndent(outfile, level)
            outfile.write('StudentReference=model_.StudentReferenceType(\n')
            self.StudentReference.exportLiteral(outfile, level, name_='StudentReference')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EventDate':
            EventDate_ = child_.text
            EventDate_ = self.gds_validate_string(EventDate_, node, 'EventDate')
            self.EventDate = EventDate_
        elif nodeName_ == 'PostSecondaryEventDescriptor':
            PostSecondaryEventDescriptor_ = child_.text
            PostSecondaryEventDescriptor_ = re_.sub(String_cleanup_pat_, " ", PostSecondaryEventDescriptor_).strip()
            PostSecondaryEventDescriptor_ = self.gds_validate_string(PostSecondaryEventDescriptor_, node, 'PostSecondaryEventDescriptor')
            self.PostSecondaryEventDescriptor = PostSecondaryEventDescriptor_
            self.validate_PostSecondaryEventDescriptorType(self.PostSecondaryEventDescriptor)    # validate type PostSecondaryEventDescriptorType
        elif nodeName_ == 'NameOfInstitution':
            NameOfInstitution_ = child_.text
            NameOfInstitution_ = self.gds_validate_string(NameOfInstitution_, node, 'NameOfInstitution')
            self.NameOfInstitution = NameOfInstitution_
            self.validate_NameOfInstitution(self.NameOfInstitution)    # validate type NameOfInstitution
        elif nodeName_ == 'InstitutionId':
            InstitutionId_ = child_.text
            InstitutionId_ = self.gds_validate_string(InstitutionId_, node, 'InstitutionId')
            self.InstitutionId = InstitutionId_
            self.validate_InstitutionId(self.InstitutionId)    # validate type InstitutionId
        elif nodeName_ == 'StudentReference':
            obj_ = StudentReferenceType.factory()
            obj_.build(child_)
            self.set_StudentReference(obj_)
# end class PostSecondaryEvent


class NumberOfDaysAbsent(GeneratedsSuper):
    """The number of days an individual is absent when school is in session
    during a given reporting period."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if NumberOfDaysAbsent.subclass:
            return NumberOfDaysAbsent.subclass(*args_, **kwargs_)
        else:
            return NumberOfDaysAbsent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='NumberOfDaysAbsent', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NumberOfDaysAbsent')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NumberOfDaysAbsent'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NumberOfDaysAbsent', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NumberOfDaysAbsent'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NumberOfDaysAbsent


class NumberOfDaysInAttendance(GeneratedsSuper):
    """The number of days an individual is present when school is in
    session during a given reporting period."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if NumberOfDaysInAttendance.subclass:
            return NumberOfDaysInAttendance.subclass(*args_, **kwargs_)
        else:
            return NumberOfDaysInAttendance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='NumberOfDaysInAttendance', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NumberOfDaysInAttendance')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NumberOfDaysInAttendance'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NumberOfDaysInAttendance', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NumberOfDaysInAttendance'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NumberOfDaysInAttendance


class NumberOfDaysTardy(GeneratedsSuper):
    """The number of days an individual is tardy during a given reporting
    period."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if NumberOfDaysTardy.subclass:
            return NumberOfDaysTardy.subclass(*args_, **kwargs_)
        else:
            return NumberOfDaysTardy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='NumberOfDaysTardy', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NumberOfDaysTardy')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NumberOfDaysTardy'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NumberOfDaysTardy', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NumberOfDaysTardy'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NumberOfDaysTardy


class SequenceOfCourse(GeneratedsSuper):
    """When a section is part of a sequence of parts for a course, the
    number if the sequence. If the course has only onle part, the
    value of this section attribute should be 1."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if SequenceOfCourse.subclass:
            return SequenceOfCourse.subclass(*args_, **kwargs_)
        else:
            return SequenceOfCourse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='SequenceOfCourse', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SequenceOfCourse')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SequenceOfCourse'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SequenceOfCourse', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SequenceOfCourse'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SequenceOfCourse


class StaffCohortAssociation(GeneratedsSuper):
    """This association indicates the staff associated with a cohort of
    students."""
    subclass = None
    superclass = None
    def __init__(self, StaffReference=None, CohortReference=None, BeginDate=None, EndDate=None, CohortStudentRecordAccess=None):
        if StaffReference is None:
            self.StaffReference = []
        else:
            self.StaffReference = StaffReference
        if CohortReference is None:
            self.CohortReference = []
        else:
            self.CohortReference = CohortReference
        self.BeginDate = BeginDate
        self.EndDate = EndDate
        self.CohortStudentRecordAccess = CohortStudentRecordAccess
    def factory(*args_, **kwargs_):
        if StaffCohortAssociation.subclass:
            return StaffCohortAssociation.subclass(*args_, **kwargs_)
        else:
            return StaffCohortAssociation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StaffReference(self): return self.StaffReference
    def set_StaffReference(self, StaffReference): self.StaffReference = StaffReference
    def add_StaffReference(self, value): self.StaffReference.append(value)
    def insert_StaffReference(self, index, value): self.StaffReference[index] = value
    def get_CohortReference(self): return self.CohortReference
    def set_CohortReference(self, CohortReference): self.CohortReference = CohortReference
    def add_CohortReference(self, value): self.CohortReference.append(value)
    def insert_CohortReference(self, index, value): self.CohortReference[index] = value
    def get_BeginDate(self): return self.BeginDate
    def set_BeginDate(self, BeginDate): self.BeginDate = BeginDate
    def get_EndDate(self): return self.EndDate
    def set_EndDate(self, EndDate): self.EndDate = EndDate
    def get_CohortStudentRecordAccess(self): return self.CohortStudentRecordAccess
    def set_CohortStudentRecordAccess(self, CohortStudentRecordAccess): self.CohortStudentRecordAccess = CohortStudentRecordAccess
    def export(self, outfile, level, namespace_='', name_='StaffCohortAssociation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StaffCohortAssociation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StaffCohortAssociation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StaffCohortAssociation', fromsubclass_=False):
        for StaffReference_ in self.StaffReference:
            StaffReference_.export(outfile, level, namespace_, name_='StaffReference')
        for CohortReference_ in self.CohortReference:
            CohortReference_.export(outfile, level, namespace_, name_='CohortReference')
        if self.BeginDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sBeginDate>%s</%sBeginDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.BeginDate).encode(ExternalEncoding), input_name='BeginDate'), namespace_))
        if self.EndDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sEndDate>%s</%sEndDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.EndDate).encode(ExternalEncoding), input_name='EndDate'), namespace_))
        if self.CohortStudentRecordAccess is not None:
            showIndent(outfile, level)
            outfile.write('<%sCohortStudentRecordAccess>%s</%sCohortStudentRecordAccess>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.CohortStudentRecordAccess)), input_name='CohortStudentRecordAccess'), namespace_))
    def hasContent_(self):
        if (
            self.StaffReference or
            self.CohortReference or
            self.BeginDate is not None or
            self.EndDate is not None or
            self.CohortStudentRecordAccess is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StaffCohortAssociation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('StaffReference=[\n')
        level += 1
        for StaffReference_ in self.StaffReference:
            showIndent(outfile, level)
            outfile.write('model_.StaffReferenceType(\n')
            StaffReference_.exportLiteral(outfile, level, name_='StaffReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CohortReference=[\n')
        level += 1
        for CohortReference_ in self.CohortReference:
            showIndent(outfile, level)
            outfile.write('model_.CohortReferenceType(\n')
            CohortReference_.exportLiteral(outfile, level, name_='CohortReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.BeginDate is not None:
            showIndent(outfile, level)
            outfile.write('BeginDate=%s,\n' % quote_python(self.BeginDate).encode(ExternalEncoding))
        if self.EndDate is not None:
            showIndent(outfile, level)
            outfile.write('EndDate=%s,\n' % quote_python(self.EndDate).encode(ExternalEncoding))
        if self.CohortStudentRecordAccess is not None:
            showIndent(outfile, level)
            outfile.write('CohortStudentRecordAccess=%s,\n' % self.CohortStudentRecordAccess)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StaffReference':
            obj_ = StaffReferenceType.factory()
            obj_.build(child_)
            self.StaffReference.append(obj_)
        elif nodeName_ == 'CohortReference':
            obj_ = CohortReferenceType.factory()
            obj_.build(child_)
            self.CohortReference.append(obj_)
        elif nodeName_ == 'BeginDate':
            BeginDate_ = child_.text
            BeginDate_ = self.gds_validate_string(BeginDate_, node, 'BeginDate')
            self.BeginDate = BeginDate_
        elif nodeName_ == 'EndDate':
            EndDate_ = child_.text
            EndDate_ = self.gds_validate_string(EndDate_, node, 'EndDate')
            self.EndDate = EndDate_
        elif nodeName_ == 'CohortStudentRecordAccess':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'CohortStudentRecordAccess')
            self.CohortStudentRecordAccess = ival_
# end class StaffCohortAssociation


class StaffEducationOrgAssignmentAssociation(GeneratedsSuper):
    """This association indicates the education organization to which a
    staff member provides services. Also known as School of service."""
    subclass = None
    superclass = None
    def __init__(self, StaffReference=None, EducationOrganizationReference=None, StaffClassification=None, PositionTitle=None, BeginDate=None, EndDate=None):
        self.StaffReference = StaffReference
        self.EducationOrganizationReference = EducationOrganizationReference
        self.StaffClassification = StaffClassification
        self.PositionTitle = PositionTitle
        self.BeginDate = BeginDate
        self.EndDate = EndDate
    def factory(*args_, **kwargs_):
        if StaffEducationOrgAssignmentAssociation.subclass:
            return StaffEducationOrgAssignmentAssociation.subclass(*args_, **kwargs_)
        else:
            return StaffEducationOrgAssignmentAssociation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StaffReference(self): return self.StaffReference
    def set_StaffReference(self, StaffReference): self.StaffReference = StaffReference
    def get_EducationOrganizationReference(self): return self.EducationOrganizationReference
    def set_EducationOrganizationReference(self, EducationOrganizationReference): self.EducationOrganizationReference = EducationOrganizationReference
    def get_StaffClassification(self): return self.StaffClassification
    def set_StaffClassification(self, StaffClassification): self.StaffClassification = StaffClassification
    def validate_StaffClassificationType(self, value):
        # Validate type StaffClassificationType, a restriction on xs:token.
        pass
    def get_PositionTitle(self): return self.PositionTitle
    def set_PositionTitle(self, PositionTitle): self.PositionTitle = PositionTitle
    def validate_PositionTitle(self, value):
        # Validate type PositionTitle, a restriction on xs:string.
        pass
    def get_BeginDate(self): return self.BeginDate
    def set_BeginDate(self, BeginDate): self.BeginDate = BeginDate
    def get_EndDate(self): return self.EndDate
    def set_EndDate(self, EndDate): self.EndDate = EndDate
    def export(self, outfile, level, namespace_='', name_='StaffEducationOrgAssignmentAssociation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StaffEducationOrgAssignmentAssociation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StaffEducationOrgAssignmentAssociation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StaffEducationOrgAssignmentAssociation', fromsubclass_=False):
        if self.StaffReference:
            self.StaffReference.export(outfile, level, namespace_, name_='StaffReference', )
        if self.EducationOrganizationReference:
            self.EducationOrganizationReference.export(outfile, level, namespace_, name_='EducationOrganizationReference', )
        if self.StaffClassification is not None:
            showIndent(outfile, level)
            outfile.write('<%sStaffClassification>%s</%sStaffClassification>\n' % (namespace_, self.gds_format_string(quote_xml(self.StaffClassification).encode(ExternalEncoding), input_name='StaffClassification'), namespace_))
        if self.PositionTitle is not None:
            showIndent(outfile, level)
            outfile.write('<%sPositionTitle>%s</%sPositionTitle>\n' % (namespace_, self.gds_format_string(quote_xml(self.PositionTitle).encode(ExternalEncoding), input_name='PositionTitle'), namespace_))
        if self.BeginDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sBeginDate>%s</%sBeginDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.BeginDate).encode(ExternalEncoding), input_name='BeginDate'), namespace_))
        if self.EndDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sEndDate>%s</%sEndDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.EndDate).encode(ExternalEncoding), input_name='EndDate'), namespace_))
    def hasContent_(self):
        if (
            self.StaffReference is not None or
            self.EducationOrganizationReference is not None or
            self.StaffClassification is not None or
            self.PositionTitle is not None or
            self.BeginDate is not None or
            self.EndDate is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StaffEducationOrgAssignmentAssociation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StaffReference is not None:
            showIndent(outfile, level)
            outfile.write('StaffReference=model_.StaffReferenceType(\n')
            self.StaffReference.exportLiteral(outfile, level, name_='StaffReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.EducationOrganizationReference is not None:
            showIndent(outfile, level)
            outfile.write('EducationOrganizationReference=model_.EducationalOrgReferenceType(\n')
            self.EducationOrganizationReference.exportLiteral(outfile, level, name_='EducationOrganizationReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.StaffClassification is not None:
            showIndent(outfile, level)
            outfile.write('StaffClassification=%s,\n' % quote_python(self.StaffClassification).encode(ExternalEncoding))
        if self.PositionTitle is not None:
            showIndent(outfile, level)
            outfile.write('PositionTitle=%s,\n' % quote_python(self.PositionTitle).encode(ExternalEncoding))
        if self.BeginDate is not None:
            showIndent(outfile, level)
            outfile.write('BeginDate=%s,\n' % quote_python(self.BeginDate).encode(ExternalEncoding))
        if self.EndDate is not None:
            showIndent(outfile, level)
            outfile.write('EndDate=%s,\n' % quote_python(self.EndDate).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StaffReference':
            obj_ = StaffReferenceType.factory()
            obj_.build(child_)
            self.set_StaffReference(obj_)
        elif nodeName_ == 'EducationOrganizationReference':
            obj_ = EducationalOrgReferenceType.factory()
            obj_.build(child_)
            self.set_EducationOrganizationReference(obj_)
        elif nodeName_ == 'StaffClassification':
            StaffClassification_ = child_.text
            StaffClassification_ = re_.sub(String_cleanup_pat_, " ", StaffClassification_).strip()
            StaffClassification_ = self.gds_validate_string(StaffClassification_, node, 'StaffClassification')
            self.StaffClassification = StaffClassification_
            self.validate_StaffClassificationType(self.StaffClassification)    # validate type StaffClassificationType
        elif nodeName_ == 'PositionTitle':
            PositionTitle_ = child_.text
            PositionTitle_ = self.gds_validate_string(PositionTitle_, node, 'PositionTitle')
            self.PositionTitle = PositionTitle_
            self.validate_PositionTitle(self.PositionTitle)    # validate type PositionTitle
        elif nodeName_ == 'BeginDate':
            BeginDate_ = child_.text
            BeginDate_ = self.gds_validate_string(BeginDate_, node, 'BeginDate')
            self.BeginDate = BeginDate_
        elif nodeName_ == 'EndDate':
            EndDate_ = child_.text
            EndDate_ = self.gds_validate_string(EndDate_, node, 'EndDate')
            self.EndDate = EndDate_
# end class StaffEducationOrgAssignmentAssociation


class StaffEducationOrgEmploymentAssociation(GeneratedsSuper):
    """This association indicates the education organization an employee,
    contractor, volunteer or other service provider is formally
    associated with, typically indicated by which organization the
    staff member has a services contract with or receives their
    compensation."""
    subclass = None
    superclass = None
    def __init__(self, StaffReference=None, EducationOrganizationReference=None, EmploymentStatus=None, EmploymentPeriod=None, Department=None, FullTimeEquivalency=None):
        self.StaffReference = StaffReference
        self.EducationOrganizationReference = EducationOrganizationReference
        self.EmploymentStatus = EmploymentStatus
        self.EmploymentPeriod = EmploymentPeriod
        self.Department = Department
        self.FullTimeEquivalency = FullTimeEquivalency
    def factory(*args_, **kwargs_):
        if StaffEducationOrgEmploymentAssociation.subclass:
            return StaffEducationOrgEmploymentAssociation.subclass(*args_, **kwargs_)
        else:
            return StaffEducationOrgEmploymentAssociation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StaffReference(self): return self.StaffReference
    def set_StaffReference(self, StaffReference): self.StaffReference = StaffReference
    def get_EducationOrganizationReference(self): return self.EducationOrganizationReference
    def set_EducationOrganizationReference(self, EducationOrganizationReference): self.EducationOrganizationReference = EducationOrganizationReference
    def get_EmploymentStatus(self): return self.EmploymentStatus
    def set_EmploymentStatus(self, EmploymentStatus): self.EmploymentStatus = EmploymentStatus
    def validate_EmploymentStatusType(self, value):
        # Validate type EmploymentStatusType, a restriction on xs:token.
        pass
    def get_EmploymentPeriod(self): return self.EmploymentPeriod
    def set_EmploymentPeriod(self, EmploymentPeriod): self.EmploymentPeriod = EmploymentPeriod
    def get_Department(self): return self.Department
    def set_Department(self, Department): self.Department = Department
    def validate_Department(self, value):
        # Validate type Department, a restriction on xs:string.
        pass
    def get_FullTimeEquivalency(self): return self.FullTimeEquivalency
    def set_FullTimeEquivalency(self, FullTimeEquivalency): self.FullTimeEquivalency = FullTimeEquivalency
    def validate_percent(self, value):
        # Validate type percent, a restriction on xs:int.
        pass
    def export(self, outfile, level, namespace_='', name_='StaffEducationOrgEmploymentAssociation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StaffEducationOrgEmploymentAssociation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StaffEducationOrgEmploymentAssociation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StaffEducationOrgEmploymentAssociation', fromsubclass_=False):
        if self.StaffReference:
            self.StaffReference.export(outfile, level, namespace_, name_='StaffReference', )
        if self.EducationOrganizationReference:
            self.EducationOrganizationReference.export(outfile, level, namespace_, name_='EducationOrganizationReference', )
        if self.EmploymentStatus is not None:
            showIndent(outfile, level)
            outfile.write('<%sEmploymentStatus>%s</%sEmploymentStatus>\n' % (namespace_, self.gds_format_string(quote_xml(self.EmploymentStatus).encode(ExternalEncoding), input_name='EmploymentStatus'), namespace_))
        if self.EmploymentPeriod:
            self.EmploymentPeriod.export(outfile, level, namespace_, name_='EmploymentPeriod', )
        if self.Department is not None:
            showIndent(outfile, level)
            outfile.write('<%sDepartment>%s</%sDepartment>\n' % (namespace_, self.gds_format_string(quote_xml(self.Department).encode(ExternalEncoding), input_name='Department'), namespace_))
        if self.FullTimeEquivalency is not None:
            showIndent(outfile, level)
            outfile.write('<%sFullTimeEquivalency>%s</%sFullTimeEquivalency>\n' % (namespace_, self.gds_format_integer(self.FullTimeEquivalency, input_name='FullTimeEquivalency'), namespace_))
    def hasContent_(self):
        if (
            self.StaffReference is not None or
            self.EducationOrganizationReference is not None or
            self.EmploymentStatus is not None or
            self.EmploymentPeriod is not None or
            self.Department is not None or
            self.FullTimeEquivalency is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StaffEducationOrgEmploymentAssociation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StaffReference is not None:
            showIndent(outfile, level)
            outfile.write('StaffReference=model_.StaffReferenceType(\n')
            self.StaffReference.exportLiteral(outfile, level, name_='StaffReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.EducationOrganizationReference is not None:
            showIndent(outfile, level)
            outfile.write('EducationOrganizationReference=model_.EducationalOrgReferenceType(\n')
            self.EducationOrganizationReference.exportLiteral(outfile, level, name_='EducationOrganizationReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.EmploymentStatus is not None:
            showIndent(outfile, level)
            outfile.write('EmploymentStatus=%s,\n' % quote_python(self.EmploymentStatus).encode(ExternalEncoding))
        if self.EmploymentPeriod is not None:
            showIndent(outfile, level)
            outfile.write('EmploymentPeriod=model_.EmploymentPeriod(\n')
            self.EmploymentPeriod.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Department is not None:
            showIndent(outfile, level)
            outfile.write('Department=%s,\n' % quote_python(self.Department).encode(ExternalEncoding))
        if self.FullTimeEquivalency is not None:
            showIndent(outfile, level)
            outfile.write('FullTimeEquivalency=%d,\n' % self.FullTimeEquivalency)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StaffReference':
            obj_ = StaffReferenceType.factory()
            obj_.build(child_)
            self.set_StaffReference(obj_)
        elif nodeName_ == 'EducationOrganizationReference':
            obj_ = EducationalOrgReferenceType.factory()
            obj_.build(child_)
            self.set_EducationOrganizationReference(obj_)
        elif nodeName_ == 'EmploymentStatus':
            EmploymentStatus_ = child_.text
            EmploymentStatus_ = re_.sub(String_cleanup_pat_, " ", EmploymentStatus_).strip()
            EmploymentStatus_ = self.gds_validate_string(EmploymentStatus_, node, 'EmploymentStatus')
            self.EmploymentStatus = EmploymentStatus_
            self.validate_EmploymentStatusType(self.EmploymentStatus)    # validate type EmploymentStatusType
        elif nodeName_ == 'EmploymentPeriod':
            obj_ = EmploymentPeriod.factory()
            obj_.build(child_)
            self.set_EmploymentPeriod(obj_)
        elif nodeName_ == 'Department':
            Department_ = child_.text
            Department_ = self.gds_validate_string(Department_, node, 'Department')
            self.Department = Department_
            self.validate_Department(self.Department)    # validate type Department
        elif nodeName_ == 'FullTimeEquivalency':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'FullTimeEquivalency')
            self.FullTimeEquivalency = ival_
            self.validate_percent(self.FullTimeEquivalency)    # validate type percent
# end class StaffEducationOrgEmploymentAssociation


class StudentCohortAssociation(GeneratedsSuper):
    """This association represents the cohort(s) that a student is
    designated for."""
    subclass = None
    superclass = None
    def __init__(self, StudentReference=None, CohortReference=None, BeginDate=None, EndDate=None):
        self.StudentReference = StudentReference
        self.CohortReference = CohortReference
        self.BeginDate = BeginDate
        self.EndDate = EndDate
    def factory(*args_, **kwargs_):
        if StudentCohortAssociation.subclass:
            return StudentCohortAssociation.subclass(*args_, **kwargs_)
        else:
            return StudentCohortAssociation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StudentReference(self): return self.StudentReference
    def set_StudentReference(self, StudentReference): self.StudentReference = StudentReference
    def get_CohortReference(self): return self.CohortReference
    def set_CohortReference(self, CohortReference): self.CohortReference = CohortReference
    def get_BeginDate(self): return self.BeginDate
    def set_BeginDate(self, BeginDate): self.BeginDate = BeginDate
    def get_EndDate(self): return self.EndDate
    def set_EndDate(self, EndDate): self.EndDate = EndDate
    def export(self, outfile, level, namespace_='', name_='StudentCohortAssociation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StudentCohortAssociation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StudentCohortAssociation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StudentCohortAssociation', fromsubclass_=False):
        if self.StudentReference:
            self.StudentReference.export(outfile, level, namespace_, name_='StudentReference', )
        if self.CohortReference:
            self.CohortReference.export(outfile, level, namespace_, name_='CohortReference', )
        if self.BeginDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sBeginDate>%s</%sBeginDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.BeginDate).encode(ExternalEncoding), input_name='BeginDate'), namespace_))
        if self.EndDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sEndDate>%s</%sEndDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.EndDate).encode(ExternalEncoding), input_name='EndDate'), namespace_))
    def hasContent_(self):
        if (
            self.StudentReference is not None or
            self.CohortReference is not None or
            self.BeginDate is not None or
            self.EndDate is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StudentCohortAssociation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StudentReference is not None:
            showIndent(outfile, level)
            outfile.write('StudentReference=model_.StudentReferenceType(\n')
            self.StudentReference.exportLiteral(outfile, level, name_='StudentReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CohortReference is not None:
            showIndent(outfile, level)
            outfile.write('CohortReference=model_.CohortReferenceType(\n')
            self.CohortReference.exportLiteral(outfile, level, name_='CohortReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BeginDate is not None:
            showIndent(outfile, level)
            outfile.write('BeginDate=%s,\n' % quote_python(self.BeginDate).encode(ExternalEncoding))
        if self.EndDate is not None:
            showIndent(outfile, level)
            outfile.write('EndDate=%s,\n' % quote_python(self.EndDate).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StudentReference':
            obj_ = StudentReferenceType.factory()
            obj_.build(child_)
            self.set_StudentReference(obj_)
        elif nodeName_ == 'CohortReference':
            obj_ = CohortReferenceType.factory()
            obj_.build(child_)
            self.set_CohortReference(obj_)
        elif nodeName_ == 'BeginDate':
            BeginDate_ = child_.text
            BeginDate_ = self.gds_validate_string(BeginDate_, node, 'BeginDate')
            self.BeginDate = BeginDate_
        elif nodeName_ == 'EndDate':
            EndDate_ = child_.text
            EndDate_ = self.gds_validate_string(EndDate_, node, 'EndDate')
            self.EndDate = EndDate_
# end class StudentCohortAssociation


class StudentDisciplineIncidentAssociation(GeneratedsSuper):
    """This association indicates those students related to a discipline
    incident who were victims, perpetrators, witnesses, and/or
    reporters."""
    subclass = None
    superclass = None
    def __init__(self, StudentReference=None, DisciplineIncidentReference=None, StudentParticipationCode=None):
        self.StudentReference = StudentReference
        self.DisciplineIncidentReference = DisciplineIncidentReference
        self.StudentParticipationCode = StudentParticipationCode
    def factory(*args_, **kwargs_):
        if StudentDisciplineIncidentAssociation.subclass:
            return StudentDisciplineIncidentAssociation.subclass(*args_, **kwargs_)
        else:
            return StudentDisciplineIncidentAssociation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StudentReference(self): return self.StudentReference
    def set_StudentReference(self, StudentReference): self.StudentReference = StudentReference
    def get_DisciplineIncidentReference(self): return self.DisciplineIncidentReference
    def set_DisciplineIncidentReference(self, DisciplineIncidentReference): self.DisciplineIncidentReference = DisciplineIncidentReference
    def get_StudentParticipationCode(self): return self.StudentParticipationCode
    def set_StudentParticipationCode(self, StudentParticipationCode): self.StudentParticipationCode = StudentParticipationCode
    def validate_StudentParticipationCodeType(self, value):
        # Validate type StudentParticipationCodeType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='StudentDisciplineIncidentAssociation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StudentDisciplineIncidentAssociation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StudentDisciplineIncidentAssociation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StudentDisciplineIncidentAssociation', fromsubclass_=False):
        if self.StudentReference:
            self.StudentReference.export(outfile, level, namespace_, name_='StudentReference', )
        if self.DisciplineIncidentReference:
            self.DisciplineIncidentReference.export(outfile, level, namespace_, name_='DisciplineIncidentReference', )
        if self.StudentParticipationCode is not None:
            showIndent(outfile, level)
            outfile.write('<%sStudentParticipationCode>%s</%sStudentParticipationCode>\n' % (namespace_, self.gds_format_string(quote_xml(self.StudentParticipationCode).encode(ExternalEncoding), input_name='StudentParticipationCode'), namespace_))
    def hasContent_(self):
        if (
            self.StudentReference is not None or
            self.DisciplineIncidentReference is not None or
            self.StudentParticipationCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StudentDisciplineIncidentAssociation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StudentReference is not None:
            showIndent(outfile, level)
            outfile.write('StudentReference=model_.StudentReferenceType(\n')
            self.StudentReference.exportLiteral(outfile, level, name_='StudentReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DisciplineIncidentReference is not None:
            showIndent(outfile, level)
            outfile.write('DisciplineIncidentReference=model_.ReferenceType(\n')
            self.DisciplineIncidentReference.exportLiteral(outfile, level, name_='DisciplineIncidentReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.StudentParticipationCode is not None:
            showIndent(outfile, level)
            outfile.write('StudentParticipationCode=%s,\n' % quote_python(self.StudentParticipationCode).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StudentReference':
            obj_ = StudentReferenceType.factory()
            obj_.build(child_)
            self.set_StudentReference(obj_)
        elif nodeName_ == 'DisciplineIncidentReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_DisciplineIncidentReference(obj_)
        elif nodeName_ == 'StudentParticipationCode':
            StudentParticipationCode_ = child_.text
            StudentParticipationCode_ = re_.sub(String_cleanup_pat_, " ", StudentParticipationCode_).strip()
            StudentParticipationCode_ = self.gds_validate_string(StudentParticipationCode_, node, 'StudentParticipationCode')
            self.StudentParticipationCode = StudentParticipationCode_
            self.validate_StudentParticipationCodeType(self.StudentParticipationCode)    # validate type StudentParticipationCodeType
# end class StudentDisciplineIncidentAssociation


class StudentParentAssociation(GeneratedsSuper):
    """This association relates students to their parents, guradians, or
    caretakers."""
    subclass = None
    superclass = None
    def __init__(self, StudentReference=None, ParentReference=None, Relation=None, PrimaryContactStatus=None, LivesWith=None, EmergencyContactStatus=None, ContactPriority=None, ContactRestrictions=None):
        self.StudentReference = StudentReference
        self.ParentReference = ParentReference
        self.Relation = Relation
        self.PrimaryContactStatus = PrimaryContactStatus
        self.LivesWith = LivesWith
        self.EmergencyContactStatus = EmergencyContactStatus
        self.ContactPriority = ContactPriority
        self.ContactRestrictions = ContactRestrictions
    def factory(*args_, **kwargs_):
        if StudentParentAssociation.subclass:
            return StudentParentAssociation.subclass(*args_, **kwargs_)
        else:
            return StudentParentAssociation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StudentReference(self): return self.StudentReference
    def set_StudentReference(self, StudentReference): self.StudentReference = StudentReference
    def get_ParentReference(self): return self.ParentReference
    def set_ParentReference(self, ParentReference): self.ParentReference = ParentReference
    def get_Relation(self): return self.Relation
    def set_Relation(self, Relation): self.Relation = Relation
    def validate_RelationType(self, value):
        # Validate type RelationType, a restriction on xs:token.
        pass
    def get_PrimaryContactStatus(self): return self.PrimaryContactStatus
    def set_PrimaryContactStatus(self, PrimaryContactStatus): self.PrimaryContactStatus = PrimaryContactStatus
    def get_LivesWith(self): return self.LivesWith
    def set_LivesWith(self, LivesWith): self.LivesWith = LivesWith
    def get_EmergencyContactStatus(self): return self.EmergencyContactStatus
    def set_EmergencyContactStatus(self, EmergencyContactStatus): self.EmergencyContactStatus = EmergencyContactStatus
    def get_ContactPriority(self): return self.ContactPriority
    def set_ContactPriority(self, ContactPriority): self.ContactPriority = ContactPriority
    def get_ContactRestrictions(self): return self.ContactRestrictions
    def set_ContactRestrictions(self, ContactRestrictions): self.ContactRestrictions = ContactRestrictions
    def validate_ContactRestrictions(self, value):
        # Validate type ContactRestrictions, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='StudentParentAssociation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StudentParentAssociation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StudentParentAssociation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StudentParentAssociation', fromsubclass_=False):
        if self.StudentReference:
            self.StudentReference.export(outfile, level, namespace_, name_='StudentReference', )
        if self.ParentReference:
            self.ParentReference.export(outfile, level, namespace_, name_='ParentReference', )
        if self.Relation is not None:
            showIndent(outfile, level)
            outfile.write('<%sRelation>%s</%sRelation>\n' % (namespace_, self.gds_format_string(quote_xml(self.Relation).encode(ExternalEncoding), input_name='Relation'), namespace_))
        if self.PrimaryContactStatus is not None:
            showIndent(outfile, level)
            outfile.write('<%sPrimaryContactStatus>%s</%sPrimaryContactStatus>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.PrimaryContactStatus)), input_name='PrimaryContactStatus'), namespace_))
        if self.LivesWith is not None:
            showIndent(outfile, level)
            outfile.write('<%sLivesWith>%s</%sLivesWith>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.LivesWith)), input_name='LivesWith'), namespace_))
        if self.EmergencyContactStatus is not None:
            showIndent(outfile, level)
            outfile.write('<%sEmergencyContactStatus>%s</%sEmergencyContactStatus>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.EmergencyContactStatus)), input_name='EmergencyContactStatus'), namespace_))
        if self.ContactPriority is not None:
            showIndent(outfile, level)
            outfile.write('<%sContactPriority>%s</%sContactPriority>\n' % (namespace_, self.gds_format_integer(self.ContactPriority, input_name='ContactPriority'), namespace_))
        if self.ContactRestrictions is not None:
            showIndent(outfile, level)
            outfile.write('<%sContactRestrictions>%s</%sContactRestrictions>\n' % (namespace_, self.gds_format_string(quote_xml(self.ContactRestrictions).encode(ExternalEncoding), input_name='ContactRestrictions'), namespace_))
    def hasContent_(self):
        if (
            self.StudentReference is not None or
            self.ParentReference is not None or
            self.Relation is not None or
            self.PrimaryContactStatus is not None or
            self.LivesWith is not None or
            self.EmergencyContactStatus is not None or
            self.ContactPriority is not None or
            self.ContactRestrictions is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StudentParentAssociation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StudentReference is not None:
            showIndent(outfile, level)
            outfile.write('StudentReference=model_.StudentReferenceType(\n')
            self.StudentReference.exportLiteral(outfile, level, name_='StudentReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ParentReference is not None:
            showIndent(outfile, level)
            outfile.write('ParentReference=model_.ReferenceType(\n')
            self.ParentReference.exportLiteral(outfile, level, name_='ParentReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Relation is not None:
            showIndent(outfile, level)
            outfile.write('Relation=%s,\n' % quote_python(self.Relation).encode(ExternalEncoding))
        if self.PrimaryContactStatus is not None:
            showIndent(outfile, level)
            outfile.write('PrimaryContactStatus=%s,\n' % self.PrimaryContactStatus)
        if self.LivesWith is not None:
            showIndent(outfile, level)
            outfile.write('LivesWith=%s,\n' % self.LivesWith)
        if self.EmergencyContactStatus is not None:
            showIndent(outfile, level)
            outfile.write('EmergencyContactStatus=%s,\n' % self.EmergencyContactStatus)
        if self.ContactPriority is not None:
            showIndent(outfile, level)
            outfile.write('ContactPriority=%d,\n' % self.ContactPriority)
        if self.ContactRestrictions is not None:
            showIndent(outfile, level)
            outfile.write('ContactRestrictions=%s,\n' % quote_python(self.ContactRestrictions).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StudentReference':
            obj_ = StudentReferenceType.factory()
            obj_.build(child_)
            self.set_StudentReference(obj_)
        elif nodeName_ == 'ParentReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_ParentReference(obj_)
        elif nodeName_ == 'Relation':
            Relation_ = child_.text
            Relation_ = re_.sub(String_cleanup_pat_, " ", Relation_).strip()
            Relation_ = self.gds_validate_string(Relation_, node, 'Relation')
            self.Relation = Relation_
            self.validate_RelationType(self.Relation)    # validate type RelationType
        elif nodeName_ == 'PrimaryContactStatus':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'PrimaryContactStatus')
            self.PrimaryContactStatus = ival_
        elif nodeName_ == 'LivesWith':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'LivesWith')
            self.LivesWith = ival_
        elif nodeName_ == 'EmergencyContactStatus':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'EmergencyContactStatus')
            self.EmergencyContactStatus = ival_
        elif nodeName_ == 'ContactPriority':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ContactPriority')
            self.ContactPriority = ival_
        elif nodeName_ == 'ContactRestrictions':
            ContactRestrictions_ = child_.text
            ContactRestrictions_ = self.gds_validate_string(ContactRestrictions_, node, 'ContactRestrictions')
            self.ContactRestrictions = ContactRestrictions_
            self.validate_ContactRestrictions(self.ContactRestrictions)    # validate type ContactRestrictions
# end class StudentParentAssociation


class StudentProgramAssociation(GeneratedsSuper):
    """This association represents the program(s) that a student
    participates in or is served by."""
    subclass = None
    superclass = None
    def __init__(self, StudentReference=None, ProgramReference=None, BeginDate=None, EndDate=None, ReasonExited=None, EducationOrganizationReference=None, extensiontype_=None):
        self.StudentReference = StudentReference
        self.ProgramReference = ProgramReference
        self.BeginDate = BeginDate
        self.EndDate = EndDate
        self.ReasonExited = ReasonExited
        self.EducationOrganizationReference = EducationOrganizationReference
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if StudentProgramAssociation.subclass:
            return StudentProgramAssociation.subclass(*args_, **kwargs_)
        else:
            return StudentProgramAssociation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StudentReference(self): return self.StudentReference
    def set_StudentReference(self, StudentReference): self.StudentReference = StudentReference
    def get_ProgramReference(self): return self.ProgramReference
    def set_ProgramReference(self, ProgramReference): self.ProgramReference = ProgramReference
    def get_BeginDate(self): return self.BeginDate
    def set_BeginDate(self, BeginDate): self.BeginDate = BeginDate
    def get_EndDate(self): return self.EndDate
    def set_EndDate(self, EndDate): self.EndDate = EndDate
    def get_ReasonExited(self): return self.ReasonExited
    def set_ReasonExited(self, ReasonExited): self.ReasonExited = ReasonExited
    def validate_ReasonExitedType(self, value):
        # Validate type ReasonExitedType, a restriction on xs:token.
        pass
    def get_EducationOrganizationReference(self): return self.EducationOrganizationReference
    def set_EducationOrganizationReference(self, EducationOrganizationReference): self.EducationOrganizationReference = EducationOrganizationReference
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='StudentProgramAssociation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StudentProgramAssociation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StudentProgramAssociation'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StudentProgramAssociation', fromsubclass_=False):
        if self.StudentReference:
            self.StudentReference.export(outfile, level, namespace_, name_='StudentReference', )
        if self.ProgramReference:
            self.ProgramReference.export(outfile, level, namespace_, name_='ProgramReference', )
        if self.BeginDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sBeginDate>%s</%sBeginDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.BeginDate).encode(ExternalEncoding), input_name='BeginDate'), namespace_))
        if self.EndDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sEndDate>%s</%sEndDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.EndDate).encode(ExternalEncoding), input_name='EndDate'), namespace_))
        if self.ReasonExited is not None:
            showIndent(outfile, level)
            outfile.write('<%sReasonExited>%s</%sReasonExited>\n' % (namespace_, self.gds_format_string(quote_xml(self.ReasonExited).encode(ExternalEncoding), input_name='ReasonExited'), namespace_))
        if self.EducationOrganizationReference:
            self.EducationOrganizationReference.export(outfile, level, namespace_, name_='EducationOrganizationReference', )
    def hasContent_(self):
        if (
            self.StudentReference is not None or
            self.ProgramReference is not None or
            self.BeginDate is not None or
            self.EndDate is not None or
            self.ReasonExited is not None or
            self.EducationOrganizationReference is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StudentProgramAssociation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StudentReference is not None:
            showIndent(outfile, level)
            outfile.write('StudentReference=model_.StudentReferenceType(\n')
            self.StudentReference.exportLiteral(outfile, level, name_='StudentReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ProgramReference is not None:
            showIndent(outfile, level)
            outfile.write('ProgramReference=model_.ProgramReferenceType(\n')
            self.ProgramReference.exportLiteral(outfile, level, name_='ProgramReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BeginDate is not None:
            showIndent(outfile, level)
            outfile.write('BeginDate=%s,\n' % quote_python(self.BeginDate).encode(ExternalEncoding))
        if self.EndDate is not None:
            showIndent(outfile, level)
            outfile.write('EndDate=%s,\n' % quote_python(self.EndDate).encode(ExternalEncoding))
        if self.ReasonExited is not None:
            showIndent(outfile, level)
            outfile.write('ReasonExited=%s,\n' % quote_python(self.ReasonExited).encode(ExternalEncoding))
        if self.EducationOrganizationReference is not None:
            showIndent(outfile, level)
            outfile.write('EducationOrganizationReference=model_.EducationalOrgReferenceType(\n')
            self.EducationOrganizationReference.exportLiteral(outfile, level, name_='EducationOrganizationReference')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StudentReference':
            obj_ = StudentReferenceType.factory()
            obj_.build(child_)
            self.set_StudentReference(obj_)
        elif nodeName_ == 'ProgramReference':
            obj_ = ProgramReferenceType.factory()
            obj_.build(child_)
            self.set_ProgramReference(obj_)
        elif nodeName_ == 'BeginDate':
            BeginDate_ = child_.text
            BeginDate_ = self.gds_validate_string(BeginDate_, node, 'BeginDate')
            self.BeginDate = BeginDate_
        elif nodeName_ == 'EndDate':
            EndDate_ = child_.text
            EndDate_ = self.gds_validate_string(EndDate_, node, 'EndDate')
            self.EndDate = EndDate_
        elif nodeName_ == 'ReasonExited':
            ReasonExited_ = child_.text
            ReasonExited_ = re_.sub(String_cleanup_pat_, " ", ReasonExited_).strip()
            ReasonExited_ = self.gds_validate_string(ReasonExited_, node, 'ReasonExited')
            self.ReasonExited = ReasonExited_
            self.validate_ReasonExitedType(self.ReasonExited)    # validate type ReasonExitedType
        elif nodeName_ == 'EducationOrganizationReference':
            obj_ = EducationalOrgReferenceType.factory()
            obj_.build(child_)
            self.set_EducationOrganizationReference(obj_)
# end class StudentProgramAssociation


class StudentSchoolAssociation(GeneratedsSuper):
    """This association represents the school to which a student is
    enrolled."""
    subclass = None
    superclass = None
    def __init__(self, StudentReference=None, SchoolReference=None, EntryDate=None, EntryGradeLevel=None, EntryType=None, RepeatGradeIndicator=None, SchoolChoiceTransfer=None, ExitWithdrawDate=None, ExitWithdrawType=None, GraduationPlan=None, EducationalPlans=None):
        self.StudentReference = StudentReference
        self.SchoolReference = SchoolReference
        self.EntryDate = EntryDate
        self.EntryGradeLevel = EntryGradeLevel
        self.EntryType = EntryType
        self.RepeatGradeIndicator = RepeatGradeIndicator
        self.SchoolChoiceTransfer = SchoolChoiceTransfer
        self.ExitWithdrawDate = ExitWithdrawDate
        self.ExitWithdrawType = ExitWithdrawType
        self.GraduationPlan = GraduationPlan
        self.EducationalPlans = EducationalPlans
    def factory(*args_, **kwargs_):
        if StudentSchoolAssociation.subclass:
            return StudentSchoolAssociation.subclass(*args_, **kwargs_)
        else:
            return StudentSchoolAssociation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StudentReference(self): return self.StudentReference
    def set_StudentReference(self, StudentReference): self.StudentReference = StudentReference
    def get_SchoolReference(self): return self.SchoolReference
    def set_SchoolReference(self, SchoolReference): self.SchoolReference = SchoolReference
    def get_EntryDate(self): return self.EntryDate
    def set_EntryDate(self, EntryDate): self.EntryDate = EntryDate
    def get_EntryGradeLevel(self): return self.EntryGradeLevel
    def set_EntryGradeLevel(self, EntryGradeLevel): self.EntryGradeLevel = EntryGradeLevel
    def validate_GradeLevelType(self, value):
        # Validate type GradeLevelType, a restriction on xs:token.
        pass
    def get_EntryType(self): return self.EntryType
    def set_EntryType(self, EntryType): self.EntryType = EntryType
    def validate_EntryType(self, value):
        # Validate type EntryType, a restriction on xs:token.
        pass
    def get_RepeatGradeIndicator(self): return self.RepeatGradeIndicator
    def set_RepeatGradeIndicator(self, RepeatGradeIndicator): self.RepeatGradeIndicator = RepeatGradeIndicator
    def get_SchoolChoiceTransfer(self): return self.SchoolChoiceTransfer
    def set_SchoolChoiceTransfer(self, SchoolChoiceTransfer): self.SchoolChoiceTransfer = SchoolChoiceTransfer
    def get_ExitWithdrawDate(self): return self.ExitWithdrawDate
    def set_ExitWithdrawDate(self, ExitWithdrawDate): self.ExitWithdrawDate = ExitWithdrawDate
    def get_ExitWithdrawType(self): return self.ExitWithdrawType
    def set_ExitWithdrawType(self, ExitWithdrawType): self.ExitWithdrawType = ExitWithdrawType
    def validate_ExitWithdrawType(self, value):
        # Validate type ExitWithdrawType, a restriction on xs:token.
        pass
    def get_GraduationPlan(self): return self.GraduationPlan
    def set_GraduationPlan(self, GraduationPlan): self.GraduationPlan = GraduationPlan
    def validate_GraduationPlanType(self, value):
        # Validate type GraduationPlanType, a restriction on xs:token.
        pass
    def get_EducationalPlans(self): return self.EducationalPlans
    def set_EducationalPlans(self, EducationalPlans): self.EducationalPlans = EducationalPlans
    def export(self, outfile, level, namespace_='', name_='StudentSchoolAssociation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StudentSchoolAssociation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StudentSchoolAssociation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StudentSchoolAssociation', fromsubclass_=False):
        if self.StudentReference:
            self.StudentReference.export(outfile, level, namespace_, name_='StudentReference', )
        if self.SchoolReference:
            self.SchoolReference.export(outfile, level, namespace_, name_='SchoolReference', )
        if self.EntryDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sEntryDate>%s</%sEntryDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.EntryDate).encode(ExternalEncoding), input_name='EntryDate'), namespace_))
        if self.EntryGradeLevel is not None:
            showIndent(outfile, level)
            outfile.write('<%sEntryGradeLevel>%s</%sEntryGradeLevel>\n' % (namespace_, self.gds_format_string(quote_xml(self.EntryGradeLevel).encode(ExternalEncoding), input_name='EntryGradeLevel'), namespace_))
        if self.EntryType is not None:
            showIndent(outfile, level)
            outfile.write('<%sEntryType>%s</%sEntryType>\n' % (namespace_, self.gds_format_string(quote_xml(self.EntryType).encode(ExternalEncoding), input_name='EntryType'), namespace_))
        if self.RepeatGradeIndicator is not None:
            showIndent(outfile, level)
            outfile.write('<%sRepeatGradeIndicator>%s</%sRepeatGradeIndicator>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.RepeatGradeIndicator)), input_name='RepeatGradeIndicator'), namespace_))
        if self.SchoolChoiceTransfer is not None:
            showIndent(outfile, level)
            outfile.write('<%sSchoolChoiceTransfer>%s</%sSchoolChoiceTransfer>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.SchoolChoiceTransfer)), input_name='SchoolChoiceTransfer'), namespace_))
        if self.ExitWithdrawDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sExitWithdrawDate>%s</%sExitWithdrawDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.ExitWithdrawDate).encode(ExternalEncoding), input_name='ExitWithdrawDate'), namespace_))
        if self.ExitWithdrawType is not None:
            showIndent(outfile, level)
            outfile.write('<%sExitWithdrawType>%s</%sExitWithdrawType>\n' % (namespace_, self.gds_format_string(quote_xml(self.ExitWithdrawType).encode(ExternalEncoding), input_name='ExitWithdrawType'), namespace_))
        if self.GraduationPlan is not None:
            showIndent(outfile, level)
            outfile.write('<%sGraduationPlan>%s</%sGraduationPlan>\n' % (namespace_, self.gds_format_string(quote_xml(self.GraduationPlan).encode(ExternalEncoding), input_name='GraduationPlan'), namespace_))
        if self.EducationalPlans:
            self.EducationalPlans.export(outfile, level, namespace_, name_='EducationalPlans')
    def hasContent_(self):
        if (
            self.StudentReference is not None or
            self.SchoolReference is not None or
            self.EntryDate is not None or
            self.EntryGradeLevel is not None or
            self.EntryType is not None or
            self.RepeatGradeIndicator is not None or
            self.SchoolChoiceTransfer is not None or
            self.ExitWithdrawDate is not None or
            self.ExitWithdrawType is not None or
            self.GraduationPlan is not None or
            self.EducationalPlans is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StudentSchoolAssociation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StudentReference is not None:
            showIndent(outfile, level)
            outfile.write('StudentReference=model_.StudentReferenceType(\n')
            self.StudentReference.exportLiteral(outfile, level, name_='StudentReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SchoolReference is not None:
            showIndent(outfile, level)
            outfile.write('SchoolReference=model_.EducationalOrgReferenceType(\n')
            self.SchoolReference.exportLiteral(outfile, level, name_='SchoolReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.EntryDate is not None:
            showIndent(outfile, level)
            outfile.write('EntryDate=%s,\n' % quote_python(self.EntryDate).encode(ExternalEncoding))
        if self.EntryGradeLevel is not None:
            showIndent(outfile, level)
            outfile.write('EntryGradeLevel=%s,\n' % quote_python(self.EntryGradeLevel).encode(ExternalEncoding))
        if self.EntryType is not None:
            showIndent(outfile, level)
            outfile.write('EntryType=%s,\n' % quote_python(self.EntryType).encode(ExternalEncoding))
        if self.RepeatGradeIndicator is not None:
            showIndent(outfile, level)
            outfile.write('RepeatGradeIndicator=%s,\n' % self.RepeatGradeIndicator)
        if self.SchoolChoiceTransfer is not None:
            showIndent(outfile, level)
            outfile.write('SchoolChoiceTransfer=%s,\n' % self.SchoolChoiceTransfer)
        if self.ExitWithdrawDate is not None:
            showIndent(outfile, level)
            outfile.write('ExitWithdrawDate=%s,\n' % quote_python(self.ExitWithdrawDate).encode(ExternalEncoding))
        if self.ExitWithdrawType is not None:
            showIndent(outfile, level)
            outfile.write('ExitWithdrawType=%s,\n' % quote_python(self.ExitWithdrawType).encode(ExternalEncoding))
        if self.GraduationPlan is not None:
            showIndent(outfile, level)
            outfile.write('GraduationPlan=%s,\n' % quote_python(self.GraduationPlan).encode(ExternalEncoding))
        if self.EducationalPlans is not None:
            showIndent(outfile, level)
            outfile.write('EducationalPlans=model_.EducationalPlansType(\n')
            self.EducationalPlans.exportLiteral(outfile, level, name_='EducationalPlans')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StudentReference':
            obj_ = StudentReferenceType.factory()
            obj_.build(child_)
            self.set_StudentReference(obj_)
        elif nodeName_ == 'SchoolReference':
            obj_ = EducationalOrgReferenceType.factory()
            obj_.build(child_)
            self.set_SchoolReference(obj_)
        elif nodeName_ == 'EntryDate':
            EntryDate_ = child_.text
            EntryDate_ = self.gds_validate_string(EntryDate_, node, 'EntryDate')
            self.EntryDate = EntryDate_
        elif nodeName_ == 'EntryGradeLevel':
            EntryGradeLevel_ = child_.text
            EntryGradeLevel_ = re_.sub(String_cleanup_pat_, " ", EntryGradeLevel_).strip()
            EntryGradeLevel_ = self.gds_validate_string(EntryGradeLevel_, node, 'EntryGradeLevel')
            self.EntryGradeLevel = EntryGradeLevel_
            self.validate_GradeLevelType(self.EntryGradeLevel)    # validate type GradeLevelType
        elif nodeName_ == 'EntryType':
            EntryType_ = child_.text
            EntryType_ = re_.sub(String_cleanup_pat_, " ", EntryType_).strip()
            EntryType_ = self.gds_validate_string(EntryType_, node, 'EntryType')
            self.EntryType = EntryType_
            self.validate_EntryType(self.EntryType)    # validate type EntryType
        elif nodeName_ == 'RepeatGradeIndicator':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'RepeatGradeIndicator')
            self.RepeatGradeIndicator = ival_
        elif nodeName_ == 'SchoolChoiceTransfer':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'SchoolChoiceTransfer')
            self.SchoolChoiceTransfer = ival_
        elif nodeName_ == 'ExitWithdrawDate':
            ExitWithdrawDate_ = child_.text
            ExitWithdrawDate_ = self.gds_validate_string(ExitWithdrawDate_, node, 'ExitWithdrawDate')
            self.ExitWithdrawDate = ExitWithdrawDate_
        elif nodeName_ == 'ExitWithdrawType':
            ExitWithdrawType_ = child_.text
            ExitWithdrawType_ = re_.sub(String_cleanup_pat_, " ", ExitWithdrawType_).strip()
            ExitWithdrawType_ = self.gds_validate_string(ExitWithdrawType_, node, 'ExitWithdrawType')
            self.ExitWithdrawType = ExitWithdrawType_
            self.validate_ExitWithdrawType(self.ExitWithdrawType)    # validate type ExitWithdrawType
        elif nodeName_ == 'GraduationPlan':
            GraduationPlan_ = child_.text
            GraduationPlan_ = re_.sub(String_cleanup_pat_, " ", GraduationPlan_).strip()
            GraduationPlan_ = self.gds_validate_string(GraduationPlan_, node, 'GraduationPlan')
            self.GraduationPlan = GraduationPlan_
            self.validate_GraduationPlanType(self.GraduationPlan)    # validate type GraduationPlanType
        elif nodeName_ == 'EducationalPlans':
            obj_ = EducationalPlansType.factory()
            obj_.build(child_)
            self.set_EducationalPlans(obj_)
# end class StudentSchoolAssociation


class StudentSupplementalServiceProgramAssociation(StudentProgramAssociation):
    """This association represents the supplemental program(s) that a
    student participates in or receives services from. The
    association is an extension of the StudentProgramAssociation
    particular for supplemental services."""
    subclass = None
    superclass = StudentProgramAssociation
    def __init__(self, StudentReference=None, ProgramReference=None, BeginDate=None, EndDate=None, ReasonExited=None, EducationOrganizationReference=None, SupplementalServices=None):
        super(StudentSupplementalServiceProgramAssociation, self).__init__(StudentReference, ProgramReference, BeginDate, EndDate, ReasonExited, EducationOrganizationReference, )
        if SupplementalServices is None:
            self.SupplementalServices = []
        else:
            self.SupplementalServices = SupplementalServices
    def factory(*args_, **kwargs_):
        if StudentSupplementalServiceProgramAssociation.subclass:
            return StudentSupplementalServiceProgramAssociation.subclass(*args_, **kwargs_)
        else:
            return StudentSupplementalServiceProgramAssociation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SupplementalServices(self): return self.SupplementalServices
    def set_SupplementalServices(self, SupplementalServices): self.SupplementalServices = SupplementalServices
    def add_SupplementalServices(self, value): self.SupplementalServices.append(value)
    def insert_SupplementalServices(self, index, value): self.SupplementalServices[index] = value
    def validate_SupplementalServiceType(self, value):
        # Validate type SupplementalServiceType, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='StudentSupplementalServiceProgramAssociation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StudentSupplementalServiceProgramAssociation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StudentSupplementalServiceProgramAssociation'):
        super(StudentSupplementalServiceProgramAssociation, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StudentSupplementalServiceProgramAssociation')
    def exportChildren(self, outfile, level, namespace_='', name_='StudentSupplementalServiceProgramAssociation', fromsubclass_=False):
        super(StudentSupplementalServiceProgramAssociation, self).exportChildren(outfile, level, namespace_, name_, True)
        for SupplementalServices_ in self.SupplementalServices:
            showIndent(outfile, level)
            outfile.write('<%sSupplementalServices>%s</%sSupplementalServices>\n' % (namespace_, self.gds_format_string(quote_xml(SupplementalServices_).encode(ExternalEncoding), input_name='SupplementalServices'), namespace_))
    def hasContent_(self):
        if (
            self.SupplementalServices or
            super(StudentSupplementalServiceProgramAssociation, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StudentSupplementalServiceProgramAssociation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StudentSupplementalServiceProgramAssociation, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StudentSupplementalServiceProgramAssociation, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('SupplementalServices=[\n')
        level += 1
        for SupplementalServices_ in self.SupplementalServices:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(SupplementalServices_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(StudentSupplementalServiceProgramAssociation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SupplementalServices':
            SupplementalServices_ = child_.text
            SupplementalServices_ = self.gds_validate_string(SupplementalServices_, node, 'SupplementalServices')
            self.SupplementalServices.append(SupplementalServices_)
            self.validate_SupplementalServiceType(self.SupplementalServices)    # validate type SupplementalServiceType
        super(StudentSupplementalServiceProgramAssociation, self).buildChildren(child_, node, nodeName_, True)
# end class StudentSupplementalServiceProgramAssociation


class StudentSectionAssociation(GeneratedsSuper):
    """This association indicates the course sections a student is assigned
    to."""
    subclass = None
    superclass = None
    def __init__(self, StudentReference=None, SectionReference=None, BeginDate=None, EndDate=None, HomeroomIndicator=None, RepeatIdentifier=None):
        self.StudentReference = StudentReference
        self.SectionReference = SectionReference
        self.BeginDate = BeginDate
        self.EndDate = EndDate
        self.HomeroomIndicator = HomeroomIndicator
        self.RepeatIdentifier = RepeatIdentifier
    def factory(*args_, **kwargs_):
        if StudentSectionAssociation.subclass:
            return StudentSectionAssociation.subclass(*args_, **kwargs_)
        else:
            return StudentSectionAssociation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StudentReference(self): return self.StudentReference
    def set_StudentReference(self, StudentReference): self.StudentReference = StudentReference
    def get_SectionReference(self): return self.SectionReference
    def set_SectionReference(self, SectionReference): self.SectionReference = SectionReference
    def get_BeginDate(self): return self.BeginDate
    def set_BeginDate(self, BeginDate): self.BeginDate = BeginDate
    def get_EndDate(self): return self.EndDate
    def set_EndDate(self, EndDate): self.EndDate = EndDate
    def get_HomeroomIndicator(self): return self.HomeroomIndicator
    def set_HomeroomIndicator(self, HomeroomIndicator): self.HomeroomIndicator = HomeroomIndicator
    def get_RepeatIdentifier(self): return self.RepeatIdentifier
    def set_RepeatIdentifier(self, RepeatIdentifier): self.RepeatIdentifier = RepeatIdentifier
    def validate_RepeatIdentifierType(self, value):
        # Validate type RepeatIdentifierType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='StudentSectionAssociation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StudentSectionAssociation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StudentSectionAssociation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StudentSectionAssociation', fromsubclass_=False):
        if self.StudentReference:
            self.StudentReference.export(outfile, level, namespace_, name_='StudentReference', )
        if self.SectionReference:
            self.SectionReference.export(outfile, level, namespace_, name_='SectionReference', )
        if self.BeginDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sBeginDate>%s</%sBeginDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.BeginDate).encode(ExternalEncoding), input_name='BeginDate'), namespace_))
        if self.EndDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sEndDate>%s</%sEndDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.EndDate).encode(ExternalEncoding), input_name='EndDate'), namespace_))
        if self.HomeroomIndicator is not None:
            showIndent(outfile, level)
            outfile.write('<%sHomeroomIndicator>%s</%sHomeroomIndicator>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.HomeroomIndicator)), input_name='HomeroomIndicator'), namespace_))
        if self.RepeatIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('<%sRepeatIdentifier>%s</%sRepeatIdentifier>\n' % (namespace_, self.gds_format_string(quote_xml(self.RepeatIdentifier).encode(ExternalEncoding), input_name='RepeatIdentifier'), namespace_))
    def hasContent_(self):
        if (
            self.StudentReference is not None or
            self.SectionReference is not None or
            self.BeginDate is not None or
            self.EndDate is not None or
            self.HomeroomIndicator is not None or
            self.RepeatIdentifier is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StudentSectionAssociation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StudentReference is not None:
            showIndent(outfile, level)
            outfile.write('StudentReference=model_.StudentReferenceType(\n')
            self.StudentReference.exportLiteral(outfile, level, name_='StudentReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SectionReference is not None:
            showIndent(outfile, level)
            outfile.write('SectionReference=model_.SectionReferenceType(\n')
            self.SectionReference.exportLiteral(outfile, level, name_='SectionReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BeginDate is not None:
            showIndent(outfile, level)
            outfile.write('BeginDate=%s,\n' % quote_python(self.BeginDate).encode(ExternalEncoding))
        if self.EndDate is not None:
            showIndent(outfile, level)
            outfile.write('EndDate=%s,\n' % quote_python(self.EndDate).encode(ExternalEncoding))
        if self.HomeroomIndicator is not None:
            showIndent(outfile, level)
            outfile.write('HomeroomIndicator=%s,\n' % self.HomeroomIndicator)
        if self.RepeatIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('RepeatIdentifier=%s,\n' % quote_python(self.RepeatIdentifier).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StudentReference':
            obj_ = StudentReferenceType.factory()
            obj_.build(child_)
            self.set_StudentReference(obj_)
        elif nodeName_ == 'SectionReference':
            obj_ = SectionReferenceType.factory()
            obj_.build(child_)
            self.set_SectionReference(obj_)
        elif nodeName_ == 'BeginDate':
            BeginDate_ = child_.text
            BeginDate_ = self.gds_validate_string(BeginDate_, node, 'BeginDate')
            self.BeginDate = BeginDate_
        elif nodeName_ == 'EndDate':
            EndDate_ = child_.text
            EndDate_ = self.gds_validate_string(EndDate_, node, 'EndDate')
            self.EndDate = EndDate_
        elif nodeName_ == 'HomeroomIndicator':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'HomeroomIndicator')
            self.HomeroomIndicator = ival_
        elif nodeName_ == 'RepeatIdentifier':
            RepeatIdentifier_ = child_.text
            RepeatIdentifier_ = re_.sub(String_cleanup_pat_, " ", RepeatIdentifier_).strip()
            RepeatIdentifier_ = self.gds_validate_string(RepeatIdentifier_, node, 'RepeatIdentifier')
            self.RepeatIdentifier = RepeatIdentifier_
            self.validate_RepeatIdentifierType(self.RepeatIdentifier)    # validate type RepeatIdentifierType
# end class StudentSectionAssociation


class StudentSpecialEdProgramAssociation(StudentProgramAssociation):
    """This association represents the special education program(s) that a
    student participates in or receives services from. The
    association is an extension of the StudentProgramAssociation
    particular for special education programs."""
    subclass = None
    superclass = StudentProgramAssociation
    def __init__(self, StudentReference=None, ProgramReference=None, BeginDate=None, EndDate=None, ReasonExited=None, EducationOrganizationReference=None, IdeaEligibility=None, SpecialEdServices=None, InterpretingServices=None, EducationalEnvironment=None, SpecialEducationHoursPerWeek=None, MultiplyDisabled=None, MedicallyFragile=None, LastEvaluationDate=None, IEPReviewDate=None, IEPBeginDate=None, IEPEndDate=None):
        super(StudentSpecialEdProgramAssociation, self).__init__(StudentReference, ProgramReference, BeginDate, EndDate, ReasonExited, EducationOrganizationReference, )
        self.IdeaEligibility = IdeaEligibility
        self.SpecialEdServices = SpecialEdServices
        self.InterpretingServices = InterpretingServices
        self.EducationalEnvironment = EducationalEnvironment
        self.SpecialEducationHoursPerWeek = SpecialEducationHoursPerWeek
        self.MultiplyDisabled = MultiplyDisabled
        self.MedicallyFragile = MedicallyFragile
        self.LastEvaluationDate = LastEvaluationDate
        self.IEPReviewDate = IEPReviewDate
        self.IEPBeginDate = IEPBeginDate
        self.IEPEndDate = IEPEndDate
    def factory(*args_, **kwargs_):
        if StudentSpecialEdProgramAssociation.subclass:
            return StudentSpecialEdProgramAssociation.subclass(*args_, **kwargs_)
        else:
            return StudentSpecialEdProgramAssociation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IdeaEligibility(self): return self.IdeaEligibility
    def set_IdeaEligibility(self, IdeaEligibility): self.IdeaEligibility = IdeaEligibility
    def validate_IdeaEligibilityType(self, value):
        # Validate type IdeaEligibilityType, a restriction on xs:token.
        pass
    def get_SpecialEdServices(self): return self.SpecialEdServices
    def set_SpecialEdServices(self, SpecialEdServices): self.SpecialEdServices = SpecialEdServices
    def get_InterpretingServices(self): return self.InterpretingServices
    def set_InterpretingServices(self, InterpretingServices): self.InterpretingServices = InterpretingServices
    def validate_InterpretingServicesType(self, value):
        # Validate type InterpretingServicesType, a restriction on xs:token.
        pass
    def get_EducationalEnvironment(self): return self.EducationalEnvironment
    def set_EducationalEnvironment(self, EducationalEnvironment): self.EducationalEnvironment = EducationalEnvironment
    def validate_EducationalEnvironmentType(self, value):
        # Validate type EducationalEnvironmentType, a restriction on xs:token.
        pass
    def get_SpecialEducationHoursPerWeek(self): return self.SpecialEducationHoursPerWeek
    def set_SpecialEducationHoursPerWeek(self, SpecialEducationHoursPerWeek): self.SpecialEducationHoursPerWeek = SpecialEducationHoursPerWeek
    def get_MultiplyDisabled(self): return self.MultiplyDisabled
    def set_MultiplyDisabled(self, MultiplyDisabled): self.MultiplyDisabled = MultiplyDisabled
    def get_MedicallyFragile(self): return self.MedicallyFragile
    def set_MedicallyFragile(self, MedicallyFragile): self.MedicallyFragile = MedicallyFragile
    def get_LastEvaluationDate(self): return self.LastEvaluationDate
    def set_LastEvaluationDate(self, LastEvaluationDate): self.LastEvaluationDate = LastEvaluationDate
    def get_IEPReviewDate(self): return self.IEPReviewDate
    def set_IEPReviewDate(self, IEPReviewDate): self.IEPReviewDate = IEPReviewDate
    def get_IEPBeginDate(self): return self.IEPBeginDate
    def set_IEPBeginDate(self, IEPBeginDate): self.IEPBeginDate = IEPBeginDate
    def get_IEPEndDate(self): return self.IEPEndDate
    def set_IEPEndDate(self, IEPEndDate): self.IEPEndDate = IEPEndDate
    def export(self, outfile, level, namespace_='', name_='StudentSpecialEdProgramAssociation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StudentSpecialEdProgramAssociation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StudentSpecialEdProgramAssociation'):
        super(StudentSpecialEdProgramAssociation, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StudentSpecialEdProgramAssociation')
    def exportChildren(self, outfile, level, namespace_='', name_='StudentSpecialEdProgramAssociation', fromsubclass_=False):
        super(StudentSpecialEdProgramAssociation, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.IdeaEligibility is not None:
            showIndent(outfile, level)
            outfile.write('<%sIdeaEligibility>%s</%sIdeaEligibility>\n' % (namespace_, self.gds_format_string(quote_xml(self.IdeaEligibility).encode(ExternalEncoding), input_name='IdeaEligibility'), namespace_))
        if self.SpecialEdServices:
            self.SpecialEdServices.export(outfile, level, namespace_, name_='SpecialEdServices')
        if self.InterpretingServices is not None:
            showIndent(outfile, level)
            outfile.write('<%sInterpretingServices>%s</%sInterpretingServices>\n' % (namespace_, self.gds_format_string(quote_xml(self.InterpretingServices).encode(ExternalEncoding), input_name='InterpretingServices'), namespace_))
        if self.EducationalEnvironment is not None:
            showIndent(outfile, level)
            outfile.write('<%sEducationalEnvironment>%s</%sEducationalEnvironment>\n' % (namespace_, self.gds_format_string(quote_xml(self.EducationalEnvironment).encode(ExternalEncoding), input_name='EducationalEnvironment'), namespace_))
        if self.SpecialEducationHoursPerWeek is not None:
            showIndent(outfile, level)
            outfile.write('<%sSpecialEducationHoursPerWeek>%s</%sSpecialEducationHoursPerWeek>\n' % (namespace_, self.gds_format_float(self.SpecialEducationHoursPerWeek, input_name='SpecialEducationHoursPerWeek'), namespace_))
        if self.MultiplyDisabled is not None:
            showIndent(outfile, level)
            outfile.write('<%sMultiplyDisabled>%s</%sMultiplyDisabled>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.MultiplyDisabled)), input_name='MultiplyDisabled'), namespace_))
        if self.MedicallyFragile is not None:
            showIndent(outfile, level)
            outfile.write('<%sMedicallyFragile>%s</%sMedicallyFragile>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.MedicallyFragile)), input_name='MedicallyFragile'), namespace_))
        if self.LastEvaluationDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sLastEvaluationDate>%s</%sLastEvaluationDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.LastEvaluationDate).encode(ExternalEncoding), input_name='LastEvaluationDate'), namespace_))
        if self.IEPReviewDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sIEPReviewDate>%s</%sIEPReviewDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.IEPReviewDate).encode(ExternalEncoding), input_name='IEPReviewDate'), namespace_))
        if self.IEPBeginDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sIEPBeginDate>%s</%sIEPBeginDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.IEPBeginDate).encode(ExternalEncoding), input_name='IEPBeginDate'), namespace_))
        if self.IEPEndDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sIEPEndDate>%s</%sIEPEndDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.IEPEndDate).encode(ExternalEncoding), input_name='IEPEndDate'), namespace_))
    def hasContent_(self):
        if (
            self.IdeaEligibility is not None or
            self.SpecialEdServices is not None or
            self.InterpretingServices is not None or
            self.EducationalEnvironment is not None or
            self.SpecialEducationHoursPerWeek is not None or
            self.MultiplyDisabled is not None or
            self.MedicallyFragile is not None or
            self.LastEvaluationDate is not None or
            self.IEPReviewDate is not None or
            self.IEPBeginDate is not None or
            self.IEPEndDate is not None or
            super(StudentSpecialEdProgramAssociation, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StudentSpecialEdProgramAssociation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StudentSpecialEdProgramAssociation, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StudentSpecialEdProgramAssociation, self).exportLiteralChildren(outfile, level, name_)
        if self.IdeaEligibility is not None:
            showIndent(outfile, level)
            outfile.write('IdeaEligibility=%s,\n' % quote_python(self.IdeaEligibility).encode(ExternalEncoding))
        if self.SpecialEdServices is not None:
            showIndent(outfile, level)
            outfile.write('SpecialEdServices=model_.SpecialEdServicesType(\n')
            self.SpecialEdServices.exportLiteral(outfile, level, name_='SpecialEdServices')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InterpretingServices is not None:
            showIndent(outfile, level)
            outfile.write('InterpretingServices=%s,\n' % quote_python(self.InterpretingServices).encode(ExternalEncoding))
        if self.EducationalEnvironment is not None:
            showIndent(outfile, level)
            outfile.write('EducationalEnvironment=%s,\n' % quote_python(self.EducationalEnvironment).encode(ExternalEncoding))
        if self.SpecialEducationHoursPerWeek is not None:
            showIndent(outfile, level)
            outfile.write('SpecialEducationHoursPerWeek=%f,\n' % self.SpecialEducationHoursPerWeek)
        if self.MultiplyDisabled is not None:
            showIndent(outfile, level)
            outfile.write('MultiplyDisabled=%s,\n' % self.MultiplyDisabled)
        if self.MedicallyFragile is not None:
            showIndent(outfile, level)
            outfile.write('MedicallyFragile=%s,\n' % self.MedicallyFragile)
        if self.LastEvaluationDate is not None:
            showIndent(outfile, level)
            outfile.write('LastEvaluationDate=%s,\n' % quote_python(self.LastEvaluationDate).encode(ExternalEncoding))
        if self.IEPReviewDate is not None:
            showIndent(outfile, level)
            outfile.write('IEPReviewDate=%s,\n' % quote_python(self.IEPReviewDate).encode(ExternalEncoding))
        if self.IEPBeginDate is not None:
            showIndent(outfile, level)
            outfile.write('IEPBeginDate=%s,\n' % quote_python(self.IEPBeginDate).encode(ExternalEncoding))
        if self.IEPEndDate is not None:
            showIndent(outfile, level)
            outfile.write('IEPEndDate=%s,\n' % quote_python(self.IEPEndDate).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(StudentSpecialEdProgramAssociation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IdeaEligibility':
            IdeaEligibility_ = child_.text
            IdeaEligibility_ = re_.sub(String_cleanup_pat_, " ", IdeaEligibility_).strip()
            IdeaEligibility_ = self.gds_validate_string(IdeaEligibility_, node, 'IdeaEligibility')
            self.IdeaEligibility = IdeaEligibility_
            self.validate_IdeaEligibilityType(self.IdeaEligibility)    # validate type IdeaEligibilityType
        elif nodeName_ == 'SpecialEdServices':
            obj_ = SpecialEdServicesType.factory()
            obj_.build(child_)
            self.set_SpecialEdServices(obj_)
        elif nodeName_ == 'InterpretingServices':
            InterpretingServices_ = child_.text
            InterpretingServices_ = re_.sub(String_cleanup_pat_, " ", InterpretingServices_).strip()
            InterpretingServices_ = self.gds_validate_string(InterpretingServices_, node, 'InterpretingServices')
            self.InterpretingServices = InterpretingServices_
            self.validate_InterpretingServicesType(self.InterpretingServices)    # validate type InterpretingServicesType
        elif nodeName_ == 'EducationalEnvironment':
            EducationalEnvironment_ = child_.text
            EducationalEnvironment_ = re_.sub(String_cleanup_pat_, " ", EducationalEnvironment_).strip()
            EducationalEnvironment_ = self.gds_validate_string(EducationalEnvironment_, node, 'EducationalEnvironment')
            self.EducationalEnvironment = EducationalEnvironment_
            self.validate_EducationalEnvironmentType(self.EducationalEnvironment)    # validate type EducationalEnvironmentType
        elif nodeName_ == 'SpecialEducationHoursPerWeek':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'SpecialEducationHoursPerWeek')
            self.SpecialEducationHoursPerWeek = fval_
        elif nodeName_ == 'MultiplyDisabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'MultiplyDisabled')
            self.MultiplyDisabled = ival_
        elif nodeName_ == 'MedicallyFragile':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'MedicallyFragile')
            self.MedicallyFragile = ival_
        elif nodeName_ == 'LastEvaluationDate':
            LastEvaluationDate_ = child_.text
            LastEvaluationDate_ = self.gds_validate_string(LastEvaluationDate_, node, 'LastEvaluationDate')
            self.LastEvaluationDate = LastEvaluationDate_
        elif nodeName_ == 'IEPReviewDate':
            IEPReviewDate_ = child_.text
            IEPReviewDate_ = self.gds_validate_string(IEPReviewDate_, node, 'IEPReviewDate')
            self.IEPReviewDate = IEPReviewDate_
        elif nodeName_ == 'IEPBeginDate':
            IEPBeginDate_ = child_.text
            IEPBeginDate_ = self.gds_validate_string(IEPBeginDate_, node, 'IEPBeginDate')
            self.IEPBeginDate = IEPBeginDate_
        elif nodeName_ == 'IEPEndDate':
            IEPEndDate_ = child_.text
            IEPEndDate_ = self.gds_validate_string(IEPEndDate_, node, 'IEPEndDate')
            self.IEPEndDate = IEPEndDate_
        super(StudentSpecialEdProgramAssociation, self).buildChildren(child_, node, nodeName_, True)
# end class StudentSpecialEdProgramAssociation


class StudentTitleIPartAProgramAssociation(StudentProgramAssociation):
    """This association represents the Title I Part A program(s) that a
    student participates in or receives services from. The
    association is an extension of the StudentProgramAssociation
    particular for Title I part A programs."""
    subclass = None
    superclass = StudentProgramAssociation
    def __init__(self, StudentReference=None, ProgramReference=None, BeginDate=None, EndDate=None, ReasonExited=None, EducationOrganizationReference=None, TitleIPartAParticipant=None, TitleIPartAServices=None, TitleIPartASupportServices=None):
        super(StudentTitleIPartAProgramAssociation, self).__init__(StudentReference, ProgramReference, BeginDate, EndDate, ReasonExited, EducationOrganizationReference, )
        self.TitleIPartAParticipant = TitleIPartAParticipant
        if TitleIPartAServices is None:
            self.TitleIPartAServices = []
        else:
            self.TitleIPartAServices = TitleIPartAServices
        if TitleIPartASupportServices is None:
            self.TitleIPartASupportServices = []
        else:
            self.TitleIPartASupportServices = TitleIPartASupportServices
    def factory(*args_, **kwargs_):
        if StudentTitleIPartAProgramAssociation.subclass:
            return StudentTitleIPartAProgramAssociation.subclass(*args_, **kwargs_)
        else:
            return StudentTitleIPartAProgramAssociation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TitleIPartAParticipant(self): return self.TitleIPartAParticipant
    def set_TitleIPartAParticipant(self, TitleIPartAParticipant): self.TitleIPartAParticipant = TitleIPartAParticipant
    def validate_TitleIPartAParticipantType(self, value):
        # Validate type TitleIPartAParticipantType, a restriction on xs:token.
        pass
    def get_TitleIPartAServices(self): return self.TitleIPartAServices
    def set_TitleIPartAServices(self, TitleIPartAServices): self.TitleIPartAServices = TitleIPartAServices
    def add_TitleIPartAServices(self, value): self.TitleIPartAServices.append(value)
    def insert_TitleIPartAServices(self, index, value): self.TitleIPartAServices[index] = value
    def get_TitleIPartASupportServices(self): return self.TitleIPartASupportServices
    def set_TitleIPartASupportServices(self, TitleIPartASupportServices): self.TitleIPartASupportServices = TitleIPartASupportServices
    def add_TitleIPartASupportServices(self, value): self.TitleIPartASupportServices.append(value)
    def insert_TitleIPartASupportServices(self, index, value): self.TitleIPartASupportServices[index] = value
    def export(self, outfile, level, namespace_='', name_='StudentTitleIPartAProgramAssociation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StudentTitleIPartAProgramAssociation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StudentTitleIPartAProgramAssociation'):
        super(StudentTitleIPartAProgramAssociation, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StudentTitleIPartAProgramAssociation')
    def exportChildren(self, outfile, level, namespace_='', name_='StudentTitleIPartAProgramAssociation', fromsubclass_=False):
        super(StudentTitleIPartAProgramAssociation, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.TitleIPartAParticipant is not None:
            showIndent(outfile, level)
            outfile.write('<%sTitleIPartAParticipant>%s</%sTitleIPartAParticipant>\n' % (namespace_, self.gds_format_string(quote_xml(self.TitleIPartAParticipant).encode(ExternalEncoding), input_name='TitleIPartAParticipant'), namespace_))
        for TitleIPartAServices_ in self.TitleIPartAServices:
            TitleIPartAServices_.export(outfile, level, namespace_, name_='TitleIPartAServices')
        for TitleIPartASupportServices_ in self.TitleIPartASupportServices:
            TitleIPartASupportServices_.export(outfile, level, namespace_, name_='TitleIPartASupportServices')
    def hasContent_(self):
        if (
            self.TitleIPartAParticipant is not None or
            self.TitleIPartAServices or
            self.TitleIPartASupportServices or
            super(StudentTitleIPartAProgramAssociation, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StudentTitleIPartAProgramAssociation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StudentTitleIPartAProgramAssociation, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StudentTitleIPartAProgramAssociation, self).exportLiteralChildren(outfile, level, name_)
        if self.TitleIPartAParticipant is not None:
            showIndent(outfile, level)
            outfile.write('TitleIPartAParticipant=%s,\n' % quote_python(self.TitleIPartAParticipant).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('TitleIPartAServices=[\n')
        level += 1
        for TitleIPartAServices_ in self.TitleIPartAServices:
            showIndent(outfile, level)
            outfile.write('model_.TitleIPartAServicesType(\n')
            TitleIPartAServices_.exportLiteral(outfile, level, name_='TitleIPartAServicesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TitleIPartASupportServices=[\n')
        level += 1
        for TitleIPartASupportServices_ in self.TitleIPartASupportServices:
            showIndent(outfile, level)
            outfile.write('model_.TitleIPartASupportServicesType(\n')
            TitleIPartASupportServices_.exportLiteral(outfile, level, name_='TitleIPartASupportServicesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(StudentTitleIPartAProgramAssociation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TitleIPartAParticipant':
            TitleIPartAParticipant_ = child_.text
            TitleIPartAParticipant_ = re_.sub(String_cleanup_pat_, " ", TitleIPartAParticipant_).strip()
            TitleIPartAParticipant_ = self.gds_validate_string(TitleIPartAParticipant_, node, 'TitleIPartAParticipant')
            self.TitleIPartAParticipant = TitleIPartAParticipant_
            self.validate_TitleIPartAParticipantType(self.TitleIPartAParticipant)    # validate type TitleIPartAParticipantType
        elif nodeName_ == 'TitleIPartAServices':
            obj_ = TitleIPartAServicesType.factory()
            obj_.build(child_)
            self.TitleIPartAServices.append(obj_)
        elif nodeName_ == 'TitleIPartASupportServices':
            obj_ = TitleIPartASupportServicesType.factory()
            obj_.build(child_)
            self.TitleIPartASupportServices.append(obj_)
        super(StudentTitleIPartAProgramAssociation, self).buildChildren(child_, node, nodeName_, True)
# end class StudentTitleIPartAProgramAssociation


class TeacherSchoolAssociation(GeneratedsSuper):
    """This association indicates the school(s) to which a teacher provides
    instructional services to."""
    subclass = None
    superclass = None
    def __init__(self, TeacherReference=None, SchoolReference=None, ProgramAssignment=None, InstructionalGradeLevels=None, AcademicSubjects=None):
        self.TeacherReference = TeacherReference
        if SchoolReference is None:
            self.SchoolReference = []
        else:
            self.SchoolReference = SchoolReference
        self.ProgramAssignment = ProgramAssignment
        self.InstructionalGradeLevels = InstructionalGradeLevels
        self.AcademicSubjects = AcademicSubjects
    def factory(*args_, **kwargs_):
        if TeacherSchoolAssociation.subclass:
            return TeacherSchoolAssociation.subclass(*args_, **kwargs_)
        else:
            return TeacherSchoolAssociation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TeacherReference(self): return self.TeacherReference
    def set_TeacherReference(self, TeacherReference): self.TeacherReference = TeacherReference
    def get_SchoolReference(self): return self.SchoolReference
    def set_SchoolReference(self, SchoolReference): self.SchoolReference = SchoolReference
    def add_SchoolReference(self, value): self.SchoolReference.append(value)
    def insert_SchoolReference(self, index, value): self.SchoolReference[index] = value
    def get_ProgramAssignment(self): return self.ProgramAssignment
    def set_ProgramAssignment(self, ProgramAssignment): self.ProgramAssignment = ProgramAssignment
    def validate_ProgramAssignmentType(self, value):
        # Validate type ProgramAssignmentType, a restriction on xs:token.
        pass
    def get_InstructionalGradeLevels(self): return self.InstructionalGradeLevels
    def set_InstructionalGradeLevels(self, InstructionalGradeLevels): self.InstructionalGradeLevels = InstructionalGradeLevels
    def get_AcademicSubjects(self): return self.AcademicSubjects
    def set_AcademicSubjects(self, AcademicSubjects): self.AcademicSubjects = AcademicSubjects
    def export(self, outfile, level, namespace_='', name_='TeacherSchoolAssociation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TeacherSchoolAssociation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TeacherSchoolAssociation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TeacherSchoolAssociation', fromsubclass_=False):
        if self.TeacherReference:
            self.TeacherReference.export(outfile, level, namespace_, name_='TeacherReference', )
        for SchoolReference_ in self.SchoolReference:
            SchoolReference_.export(outfile, level, namespace_, name_='SchoolReference')
        if self.ProgramAssignment is not None:
            showIndent(outfile, level)
            outfile.write('<%sProgramAssignment>%s</%sProgramAssignment>\n' % (namespace_, self.gds_format_string(quote_xml(self.ProgramAssignment).encode(ExternalEncoding), input_name='ProgramAssignment'), namespace_))
        if self.InstructionalGradeLevels:
            self.InstructionalGradeLevels.export(outfile, level, namespace_, name_='InstructionalGradeLevels', )
        if self.AcademicSubjects:
            self.AcademicSubjects.export(outfile, level, namespace_, name_='AcademicSubjects', )
    def hasContent_(self):
        if (
            self.TeacherReference is not None or
            self.SchoolReference or
            self.ProgramAssignment is not None or
            self.InstructionalGradeLevels is not None or
            self.AcademicSubjects is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TeacherSchoolAssociation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TeacherReference is not None:
            showIndent(outfile, level)
            outfile.write('TeacherReference=model_.StaffReferenceType(\n')
            self.TeacherReference.exportLiteral(outfile, level, name_='TeacherReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('SchoolReference=[\n')
        level += 1
        for SchoolReference_ in self.SchoolReference:
            showIndent(outfile, level)
            outfile.write('model_.EducationalOrgReferenceType(\n')
            SchoolReference_.exportLiteral(outfile, level, name_='EducationalOrgReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ProgramAssignment is not None:
            showIndent(outfile, level)
            outfile.write('ProgramAssignment=%s,\n' % quote_python(self.ProgramAssignment).encode(ExternalEncoding))
        if self.InstructionalGradeLevels is not None:
            showIndent(outfile, level)
            outfile.write('InstructionalGradeLevels=model_.GradeLevelsType(\n')
            self.InstructionalGradeLevels.exportLiteral(outfile, level, name_='InstructionalGradeLevels')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AcademicSubjects is not None:
            showIndent(outfile, level)
            outfile.write('AcademicSubjects=model_.AcademicSubjectsType(\n')
            self.AcademicSubjects.exportLiteral(outfile, level, name_='AcademicSubjects')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TeacherReference':
            obj_ = StaffReferenceType.factory()
            obj_.build(child_)
            self.set_TeacherReference(obj_)
        elif nodeName_ == 'SchoolReference':
            obj_ = EducationalOrgReferenceType.factory()
            obj_.build(child_)
            self.SchoolReference.append(obj_)
        elif nodeName_ == 'ProgramAssignment':
            ProgramAssignment_ = child_.text
            ProgramAssignment_ = re_.sub(String_cleanup_pat_, " ", ProgramAssignment_).strip()
            ProgramAssignment_ = self.gds_validate_string(ProgramAssignment_, node, 'ProgramAssignment')
            self.ProgramAssignment = ProgramAssignment_
            self.validate_ProgramAssignmentType(self.ProgramAssignment)    # validate type ProgramAssignmentType
        elif nodeName_ == 'InstructionalGradeLevels':
            obj_ = GradeLevelsType.factory()
            obj_.build(child_)
            self.set_InstructionalGradeLevels(obj_)
        elif nodeName_ == 'AcademicSubjects':
            obj_ = AcademicSubjectsType.factory()
            obj_.build(child_)
            self.set_AcademicSubjects(obj_)
# end class TeacherSchoolAssociation


class TeacherSectionAssociation(GeneratedsSuper):
    """This association indicates the class sections to which a teacher is
    assigned to."""
    subclass = None
    superclass = None
    def __init__(self, TeacherReference=None, SectionReference=None, ClassroomPosition=None, BeginDate=None, EndDate=None, HighlyQualifiedTeacher=None):
        self.TeacherReference = TeacherReference
        self.SectionReference = SectionReference
        self.ClassroomPosition = ClassroomPosition
        self.BeginDate = BeginDate
        self.EndDate = EndDate
        self.HighlyQualifiedTeacher = HighlyQualifiedTeacher
    def factory(*args_, **kwargs_):
        if TeacherSectionAssociation.subclass:
            return TeacherSectionAssociation.subclass(*args_, **kwargs_)
        else:
            return TeacherSectionAssociation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TeacherReference(self): return self.TeacherReference
    def set_TeacherReference(self, TeacherReference): self.TeacherReference = TeacherReference
    def get_SectionReference(self): return self.SectionReference
    def set_SectionReference(self, SectionReference): self.SectionReference = SectionReference
    def get_ClassroomPosition(self): return self.ClassroomPosition
    def set_ClassroomPosition(self, ClassroomPosition): self.ClassroomPosition = ClassroomPosition
    def validate_ClassroomPositionType(self, value):
        # Validate type ClassroomPositionType, a restriction on xs:token.
        pass
    def get_BeginDate(self): return self.BeginDate
    def set_BeginDate(self, BeginDate): self.BeginDate = BeginDate
    def get_EndDate(self): return self.EndDate
    def set_EndDate(self, EndDate): self.EndDate = EndDate
    def get_HighlyQualifiedTeacher(self): return self.HighlyQualifiedTeacher
    def set_HighlyQualifiedTeacher(self, HighlyQualifiedTeacher): self.HighlyQualifiedTeacher = HighlyQualifiedTeacher
    def export(self, outfile, level, namespace_='', name_='TeacherSectionAssociation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TeacherSectionAssociation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TeacherSectionAssociation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TeacherSectionAssociation', fromsubclass_=False):
        if self.TeacherReference:
            self.TeacherReference.export(outfile, level, namespace_, name_='TeacherReference', )
        if self.SectionReference:
            self.SectionReference.export(outfile, level, namespace_, name_='SectionReference', )
        if self.ClassroomPosition is not None:
            showIndent(outfile, level)
            outfile.write('<%sClassroomPosition>%s</%sClassroomPosition>\n' % (namespace_, self.gds_format_string(quote_xml(self.ClassroomPosition).encode(ExternalEncoding), input_name='ClassroomPosition'), namespace_))
        if self.BeginDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sBeginDate>%s</%sBeginDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.BeginDate).encode(ExternalEncoding), input_name='BeginDate'), namespace_))
        if self.EndDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sEndDate>%s</%sEndDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.EndDate).encode(ExternalEncoding), input_name='EndDate'), namespace_))
        if self.HighlyQualifiedTeacher is not None:
            showIndent(outfile, level)
            outfile.write('<%sHighlyQualifiedTeacher>%s</%sHighlyQualifiedTeacher>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.HighlyQualifiedTeacher)), input_name='HighlyQualifiedTeacher'), namespace_))
    def hasContent_(self):
        if (
            self.TeacherReference is not None or
            self.SectionReference is not None or
            self.ClassroomPosition is not None or
            self.BeginDate is not None or
            self.EndDate is not None or
            self.HighlyQualifiedTeacher is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TeacherSectionAssociation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TeacherReference is not None:
            showIndent(outfile, level)
            outfile.write('TeacherReference=model_.StaffReferenceType(\n')
            self.TeacherReference.exportLiteral(outfile, level, name_='TeacherReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SectionReference is not None:
            showIndent(outfile, level)
            outfile.write('SectionReference=model_.SectionReferenceType(\n')
            self.SectionReference.exportLiteral(outfile, level, name_='SectionReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ClassroomPosition is not None:
            showIndent(outfile, level)
            outfile.write('ClassroomPosition=%s,\n' % quote_python(self.ClassroomPosition).encode(ExternalEncoding))
        if self.BeginDate is not None:
            showIndent(outfile, level)
            outfile.write('BeginDate=%s,\n' % quote_python(self.BeginDate).encode(ExternalEncoding))
        if self.EndDate is not None:
            showIndent(outfile, level)
            outfile.write('EndDate=%s,\n' % quote_python(self.EndDate).encode(ExternalEncoding))
        if self.HighlyQualifiedTeacher is not None:
            showIndent(outfile, level)
            outfile.write('HighlyQualifiedTeacher=%s,\n' % self.HighlyQualifiedTeacher)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TeacherReference':
            obj_ = StaffReferenceType.factory()
            obj_.build(child_)
            self.set_TeacherReference(obj_)
        elif nodeName_ == 'SectionReference':
            obj_ = SectionReferenceType.factory()
            obj_.build(child_)
            self.set_SectionReference(obj_)
        elif nodeName_ == 'ClassroomPosition':
            ClassroomPosition_ = child_.text
            ClassroomPosition_ = re_.sub(String_cleanup_pat_, " ", ClassroomPosition_).strip()
            ClassroomPosition_ = self.gds_validate_string(ClassroomPosition_, node, 'ClassroomPosition')
            self.ClassroomPosition = ClassroomPosition_
            self.validate_ClassroomPositionType(self.ClassroomPosition)    # validate type ClassroomPositionType
        elif nodeName_ == 'BeginDate':
            BeginDate_ = child_.text
            BeginDate_ = self.gds_validate_string(BeginDate_, node, 'BeginDate')
            self.BeginDate = BeginDate_
        elif nodeName_ == 'EndDate':
            EndDate_ = child_.text
            EndDate_ = self.gds_validate_string(EndDate_, node, 'EndDate')
            self.EndDate = EndDate_
        elif nodeName_ == 'HighlyQualifiedTeacher':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'HighlyQualifiedTeacher')
            self.HighlyQualifiedTeacher = ival_
# end class TeacherSectionAssociation


class ComplexObjectType(GeneratedsSuper):
    """This is the base type from which all entity elements are extended."""
    subclass = None
    superclass = None
    def __init__(self, id=None, extensiontype_=None):
        self.id = _cast(None, id)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ComplexObjectType.subclass:
            return ComplexObjectType.subclass(*args_, **kwargs_)
        else:
            return ComplexObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='ComplexObjectType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ComplexObjectType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ComplexObjectType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ComplexObjectType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ComplexObjectType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ComplexObjectType


class ReferenceType(GeneratedsSuper):
    """This is the base type for association references."""
    subclass = None
    superclass = None
    def __init__(self, ref=None, id=None, extensiontype_=None):
        self.ref = _cast(None, ref)
        self.id = _cast(None, id)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ReferenceType.subclass:
            return ReferenceType.subclass(*args_, **kwargs_)
        else:
            return ReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='ReferenceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferenceType'):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.append('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ReferenceType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ReferenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.append('ref')
            showIndent(outfile, level)
            outfile.write('ref = "%s",\n' % (self.ref,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.append('ref')
            self.ref = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReferenceType


class AccountReferenceType(ReferenceType):
    """Provides alternative references for finance accounts during
    interchange. Use XML IDREF to reference a course record that is
    included in the interchange"""
    subclass = None
    superclass = ReferenceType
    def __init__(self, ref=None, id=None, AccountIdentity=None):
        super(AccountReferenceType, self).__init__(ref, id, )
        self.AccountIdentity = AccountIdentity
    def factory(*args_, **kwargs_):
        if AccountReferenceType.subclass:
            return AccountReferenceType.subclass(*args_, **kwargs_)
        else:
            return AccountReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AccountIdentity(self): return self.AccountIdentity
    def set_AccountIdentity(self, AccountIdentity): self.AccountIdentity = AccountIdentity
    def export(self, outfile, level, namespace_='', name_='AccountReferenceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccountReferenceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccountReferenceType'):
        super(AccountReferenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AccountReferenceType')
    def exportChildren(self, outfile, level, namespace_='', name_='AccountReferenceType', fromsubclass_=False):
        super(AccountReferenceType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.AccountIdentity:
            self.AccountIdentity.export(outfile, level, namespace_, name_='AccountIdentity')
    def hasContent_(self):
        if (
            self.AccountIdentity is not None or
            super(AccountReferenceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AccountReferenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AccountReferenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AccountReferenceType, self).exportLiteralChildren(outfile, level, name_)
        if self.AccountIdentity is not None:
            showIndent(outfile, level)
            outfile.write('AccountIdentity=model_.AccountIdentityType(\n')
            self.AccountIdentity.exportLiteral(outfile, level, name_='AccountIdentity')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AccountReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AccountIdentity':
            obj_ = AccountIdentityType.factory()
            obj_.build(child_)
            self.set_AccountIdentity(obj_)
        super(AccountReferenceType, self).buildChildren(child_, node, nodeName_, True)
# end class AccountReferenceType


class AccountIdentityType(GeneratedsSuper):
    """Encapsulates the possible attributes that can be used to lookup the
    identiy of accounts."""
    subclass = None
    superclass = None
    def __init__(self, Fund=None, Function=None, Object=None):
        self.Fund = Fund
        self.Function = Function
        self.Object = Object
    def factory(*args_, **kwargs_):
        if AccountIdentityType.subclass:
            return AccountIdentityType.subclass(*args_, **kwargs_)
        else:
            return AccountIdentityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Fund(self): return self.Fund
    def set_Fund(self, Fund): self.Fund = Fund
    def validate_FundType(self, value):
        # Validate type FundType, a restriction on xs:string.
        pass
    def get_Function(self): return self.Function
    def set_Function(self, Function): self.Function = Function
    def validate_FunctionType(self, value):
        # Validate type FunctionType, a restriction on xs:string.
        pass
    def get_Object(self): return self.Object
    def set_Object(self, Object): self.Object = Object
    def validate_ObjectType(self, value):
        # Validate type ObjectType, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='AccountIdentityType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccountIdentityType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccountIdentityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AccountIdentityType', fromsubclass_=False):
        if self.Fund is not None:
            showIndent(outfile, level)
            outfile.write('<%sFund>%s</%sFund>\n' % (namespace_, self.gds_format_string(quote_xml(self.Fund).encode(ExternalEncoding), input_name='Fund'), namespace_))
        if self.Function is not None:
            showIndent(outfile, level)
            outfile.write('<%sFunction>%s</%sFunction>\n' % (namespace_, self.gds_format_string(quote_xml(self.Function).encode(ExternalEncoding), input_name='Function'), namespace_))
        if self.Object is not None:
            showIndent(outfile, level)
            outfile.write('<%sObject>%s</%sObject>\n' % (namespace_, self.gds_format_string(quote_xml(self.Object).encode(ExternalEncoding), input_name='Object'), namespace_))
    def hasContent_(self):
        if (
            self.Fund is not None or
            self.Function is not None or
            self.Object is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AccountIdentityType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Fund is not None:
            showIndent(outfile, level)
            outfile.write('Fund=%s,\n' % quote_python(self.Fund).encode(ExternalEncoding))
        if self.Function is not None:
            showIndent(outfile, level)
            outfile.write('Function=%s,\n' % quote_python(self.Function).encode(ExternalEncoding))
        if self.Object is not None:
            showIndent(outfile, level)
            outfile.write('Object=%s,\n' % quote_python(self.Object).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Fund':
            Fund_ = child_.text
            Fund_ = self.gds_validate_string(Fund_, node, 'Fund')
            self.Fund = Fund_
            self.validate_FundType(self.Fund)    # validate type FundType
        elif nodeName_ == 'Function':
            Function_ = child_.text
            Function_ = self.gds_validate_string(Function_, node, 'Function')
            self.Function = Function_
            self.validate_FunctionType(self.Function)    # validate type FunctionType
        elif nodeName_ == 'Object':
            Object_ = child_.text
            Object_ = self.gds_validate_string(Object_, node, 'Object')
            self.Object = Object_
            self.validate_ObjectType(self.Object)    # validate type ObjectType
# end class AccountIdentityType


class AssessmentReferenceType(ReferenceType):
    """Provides alternative references for assessments during interchange.
    Use XML IDREF to reference a course record that is included in
    the interchange"""
    subclass = None
    superclass = ReferenceType
    def __init__(self, ref=None, id=None, AssessmentIdentity=None):
        super(AssessmentReferenceType, self).__init__(ref, id, )
        self.AssessmentIdentity = AssessmentIdentity
    def factory(*args_, **kwargs_):
        if AssessmentReferenceType.subclass:
            return AssessmentReferenceType.subclass(*args_, **kwargs_)
        else:
            return AssessmentReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AssessmentIdentity(self): return self.AssessmentIdentity
    def set_AssessmentIdentity(self, AssessmentIdentity): self.AssessmentIdentity = AssessmentIdentity
    def export(self, outfile, level, namespace_='', name_='AssessmentReferenceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssessmentReferenceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AssessmentReferenceType'):
        super(AssessmentReferenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AssessmentReferenceType')
    def exportChildren(self, outfile, level, namespace_='', name_='AssessmentReferenceType', fromsubclass_=False):
        super(AssessmentReferenceType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.AssessmentIdentity:
            self.AssessmentIdentity.export(outfile, level, namespace_, name_='AssessmentIdentity')
    def hasContent_(self):
        if (
            self.AssessmentIdentity is not None or
            super(AssessmentReferenceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AssessmentReferenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AssessmentReferenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AssessmentReferenceType, self).exportLiteralChildren(outfile, level, name_)
        if self.AssessmentIdentity is not None:
            showIndent(outfile, level)
            outfile.write('AssessmentIdentity=model_.AssessmentIdentityType(\n')
            self.AssessmentIdentity.exportLiteral(outfile, level, name_='AssessmentIdentity')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AssessmentReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AssessmentIdentity':
            obj_ = AssessmentIdentityType.factory()
            obj_.build(child_)
            self.set_AssessmentIdentity(obj_)
        super(AssessmentReferenceType, self).buildChildren(child_, node, nodeName_, True)
# end class AssessmentReferenceType


class AssessmentIdentityType(GeneratedsSuper):
    """Encapsulates the possible attributes that can be used to lookup the
    identity of assessments."""
    subclass = None
    superclass = None
    def __init__(self, AssessmentIdentificationCode=None, AssessmentTitle=None, AcademicSubject=None, GradeLevelAssessed=None, Version=None):
        if AssessmentIdentificationCode is None:
            self.AssessmentIdentificationCode = []
        else:
            self.AssessmentIdentificationCode = AssessmentIdentificationCode
        self.AssessmentTitle = AssessmentTitle
        self.AcademicSubject = AcademicSubject
        self.GradeLevelAssessed = GradeLevelAssessed
        self.Version = Version
    def factory(*args_, **kwargs_):
        if AssessmentIdentityType.subclass:
            return AssessmentIdentityType.subclass(*args_, **kwargs_)
        else:
            return AssessmentIdentityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AssessmentIdentificationCode(self): return self.AssessmentIdentificationCode
    def set_AssessmentIdentificationCode(self, AssessmentIdentificationCode): self.AssessmentIdentificationCode = AssessmentIdentificationCode
    def add_AssessmentIdentificationCode(self, value): self.AssessmentIdentificationCode.append(value)
    def insert_AssessmentIdentificationCode(self, index, value): self.AssessmentIdentificationCode[index] = value
    def get_AssessmentTitle(self): return self.AssessmentTitle
    def set_AssessmentTitle(self, AssessmentTitle): self.AssessmentTitle = AssessmentTitle
    def validate_AssessmentTitle(self, value):
        # Validate type AssessmentTitle, a restriction on xs:string.
        pass
    def get_AcademicSubject(self): return self.AcademicSubject
    def set_AcademicSubject(self, AcademicSubject): self.AcademicSubject = AcademicSubject
    def validate_AcademicSubjectType(self, value):
        # Validate type AcademicSubjectType, a restriction on xs:token.
        pass
    def get_GradeLevelAssessed(self): return self.GradeLevelAssessed
    def set_GradeLevelAssessed(self, GradeLevelAssessed): self.GradeLevelAssessed = GradeLevelAssessed
    def validate_GradeLevelType(self, value):
        # Validate type GradeLevelType, a restriction on xs:token.
        pass
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def validate_Version(self, value):
        # Validate type Version, a restriction on xs:int.
        pass
    def export(self, outfile, level, namespace_='', name_='AssessmentIdentityType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssessmentIdentityType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AssessmentIdentityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AssessmentIdentityType', fromsubclass_=False):
        for AssessmentIdentificationCode_ in self.AssessmentIdentificationCode:
            AssessmentIdentificationCode_.export(outfile, level, namespace_, name_='AssessmentIdentificationCode')
        if self.AssessmentTitle is not None:
            showIndent(outfile, level)
            outfile.write('<%sAssessmentTitle>%s</%sAssessmentTitle>\n' % (namespace_, self.gds_format_string(quote_xml(self.AssessmentTitle).encode(ExternalEncoding), input_name='AssessmentTitle'), namespace_))
        if self.AcademicSubject is not None:
            showIndent(outfile, level)
            outfile.write('<%sAcademicSubject>%s</%sAcademicSubject>\n' % (namespace_, self.gds_format_string(quote_xml(self.AcademicSubject).encode(ExternalEncoding), input_name='AcademicSubject'), namespace_))
        if self.GradeLevelAssessed is not None:
            showIndent(outfile, level)
            outfile.write('<%sGradeLevelAssessed>%s</%sGradeLevelAssessed>\n' % (namespace_, self.gds_format_string(quote_xml(self.GradeLevelAssessed).encode(ExternalEncoding), input_name='GradeLevelAssessed'), namespace_))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('<%sVersion>%s</%sVersion>\n' % (namespace_, self.gds_format_integer(self.Version, input_name='Version'), namespace_))
    def hasContent_(self):
        if (
            self.AssessmentIdentificationCode or
            self.AssessmentTitle is not None or
            self.AcademicSubject is not None or
            self.GradeLevelAssessed is not None or
            self.Version is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AssessmentIdentityType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('AssessmentIdentificationCode=[\n')
        level += 1
        for AssessmentIdentificationCode_ in self.AssessmentIdentificationCode:
            showIndent(outfile, level)
            outfile.write('model_.AssessmentIdentificationCode(\n')
            AssessmentIdentificationCode_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.AssessmentTitle is not None:
            showIndent(outfile, level)
            outfile.write('AssessmentTitle=%s,\n' % quote_python(self.AssessmentTitle).encode(ExternalEncoding))
        if self.AcademicSubject is not None:
            showIndent(outfile, level)
            outfile.write('AcademicSubject=%s,\n' % quote_python(self.AcademicSubject).encode(ExternalEncoding))
        if self.GradeLevelAssessed is not None:
            showIndent(outfile, level)
            outfile.write('GradeLevelAssessed=%s,\n' % quote_python(self.GradeLevelAssessed).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%d,\n' % self.Version)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AssessmentIdentificationCode':
            obj_ = AssessmentIdentificationCode.factory()
            obj_.build(child_)
            self.AssessmentIdentificationCode.append(obj_)
        elif nodeName_ == 'AssessmentTitle':
            AssessmentTitle_ = child_.text
            AssessmentTitle_ = self.gds_validate_string(AssessmentTitle_, node, 'AssessmentTitle')
            self.AssessmentTitle = AssessmentTitle_
            self.validate_AssessmentTitle(self.AssessmentTitle)    # validate type AssessmentTitle
        elif nodeName_ == 'AcademicSubject':
            AcademicSubject_ = child_.text
            AcademicSubject_ = re_.sub(String_cleanup_pat_, " ", AcademicSubject_).strip()
            AcademicSubject_ = self.gds_validate_string(AcademicSubject_, node, 'AcademicSubject')
            self.AcademicSubject = AcademicSubject_
            self.validate_AcademicSubjectType(self.AcademicSubject)    # validate type AcademicSubjectType
        elif nodeName_ == 'GradeLevelAssessed':
            GradeLevelAssessed_ = child_.text
            GradeLevelAssessed_ = re_.sub(String_cleanup_pat_, " ", GradeLevelAssessed_).strip()
            GradeLevelAssessed_ = self.gds_validate_string(GradeLevelAssessed_, node, 'GradeLevelAssessed')
            self.GradeLevelAssessed = GradeLevelAssessed_
            self.validate_GradeLevelType(self.GradeLevelAssessed)    # validate type GradeLevelType
        elif nodeName_ == 'Version':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Version')
            self.Version = ival_
            self.validate_Version(self.Version)    # validate type Version
# end class AssessmentIdentityType


class AssessmentFamilyReferenceType(ReferenceType):
    """Provides alternative references for assessment families during
    interchange. Use XML IDREF to reference a course record that is
    included in the interchange"""
    subclass = None
    superclass = ReferenceType
    def __init__(self, ref=None, id=None, AssessmentFamilyIdentity=None):
        super(AssessmentFamilyReferenceType, self).__init__(ref, id, )
        self.AssessmentFamilyIdentity = AssessmentFamilyIdentity
    def factory(*args_, **kwargs_):
        if AssessmentFamilyReferenceType.subclass:
            return AssessmentFamilyReferenceType.subclass(*args_, **kwargs_)
        else:
            return AssessmentFamilyReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AssessmentFamilyIdentity(self): return self.AssessmentFamilyIdentity
    def set_AssessmentFamilyIdentity(self, AssessmentFamilyIdentity): self.AssessmentFamilyIdentity = AssessmentFamilyIdentity
    def export(self, outfile, level, namespace_='', name_='AssessmentFamilyReferenceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssessmentFamilyReferenceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AssessmentFamilyReferenceType'):
        super(AssessmentFamilyReferenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AssessmentFamilyReferenceType')
    def exportChildren(self, outfile, level, namespace_='', name_='AssessmentFamilyReferenceType', fromsubclass_=False):
        super(AssessmentFamilyReferenceType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.AssessmentFamilyIdentity:
            self.AssessmentFamilyIdentity.export(outfile, level, namespace_, name_='AssessmentFamilyIdentity')
    def hasContent_(self):
        if (
            self.AssessmentFamilyIdentity is not None or
            super(AssessmentFamilyReferenceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AssessmentFamilyReferenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AssessmentFamilyReferenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AssessmentFamilyReferenceType, self).exportLiteralChildren(outfile, level, name_)
        if self.AssessmentFamilyIdentity is not None:
            showIndent(outfile, level)
            outfile.write('AssessmentFamilyIdentity=model_.AssessmentFamilyIdentityType(\n')
            self.AssessmentFamilyIdentity.exportLiteral(outfile, level, name_='AssessmentFamilyIdentity')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AssessmentFamilyReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AssessmentFamilyIdentity':
            obj_ = AssessmentFamilyIdentityType.factory()
            obj_.build(child_)
            self.set_AssessmentFamilyIdentity(obj_)
        super(AssessmentFamilyReferenceType, self).buildChildren(child_, node, nodeName_, True)
# end class AssessmentFamilyReferenceType


class AssessmentFamilyIdentityType(GeneratedsSuper):
    """Encapsulates the possible attributes that can be used to lookup the
    identity of assessment families."""
    subclass = None
    superclass = None
    def __init__(self, AssessmentFamilyIdentificationCode=None, AssessmentFamilyTitle=None, Version=None):
        if AssessmentFamilyIdentificationCode is None:
            self.AssessmentFamilyIdentificationCode = []
        else:
            self.AssessmentFamilyIdentificationCode = AssessmentFamilyIdentificationCode
        self.AssessmentFamilyTitle = AssessmentFamilyTitle
        self.Version = Version
    def factory(*args_, **kwargs_):
        if AssessmentFamilyIdentityType.subclass:
            return AssessmentFamilyIdentityType.subclass(*args_, **kwargs_)
        else:
            return AssessmentFamilyIdentityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AssessmentFamilyIdentificationCode(self): return self.AssessmentFamilyIdentificationCode
    def set_AssessmentFamilyIdentificationCode(self, AssessmentFamilyIdentificationCode): self.AssessmentFamilyIdentificationCode = AssessmentFamilyIdentificationCode
    def add_AssessmentFamilyIdentificationCode(self, value): self.AssessmentFamilyIdentificationCode.append(value)
    def insert_AssessmentFamilyIdentificationCode(self, index, value): self.AssessmentFamilyIdentificationCode[index] = value
    def get_AssessmentFamilyTitle(self): return self.AssessmentFamilyTitle
    def set_AssessmentFamilyTitle(self, AssessmentFamilyTitle): self.AssessmentFamilyTitle = AssessmentFamilyTitle
    def validate_AssessmentTitle(self, value):
        # Validate type AssessmentTitle, a restriction on xs:string.
        pass
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def validate_Version(self, value):
        # Validate type Version, a restriction on xs:int.
        pass
    def export(self, outfile, level, namespace_='', name_='AssessmentFamilyIdentityType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssessmentFamilyIdentityType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AssessmentFamilyIdentityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AssessmentFamilyIdentityType', fromsubclass_=False):
        for AssessmentFamilyIdentificationCode_ in self.AssessmentFamilyIdentificationCode:
            AssessmentFamilyIdentificationCode_.export(outfile, level, namespace_, name_='AssessmentFamilyIdentificationCode')
        if self.AssessmentFamilyTitle is not None:
            showIndent(outfile, level)
            outfile.write('<%sAssessmentFamilyTitle>%s</%sAssessmentFamilyTitle>\n' % (namespace_, self.gds_format_string(quote_xml(self.AssessmentFamilyTitle).encode(ExternalEncoding), input_name='AssessmentFamilyTitle'), namespace_))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('<%sVersion>%s</%sVersion>\n' % (namespace_, self.gds_format_integer(self.Version, input_name='Version'), namespace_))
    def hasContent_(self):
        if (
            self.AssessmentFamilyIdentificationCode or
            self.AssessmentFamilyTitle is not None or
            self.Version is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AssessmentFamilyIdentityType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('AssessmentFamilyIdentificationCode=[\n')
        level += 1
        for AssessmentFamilyIdentificationCode_ in self.AssessmentFamilyIdentificationCode:
            showIndent(outfile, level)
            outfile.write('model_.AssessmentIdentificationCode(\n')
            AssessmentFamilyIdentificationCode_.exportLiteral(outfile, level, name_='AssessmentIdentificationCode')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.AssessmentFamilyTitle is not None:
            showIndent(outfile, level)
            outfile.write('AssessmentFamilyTitle=%s,\n' % quote_python(self.AssessmentFamilyTitle).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%d,\n' % self.Version)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AssessmentFamilyIdentificationCode':
            obj_ = AssessmentIdentificationCode.factory()
            obj_.build(child_)
            self.AssessmentFamilyIdentificationCode.append(obj_)
        elif nodeName_ == 'AssessmentFamilyTitle':
            AssessmentFamilyTitle_ = child_.text
            AssessmentFamilyTitle_ = self.gds_validate_string(AssessmentFamilyTitle_, node, 'AssessmentFamilyTitle')
            self.AssessmentFamilyTitle = AssessmentFamilyTitle_
            self.validate_AssessmentTitle(self.AssessmentFamilyTitle)    # validate type AssessmentTitle
        elif nodeName_ == 'Version':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Version')
            self.Version = ival_
            self.validate_Version(self.Version)    # validate type Version
# end class AssessmentFamilyIdentityType


class AssessmentItemReferenceType(ReferenceType):
    """Provides alternative references for assessment items during
    interchange. Use XML IDREF to reference a course record that is
    included in the interchange"""
    subclass = None
    superclass = ReferenceType
    def __init__(self, ref=None, id=None, AssessmentItemIdentity=None):
        super(AssessmentItemReferenceType, self).__init__(ref, id, )
        self.AssessmentItemIdentity = AssessmentItemIdentity
    def factory(*args_, **kwargs_):
        if AssessmentItemReferenceType.subclass:
            return AssessmentItemReferenceType.subclass(*args_, **kwargs_)
        else:
            return AssessmentItemReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AssessmentItemIdentity(self): return self.AssessmentItemIdentity
    def set_AssessmentItemIdentity(self, AssessmentItemIdentity): self.AssessmentItemIdentity = AssessmentItemIdentity
    def export(self, outfile, level, namespace_='', name_='AssessmentItemReferenceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssessmentItemReferenceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AssessmentItemReferenceType'):
        super(AssessmentItemReferenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AssessmentItemReferenceType')
    def exportChildren(self, outfile, level, namespace_='', name_='AssessmentItemReferenceType', fromsubclass_=False):
        super(AssessmentItemReferenceType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.AssessmentItemIdentity:
            self.AssessmentItemIdentity.export(outfile, level, namespace_, name_='AssessmentItemIdentity')
    def hasContent_(self):
        if (
            self.AssessmentItemIdentity is not None or
            super(AssessmentItemReferenceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AssessmentItemReferenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AssessmentItemReferenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AssessmentItemReferenceType, self).exportLiteralChildren(outfile, level, name_)
        if self.AssessmentItemIdentity is not None:
            showIndent(outfile, level)
            outfile.write('AssessmentItemIdentity=model_.AssessmentItemIdentityType(\n')
            self.AssessmentItemIdentity.exportLiteral(outfile, level, name_='AssessmentItemIdentity')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AssessmentItemReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AssessmentItemIdentity':
            obj_ = AssessmentItemIdentityType.factory()
            obj_.build(child_)
            self.set_AssessmentItemIdentity(obj_)
        super(AssessmentItemReferenceType, self).buildChildren(child_, node, nodeName_, True)
# end class AssessmentItemReferenceType


class AssessmentItemIdentityType(GeneratedsSuper):
    """Encapsulates the possible attributes that can be used to lookup the
    identity of assessment items."""
    subclass = None
    superclass = None
    def __init__(self, AssessmentItemIdentificationCode=None):
        self.AssessmentItemIdentificationCode = AssessmentItemIdentificationCode
    def factory(*args_, **kwargs_):
        if AssessmentItemIdentityType.subclass:
            return AssessmentItemIdentityType.subclass(*args_, **kwargs_)
        else:
            return AssessmentItemIdentityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AssessmentItemIdentificationCode(self): return self.AssessmentItemIdentificationCode
    def set_AssessmentItemIdentificationCode(self, AssessmentItemIdentificationCode): self.AssessmentItemIdentificationCode = AssessmentItemIdentificationCode
    def validate_IdentificationCode(self, value):
        # Validate type IdentificationCode, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='AssessmentItemIdentityType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssessmentItemIdentityType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AssessmentItemIdentityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AssessmentItemIdentityType', fromsubclass_=False):
        if self.AssessmentItemIdentificationCode is not None:
            showIndent(outfile, level)
            outfile.write('<%sAssessmentItemIdentificationCode>%s</%sAssessmentItemIdentificationCode>\n' % (namespace_, self.gds_format_string(quote_xml(self.AssessmentItemIdentificationCode).encode(ExternalEncoding), input_name='AssessmentItemIdentificationCode'), namespace_))
    def hasContent_(self):
        if (
            self.AssessmentItemIdentificationCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AssessmentItemIdentityType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AssessmentItemIdentificationCode is not None:
            showIndent(outfile, level)
            outfile.write('AssessmentItemIdentificationCode=%s,\n' % quote_python(self.AssessmentItemIdentificationCode).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AssessmentItemIdentificationCode':
            AssessmentItemIdentificationCode_ = child_.text
            AssessmentItemIdentificationCode_ = self.gds_validate_string(AssessmentItemIdentificationCode_, node, 'AssessmentItemIdentificationCode')
            self.AssessmentItemIdentificationCode = AssessmentItemIdentificationCode_
            self.validate_IdentificationCode(self.AssessmentItemIdentificationCode)    # validate type IdentificationCode
# end class AssessmentItemIdentityType


class BellScheduleReferenceType(ReferenceType):
    """Provides alternative references for a bell schedule during
    interchange. Use XML IDREF to reference a course record that is
    included in the interchange"""
    subclass = None
    superclass = ReferenceType
    def __init__(self, ref=None, id=None, BellScheduleIdentity=None):
        super(BellScheduleReferenceType, self).__init__(ref, id, )
        self.BellScheduleIdentity = BellScheduleIdentity
    def factory(*args_, **kwargs_):
        if BellScheduleReferenceType.subclass:
            return BellScheduleReferenceType.subclass(*args_, **kwargs_)
        else:
            return BellScheduleReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BellScheduleIdentity(self): return self.BellScheduleIdentity
    def set_BellScheduleIdentity(self, BellScheduleIdentity): self.BellScheduleIdentity = BellScheduleIdentity
    def export(self, outfile, level, namespace_='', name_='BellScheduleReferenceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BellScheduleReferenceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BellScheduleReferenceType'):
        super(BellScheduleReferenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BellScheduleReferenceType')
    def exportChildren(self, outfile, level, namespace_='', name_='BellScheduleReferenceType', fromsubclass_=False):
        super(BellScheduleReferenceType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.BellScheduleIdentity:
            self.BellScheduleIdentity.export(outfile, level, namespace_, name_='BellScheduleIdentity')
    def hasContent_(self):
        if (
            self.BellScheduleIdentity is not None or
            super(BellScheduleReferenceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BellScheduleReferenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(BellScheduleReferenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BellScheduleReferenceType, self).exportLiteralChildren(outfile, level, name_)
        if self.BellScheduleIdentity is not None:
            showIndent(outfile, level)
            outfile.write('BellScheduleIdentity=model_.BellScheduleIdentityType(\n')
            self.BellScheduleIdentity.exportLiteral(outfile, level, name_='BellScheduleIdentity')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(BellScheduleReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BellScheduleIdentity':
            obj_ = BellScheduleIdentityType.factory()
            obj_.build(child_)
            self.set_BellScheduleIdentity(obj_)
        super(BellScheduleReferenceType, self).buildChildren(child_, node, nodeName_, True)
# end class BellScheduleReferenceType


class BellScheduleIdentityType(GeneratedsSuper):
    """Encapsulate the attributes that can be used to lookup the bell
    schedule."""
    subclass = None
    superclass = None
    def __init__(self, SchoolId=None, GradeLevel=None, SchoolYear=None):
        self.SchoolId = SchoolId
        self.GradeLevel = GradeLevel
        self.SchoolYear = SchoolYear
    def factory(*args_, **kwargs_):
        if BellScheduleIdentityType.subclass:
            return BellScheduleIdentityType.subclass(*args_, **kwargs_)
        else:
            return BellScheduleIdentityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SchoolId(self): return self.SchoolId
    def set_SchoolId(self, SchoolId): self.SchoolId = SchoolId
    def validate_IdentificationCode(self, value):
        # Validate type IdentificationCode, a restriction on xs:string.
        pass
    def get_GradeLevel(self): return self.GradeLevel
    def set_GradeLevel(self, GradeLevel): self.GradeLevel = GradeLevel
    def validate_GradeLevelType(self, value):
        # Validate type GradeLevelType, a restriction on xs:token.
        pass
    def get_SchoolYear(self): return self.SchoolYear
    def set_SchoolYear(self, SchoolYear): self.SchoolYear = SchoolYear
    def validate_SchoolYearType(self, value):
        # Validate type SchoolYearType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='BellScheduleIdentityType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BellScheduleIdentityType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BellScheduleIdentityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BellScheduleIdentityType', fromsubclass_=False):
        if self.SchoolId is not None:
            showIndent(outfile, level)
            outfile.write('<%sSchoolId>%s</%sSchoolId>\n' % (namespace_, self.gds_format_string(quote_xml(self.SchoolId).encode(ExternalEncoding), input_name='SchoolId'), namespace_))
        if self.GradeLevel is not None:
            showIndent(outfile, level)
            outfile.write('<%sGradeLevel>%s</%sGradeLevel>\n' % (namespace_, self.gds_format_string(quote_xml(self.GradeLevel).encode(ExternalEncoding), input_name='GradeLevel'), namespace_))
        if self.SchoolYear is not None:
            showIndent(outfile, level)
            outfile.write('<%sSchoolYear>%s</%sSchoolYear>\n' % (namespace_, self.gds_format_string(quote_xml(self.SchoolYear).encode(ExternalEncoding), input_name='SchoolYear'), namespace_))
    def hasContent_(self):
        if (
            self.SchoolId is not None or
            self.GradeLevel is not None or
            self.SchoolYear is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BellScheduleIdentityType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SchoolId is not None:
            showIndent(outfile, level)
            outfile.write('SchoolId=%s,\n' % quote_python(self.SchoolId).encode(ExternalEncoding))
        if self.GradeLevel is not None:
            showIndent(outfile, level)
            outfile.write('GradeLevel=%s,\n' % quote_python(self.GradeLevel).encode(ExternalEncoding))
        if self.SchoolYear is not None:
            showIndent(outfile, level)
            outfile.write('SchoolYear=%s,\n' % quote_python(self.SchoolYear).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SchoolId':
            SchoolId_ = child_.text
            SchoolId_ = self.gds_validate_string(SchoolId_, node, 'SchoolId')
            self.SchoolId = SchoolId_
            self.validate_IdentificationCode(self.SchoolId)    # validate type IdentificationCode
        elif nodeName_ == 'GradeLevel':
            GradeLevel_ = child_.text
            GradeLevel_ = re_.sub(String_cleanup_pat_, " ", GradeLevel_).strip()
            GradeLevel_ = self.gds_validate_string(GradeLevel_, node, 'GradeLevel')
            self.GradeLevel = GradeLevel_
            self.validate_GradeLevelType(self.GradeLevel)    # validate type GradeLevelType
        elif nodeName_ == 'SchoolYear':
            SchoolYear_ = child_.text
            SchoolYear_ = re_.sub(String_cleanup_pat_, " ", SchoolYear_).strip()
            SchoolYear_ = self.gds_validate_string(SchoolYear_, node, 'SchoolYear')
            self.SchoolYear = SchoolYear_
            self.validate_SchoolYearType(self.SchoolYear)    # validate type SchoolYearType
# end class BellScheduleIdentityType


class CohortReferenceType(ReferenceType):
    """Provides alternative references for cohorts during interchange. Use
    XML IDREF to reference a course record that is included in the
    interchange"""
    subclass = None
    superclass = ReferenceType
    def __init__(self, ref=None, id=None, CohortIdentity=None):
        super(CohortReferenceType, self).__init__(ref, id, )
        self.CohortIdentity = CohortIdentity
    def factory(*args_, **kwargs_):
        if CohortReferenceType.subclass:
            return CohortReferenceType.subclass(*args_, **kwargs_)
        else:
            return CohortReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CohortIdentity(self): return self.CohortIdentity
    def set_CohortIdentity(self, CohortIdentity): self.CohortIdentity = CohortIdentity
    def export(self, outfile, level, namespace_='', name_='CohortReferenceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CohortReferenceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CohortReferenceType'):
        super(CohortReferenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CohortReferenceType')
    def exportChildren(self, outfile, level, namespace_='', name_='CohortReferenceType', fromsubclass_=False):
        super(CohortReferenceType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.CohortIdentity:
            self.CohortIdentity.export(outfile, level, namespace_, name_='CohortIdentity')
    def hasContent_(self):
        if (
            self.CohortIdentity is not None or
            super(CohortReferenceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CohortReferenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CohortReferenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CohortReferenceType, self).exportLiteralChildren(outfile, level, name_)
        if self.CohortIdentity is not None:
            showIndent(outfile, level)
            outfile.write('CohortIdentity=model_.CohortIdentityType(\n')
            self.CohortIdentity.exportLiteral(outfile, level, name_='CohortIdentity')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(CohortReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CohortIdentity':
            obj_ = CohortIdentityType.factory()
            obj_.build(child_)
            self.set_CohortIdentity(obj_)
        super(CohortReferenceType, self).buildChildren(child_, node, nodeName_, True)
# end class CohortReferenceType


class CohortIdentityType(GeneratedsSuper):
    """Encapsulates the possible attributes that can be used to lookup the
    identity of cohorts."""
    subclass = None
    superclass = None
    def __init__(self, EducationOrgReference=None, CohortIdentifier=None):
        self.EducationOrgReference = EducationOrgReference
        self.CohortIdentifier = CohortIdentifier
    def factory(*args_, **kwargs_):
        if CohortIdentityType.subclass:
            return CohortIdentityType.subclass(*args_, **kwargs_)
        else:
            return CohortIdentityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EducationOrgReference(self): return self.EducationOrgReference
    def set_EducationOrgReference(self, EducationOrgReference): self.EducationOrgReference = EducationOrgReference
    def get_CohortIdentifier(self): return self.CohortIdentifier
    def set_CohortIdentifier(self, CohortIdentifier): self.CohortIdentifier = CohortIdentifier
    def validate_CohortIdentifier(self, value):
        # Validate type CohortIdentifier, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='CohortIdentityType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CohortIdentityType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CohortIdentityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CohortIdentityType', fromsubclass_=False):
        if self.EducationOrgReference:
            self.EducationOrgReference.export(outfile, level, namespace_, name_='EducationOrgReference', )
        if self.CohortIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('<%sCohortIdentifier>%s</%sCohortIdentifier>\n' % (namespace_, self.gds_format_string(quote_xml(self.CohortIdentifier).encode(ExternalEncoding), input_name='CohortIdentifier'), namespace_))
    def hasContent_(self):
        if (
            self.EducationOrgReference is not None or
            self.CohortIdentifier is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CohortIdentityType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.EducationOrgReference is not None:
            showIndent(outfile, level)
            outfile.write('EducationOrgReference=model_.EducationalOrgReferenceType(\n')
            self.EducationOrgReference.exportLiteral(outfile, level, name_='EducationOrgReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CohortIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('CohortIdentifier=%s,\n' % quote_python(self.CohortIdentifier).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EducationOrgReference':
            obj_ = EducationalOrgReferenceType.factory()
            obj_.build(child_)
            self.set_EducationOrgReference(obj_)
        elif nodeName_ == 'CohortIdentifier':
            CohortIdentifier_ = child_.text
            CohortIdentifier_ = self.gds_validate_string(CohortIdentifier_, node, 'CohortIdentifier')
            self.CohortIdentifier = CohortIdentifier_
            self.validate_CohortIdentifier(self.CohortIdentifier)    # validate type CohortIdentifier
# end class CohortIdentityType


class CourseReferenceType(ReferenceType):
    """Provides alternative references for courses during interchange. Use
    XML IDREF to reference a course record that is included in the
    interchange"""
    subclass = None
    superclass = ReferenceType
    def __init__(self, ref=None, id=None, CourseIdentity=None):
        super(CourseReferenceType, self).__init__(ref, id, )
        self.CourseIdentity = CourseIdentity
    def factory(*args_, **kwargs_):
        if CourseReferenceType.subclass:
            return CourseReferenceType.subclass(*args_, **kwargs_)
        else:
            return CourseReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CourseIdentity(self): return self.CourseIdentity
    def set_CourseIdentity(self, CourseIdentity): self.CourseIdentity = CourseIdentity
    def export(self, outfile, level, namespace_='', name_='CourseReferenceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CourseReferenceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CourseReferenceType'):
        super(CourseReferenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CourseReferenceType')
    def exportChildren(self, outfile, level, namespace_='', name_='CourseReferenceType', fromsubclass_=False):
        super(CourseReferenceType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.CourseIdentity:
            self.CourseIdentity.export(outfile, level, namespace_, name_='CourseIdentity')
    def hasContent_(self):
        if (
            self.CourseIdentity is not None or
            super(CourseReferenceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CourseReferenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CourseReferenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CourseReferenceType, self).exportLiteralChildren(outfile, level, name_)
        if self.CourseIdentity is not None:
            showIndent(outfile, level)
            outfile.write('CourseIdentity=model_.CourseIdentityType(\n')
            self.CourseIdentity.exportLiteral(outfile, level, name_='CourseIdentity')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(CourseReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CourseIdentity':
            obj_ = CourseIdentityType.factory()
            obj_.build(child_)
            self.set_CourseIdentity(obj_)
        super(CourseReferenceType, self).buildChildren(child_, node, nodeName_, True)
# end class CourseReferenceType


class CourseIdentityType(GeneratedsSuper):
    """Encapsulates the possible attributes that can be used to lookup the
    identity of courses."""
    subclass = None
    superclass = None
    def __init__(self, EducationOrganizationID=None, LocalCourseCode=None, CourseCode=None, SchoolYear=None):
        self.EducationOrganizationID = EducationOrganizationID
        self.LocalCourseCode = LocalCourseCode
        if CourseCode is None:
            self.CourseCode = []
        else:
            self.CourseCode = CourseCode
        self.SchoolYear = SchoolYear
    def factory(*args_, **kwargs_):
        if CourseIdentityType.subclass:
            return CourseIdentityType.subclass(*args_, **kwargs_)
        else:
            return CourseIdentityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EducationOrganizationID(self): return self.EducationOrganizationID
    def set_EducationOrganizationID(self, EducationOrganizationID): self.EducationOrganizationID = EducationOrganizationID
    def validate_IdentificationCode(self, value):
        # Validate type IdentificationCode, a restriction on xs:string.
        pass
    def get_LocalCourseCode(self): return self.LocalCourseCode
    def set_LocalCourseCode(self, LocalCourseCode): self.LocalCourseCode = LocalCourseCode
    def validate_LocalCourseCode(self, value):
        # Validate type LocalCourseCode, a restriction on xs:string.
        pass
    def get_CourseCode(self): return self.CourseCode
    def set_CourseCode(self, CourseCode): self.CourseCode = CourseCode
    def add_CourseCode(self, value): self.CourseCode.append(value)
    def insert_CourseCode(self, index, value): self.CourseCode[index] = value
    def get_SchoolYear(self): return self.SchoolYear
    def set_SchoolYear(self, SchoolYear): self.SchoolYear = SchoolYear
    def validate_SchoolYearType(self, value):
        # Validate type SchoolYearType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='CourseIdentityType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CourseIdentityType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CourseIdentityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CourseIdentityType', fromsubclass_=False):
        if self.EducationOrganizationID is not None:
            showIndent(outfile, level)
            outfile.write('<%sEducationOrganizationID>%s</%sEducationOrganizationID>\n' % (namespace_, self.gds_format_string(quote_xml(self.EducationOrganizationID).encode(ExternalEncoding), input_name='EducationOrganizationID'), namespace_))
        if self.LocalCourseCode is not None:
            showIndent(outfile, level)
            outfile.write('<%sLocalCourseCode>%s</%sLocalCourseCode>\n' % (namespace_, self.gds_format_string(quote_xml(self.LocalCourseCode).encode(ExternalEncoding), input_name='LocalCourseCode'), namespace_))
        for CourseCode_ in self.CourseCode:
            CourseCode_.export(outfile, level, namespace_, name_='CourseCode')
        if self.SchoolYear is not None:
            showIndent(outfile, level)
            outfile.write('<%sSchoolYear>%s</%sSchoolYear>\n' % (namespace_, self.gds_format_string(quote_xml(self.SchoolYear).encode(ExternalEncoding), input_name='SchoolYear'), namespace_))
    def hasContent_(self):
        if (
            self.EducationOrganizationID is not None or
            self.LocalCourseCode is not None or
            self.CourseCode or
            self.SchoolYear is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CourseIdentityType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.EducationOrganizationID is not None:
            showIndent(outfile, level)
            outfile.write('EducationOrganizationID=%s,\n' % quote_python(self.EducationOrganizationID).encode(ExternalEncoding))
        if self.LocalCourseCode is not None:
            showIndent(outfile, level)
            outfile.write('LocalCourseCode=%s,\n' % quote_python(self.LocalCourseCode).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('CourseCode=[\n')
        level += 1
        for CourseCode_ in self.CourseCode:
            showIndent(outfile, level)
            outfile.write('model_.CourseCode(\n')
            CourseCode_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.SchoolYear is not None:
            showIndent(outfile, level)
            outfile.write('SchoolYear=%s,\n' % quote_python(self.SchoolYear).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EducationOrganizationID':
            EducationOrganizationID_ = child_.text
            EducationOrganizationID_ = self.gds_validate_string(EducationOrganizationID_, node, 'EducationOrganizationID')
            self.EducationOrganizationID = EducationOrganizationID_
            self.validate_IdentificationCode(self.EducationOrganizationID)    # validate type IdentificationCode
        elif nodeName_ == 'LocalCourseCode':
            LocalCourseCode_ = child_.text
            LocalCourseCode_ = self.gds_validate_string(LocalCourseCode_, node, 'LocalCourseCode')
            self.LocalCourseCode = LocalCourseCode_
            self.validate_LocalCourseCode(self.LocalCourseCode)    # validate type LocalCourseCode
        elif nodeName_ == 'CourseCode':
            obj_ = CourseCode.factory()
            obj_.build(child_)
            self.CourseCode.append(obj_)
        elif nodeName_ == 'SchoolYear':
            SchoolYear_ = child_.text
            SchoolYear_ = re_.sub(String_cleanup_pat_, " ", SchoolYear_).strip()
            SchoolYear_ = self.gds_validate_string(SchoolYear_, node, 'SchoolYear')
            self.SchoolYear = SchoolYear_
            self.validate_SchoolYearType(self.SchoolYear)    # validate type SchoolYearType
# end class CourseIdentityType


class EducationalOrgReferenceType(ReferenceType):
    """Provides alternative references for Educational Organization (ESC,
    LEA, school) reference during interchange. Use XML IDREF to
    reference an educational organization record that is included in
    the interchange"""
    subclass = None
    superclass = ReferenceType
    def __init__(self, ref=None, id=None, EducationalOrgIdentity=None):
        super(EducationalOrgReferenceType, self).__init__(ref, id, )
        self.EducationalOrgIdentity = EducationalOrgIdentity
    def factory(*args_, **kwargs_):
        if EducationalOrgReferenceType.subclass:
            return EducationalOrgReferenceType.subclass(*args_, **kwargs_)
        else:
            return EducationalOrgReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EducationalOrgIdentity(self): return self.EducationalOrgIdentity
    def set_EducationalOrgIdentity(self, EducationalOrgIdentity): self.EducationalOrgIdentity = EducationalOrgIdentity
    def export(self, outfile, level, namespace_='', name_='EducationalOrgReferenceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EducationalOrgReferenceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EducationalOrgReferenceType'):
        super(EducationalOrgReferenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EducationalOrgReferenceType')
    def exportChildren(self, outfile, level, namespace_='', name_='EducationalOrgReferenceType', fromsubclass_=False):
        super(EducationalOrgReferenceType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.EducationalOrgIdentity:
            self.EducationalOrgIdentity.export(outfile, level, namespace_, name_='EducationalOrgIdentity')
    def hasContent_(self):
        if (
            self.EducationalOrgIdentity is not None or
            super(EducationalOrgReferenceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EducationalOrgReferenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EducationalOrgReferenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EducationalOrgReferenceType, self).exportLiteralChildren(outfile, level, name_)
        if self.EducationalOrgIdentity is not None:
            showIndent(outfile, level)
            outfile.write('EducationalOrgIdentity=model_.EducationalOrgIdentityType(\n')
            self.EducationalOrgIdentity.exportLiteral(outfile, level, name_='EducationalOrgIdentity')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(EducationalOrgReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EducationalOrgIdentity':
            obj_ = EducationalOrgIdentityType.factory()
            obj_.build(child_)
            self.set_EducationalOrgIdentity(obj_)
        super(EducationalOrgReferenceType, self).buildChildren(child_, node, nodeName_, True)
# end class EducationalOrgReferenceType


class EducationalOrgIdentityType(GeneratedsSuper):
    """Encapsulates the possible attributes that can be used to lookup the
    identity of educational orgnizations, specially ESCs, LEAs
    (districts), and schooles."""
    subclass = None
    superclass = None
    def __init__(self, StateOrganizationId=None, EducationOrgIdentificationCode=None):
        self.StateOrganizationId = StateOrganizationId
        if EducationOrgIdentificationCode is None:
            self.EducationOrgIdentificationCode = []
        else:
            self.EducationOrgIdentificationCode = EducationOrgIdentificationCode
    def factory(*args_, **kwargs_):
        if EducationalOrgIdentityType.subclass:
            return EducationalOrgIdentityType.subclass(*args_, **kwargs_)
        else:
            return EducationalOrgIdentityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StateOrganizationId(self): return self.StateOrganizationId
    def set_StateOrganizationId(self, StateOrganizationId): self.StateOrganizationId = StateOrganizationId
    def validate_IdentificationCode(self, value):
        # Validate type IdentificationCode, a restriction on xs:string.
        pass
    def get_EducationOrgIdentificationCode(self): return self.EducationOrgIdentificationCode
    def set_EducationOrgIdentificationCode(self, EducationOrgIdentificationCode): self.EducationOrgIdentificationCode = EducationOrgIdentificationCode
    def add_EducationOrgIdentificationCode(self, value): self.EducationOrgIdentificationCode.append(value)
    def insert_EducationOrgIdentificationCode(self, index, value): self.EducationOrgIdentificationCode[index] = value
    def export(self, outfile, level, namespace_='', name_='EducationalOrgIdentityType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EducationalOrgIdentityType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EducationalOrgIdentityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EducationalOrgIdentityType', fromsubclass_=False):
        if self.StateOrganizationId is not None:
            showIndent(outfile, level)
            outfile.write('<%sStateOrganizationId>%s</%sStateOrganizationId>\n' % (namespace_, self.gds_format_string(quote_xml(self.StateOrganizationId).encode(ExternalEncoding), input_name='StateOrganizationId'), namespace_))
        for EducationOrgIdentificationCode_ in self.EducationOrgIdentificationCode:
            EducationOrgIdentificationCode_.export(outfile, level, namespace_, name_='EducationOrgIdentificationCode')
    def hasContent_(self):
        if (
            self.StateOrganizationId is not None or
            self.EducationOrgIdentificationCode
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EducationalOrgIdentityType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StateOrganizationId is not None:
            showIndent(outfile, level)
            outfile.write('StateOrganizationId=%s,\n' % quote_python(self.StateOrganizationId).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('EducationOrgIdentificationCode=[\n')
        level += 1
        for EducationOrgIdentificationCode_ in self.EducationOrgIdentificationCode:
            showIndent(outfile, level)
            outfile.write('model_.EducationOrgIdentificationCode(\n')
            EducationOrgIdentificationCode_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StateOrganizationId':
            StateOrganizationId_ = child_.text
            StateOrganizationId_ = self.gds_validate_string(StateOrganizationId_, node, 'StateOrganizationId')
            self.StateOrganizationId = StateOrganizationId_
            self.validate_IdentificationCode(self.StateOrganizationId)    # validate type IdentificationCode
        elif nodeName_ == 'EducationOrgIdentificationCode':
            obj_ = EducationOrgIdentificationCode.factory()
            obj_.build(child_)
            self.EducationOrgIdentificationCode.append(obj_)
# end class EducationalOrgIdentityType


class GradingPeriodReferenceType(ReferenceType):
    """Provides alternative references for grading periodss. Use XML IDREF
    to reference a program record that is included in the
    interchange"""
    subclass = None
    superclass = ReferenceType
    def __init__(self, ref=None, id=None, GradingPeriodIdentity=None):
        super(GradingPeriodReferenceType, self).__init__(ref, id, )
        self.GradingPeriodIdentity = GradingPeriodIdentity
    def factory(*args_, **kwargs_):
        if GradingPeriodReferenceType.subclass:
            return GradingPeriodReferenceType.subclass(*args_, **kwargs_)
        else:
            return GradingPeriodReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GradingPeriodIdentity(self): return self.GradingPeriodIdentity
    def set_GradingPeriodIdentity(self, GradingPeriodIdentity): self.GradingPeriodIdentity = GradingPeriodIdentity
    def export(self, outfile, level, namespace_='', name_='GradingPeriodReferenceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GradingPeriodReferenceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GradingPeriodReferenceType'):
        super(GradingPeriodReferenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GradingPeriodReferenceType')
    def exportChildren(self, outfile, level, namespace_='', name_='GradingPeriodReferenceType', fromsubclass_=False):
        super(GradingPeriodReferenceType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.GradingPeriodIdentity:
            self.GradingPeriodIdentity.export(outfile, level, namespace_, name_='GradingPeriodIdentity')
    def hasContent_(self):
        if (
            self.GradingPeriodIdentity is not None or
            super(GradingPeriodReferenceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GradingPeriodReferenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GradingPeriodReferenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GradingPeriodReferenceType, self).exportLiteralChildren(outfile, level, name_)
        if self.GradingPeriodIdentity is not None:
            showIndent(outfile, level)
            outfile.write('GradingPeriodIdentity=model_.GradingPeriodIdentityType(\n')
            self.GradingPeriodIdentity.exportLiteral(outfile, level, name_='GradingPeriodIdentity')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(GradingPeriodReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GradingPeriodIdentity':
            obj_ = GradingPeriodIdentityType.factory()
            obj_.build(child_)
            self.set_GradingPeriodIdentity(obj_)
        super(GradingPeriodReferenceType, self).buildChildren(child_, node, nodeName_, True)
# end class GradingPeriodReferenceType


class GradingPeriodIdentityType(GeneratedsSuper):
    """Encapsulates the possible attributes that can be used to lookup the
    grading period."""
    subclass = None
    superclass = None
    def __init__(self, SchoolYear=None, GradingPeriod=None):
        self.SchoolYear = SchoolYear
        self.GradingPeriod = GradingPeriod
    def factory(*args_, **kwargs_):
        if GradingPeriodIdentityType.subclass:
            return GradingPeriodIdentityType.subclass(*args_, **kwargs_)
        else:
            return GradingPeriodIdentityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SchoolYear(self): return self.SchoolYear
    def set_SchoolYear(self, SchoolYear): self.SchoolYear = SchoolYear
    def validate_SchoolYearType(self, value):
        # Validate type SchoolYearType, a restriction on xs:token.
        pass
    def get_GradingPeriod(self): return self.GradingPeriod
    def set_GradingPeriod(self, GradingPeriod): self.GradingPeriod = GradingPeriod
    def validate_GradingPeriodType(self, value):
        # Validate type GradingPeriodType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='GradingPeriodIdentityType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GradingPeriodIdentityType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GradingPeriodIdentityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GradingPeriodIdentityType', fromsubclass_=False):
        if self.SchoolYear is not None:
            showIndent(outfile, level)
            outfile.write('<%sSchoolYear>%s</%sSchoolYear>\n' % (namespace_, self.gds_format_string(quote_xml(self.SchoolYear).encode(ExternalEncoding), input_name='SchoolYear'), namespace_))
        if self.GradingPeriod is not None:
            showIndent(outfile, level)
            outfile.write('<%sGradingPeriod>%s</%sGradingPeriod>\n' % (namespace_, self.gds_format_string(quote_xml(self.GradingPeriod).encode(ExternalEncoding), input_name='GradingPeriod'), namespace_))
    def hasContent_(self):
        if (
            self.SchoolYear is not None or
            self.GradingPeriod is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GradingPeriodIdentityType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SchoolYear is not None:
            showIndent(outfile, level)
            outfile.write('SchoolYear=%s,\n' % quote_python(self.SchoolYear).encode(ExternalEncoding))
        if self.GradingPeriod is not None:
            showIndent(outfile, level)
            outfile.write('GradingPeriod=%s,\n' % quote_python(self.GradingPeriod).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SchoolYear':
            SchoolYear_ = child_.text
            SchoolYear_ = re_.sub(String_cleanup_pat_, " ", SchoolYear_).strip()
            SchoolYear_ = self.gds_validate_string(SchoolYear_, node, 'SchoolYear')
            self.SchoolYear = SchoolYear_
            self.validate_SchoolYearType(self.SchoolYear)    # validate type SchoolYearType
        elif nodeName_ == 'GradingPeriod':
            GradingPeriod_ = child_.text
            GradingPeriod_ = re_.sub(String_cleanup_pat_, " ", GradingPeriod_).strip()
            GradingPeriod_ = self.gds_validate_string(GradingPeriod_, node, 'GradingPeriod')
            self.GradingPeriod = GradingPeriod_
            self.validate_GradingPeriodType(self.GradingPeriod)    # validate type GradingPeriodType
# end class GradingPeriodIdentityType


class ObjectiveAssessmentReferenceType(ReferenceType):
    """Provides alternative references for objective assessments during
    interchange. Use XML IDREF to reference a course record that is
    included in the interchange"""
    subclass = None
    superclass = ReferenceType
    def __init__(self, ref=None, id=None, ObjectiveAssessmentIdentity=None):
        super(ObjectiveAssessmentReferenceType, self).__init__(ref, id, )
        self.ObjectiveAssessmentIdentity = ObjectiveAssessmentIdentity
    def factory(*args_, **kwargs_):
        if ObjectiveAssessmentReferenceType.subclass:
            return ObjectiveAssessmentReferenceType.subclass(*args_, **kwargs_)
        else:
            return ObjectiveAssessmentReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ObjectiveAssessmentIdentity(self): return self.ObjectiveAssessmentIdentity
    def set_ObjectiveAssessmentIdentity(self, ObjectiveAssessmentIdentity): self.ObjectiveAssessmentIdentity = ObjectiveAssessmentIdentity
    def export(self, outfile, level, namespace_='', name_='ObjectiveAssessmentReferenceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectiveAssessmentReferenceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ObjectiveAssessmentReferenceType'):
        super(ObjectiveAssessmentReferenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectiveAssessmentReferenceType')
    def exportChildren(self, outfile, level, namespace_='', name_='ObjectiveAssessmentReferenceType', fromsubclass_=False):
        super(ObjectiveAssessmentReferenceType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.ObjectiveAssessmentIdentity:
            self.ObjectiveAssessmentIdentity.export(outfile, level, namespace_, name_='ObjectiveAssessmentIdentity')
    def hasContent_(self):
        if (
            self.ObjectiveAssessmentIdentity is not None or
            super(ObjectiveAssessmentReferenceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ObjectiveAssessmentReferenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ObjectiveAssessmentReferenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ObjectiveAssessmentReferenceType, self).exportLiteralChildren(outfile, level, name_)
        if self.ObjectiveAssessmentIdentity is not None:
            showIndent(outfile, level)
            outfile.write('ObjectiveAssessmentIdentity=model_.ObjectiveAssessmentIdentityType(\n')
            self.ObjectiveAssessmentIdentity.exportLiteral(outfile, level, name_='ObjectiveAssessmentIdentity')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(ObjectiveAssessmentReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ObjectiveAssessmentIdentity':
            obj_ = ObjectiveAssessmentIdentityType.factory()
            obj_.build(child_)
            self.set_ObjectiveAssessmentIdentity(obj_)
        super(ObjectiveAssessmentReferenceType, self).buildChildren(child_, node, nodeName_, True)
# end class ObjectiveAssessmentReferenceType


class ObjectiveAssessmentIdentityType(GeneratedsSuper):
    """Encapsulates the possible attributes that can be used to lookup the
    identity of assessment objectives."""
    subclass = None
    superclass = None
    def __init__(self, ObjectiveAssessmentIdentificationCode=None):
        self.ObjectiveAssessmentIdentificationCode = ObjectiveAssessmentIdentificationCode
    def factory(*args_, **kwargs_):
        if ObjectiveAssessmentIdentityType.subclass:
            return ObjectiveAssessmentIdentityType.subclass(*args_, **kwargs_)
        else:
            return ObjectiveAssessmentIdentityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ObjectiveAssessmentIdentificationCode(self): return self.ObjectiveAssessmentIdentificationCode
    def set_ObjectiveAssessmentIdentificationCode(self, ObjectiveAssessmentIdentificationCode): self.ObjectiveAssessmentIdentificationCode = ObjectiveAssessmentIdentificationCode
    def validate_IdentificationCode(self, value):
        # Validate type IdentificationCode, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='ObjectiveAssessmentIdentityType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectiveAssessmentIdentityType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ObjectiveAssessmentIdentityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ObjectiveAssessmentIdentityType', fromsubclass_=False):
        if self.ObjectiveAssessmentIdentificationCode is not None:
            showIndent(outfile, level)
            outfile.write('<%sObjectiveAssessmentIdentificationCode>%s</%sObjectiveAssessmentIdentificationCode>\n' % (namespace_, self.gds_format_string(quote_xml(self.ObjectiveAssessmentIdentificationCode).encode(ExternalEncoding), input_name='ObjectiveAssessmentIdentificationCode'), namespace_))
    def hasContent_(self):
        if (
            self.ObjectiveAssessmentIdentificationCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ObjectiveAssessmentIdentityType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ObjectiveAssessmentIdentificationCode is not None:
            showIndent(outfile, level)
            outfile.write('ObjectiveAssessmentIdentificationCode=%s,\n' % quote_python(self.ObjectiveAssessmentIdentificationCode).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ObjectiveAssessmentIdentificationCode':
            ObjectiveAssessmentIdentificationCode_ = child_.text
            ObjectiveAssessmentIdentificationCode_ = self.gds_validate_string(ObjectiveAssessmentIdentificationCode_, node, 'ObjectiveAssessmentIdentificationCode')
            self.ObjectiveAssessmentIdentificationCode = ObjectiveAssessmentIdentificationCode_
            self.validate_IdentificationCode(self.ObjectiveAssessmentIdentificationCode)    # validate type IdentificationCode
# end class ObjectiveAssessmentIdentityType


class ProgramReferenceType(ReferenceType):
    """Provides alternative references for programs. Use XML IDREF to
    reference a program record that is included in the interchange"""
    subclass = None
    superclass = ReferenceType
    def __init__(self, ref=None, id=None, ProgramIdentity=None):
        super(ProgramReferenceType, self).__init__(ref, id, )
        self.ProgramIdentity = ProgramIdentity
    def factory(*args_, **kwargs_):
        if ProgramReferenceType.subclass:
            return ProgramReferenceType.subclass(*args_, **kwargs_)
        else:
            return ProgramReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ProgramIdentity(self): return self.ProgramIdentity
    def set_ProgramIdentity(self, ProgramIdentity): self.ProgramIdentity = ProgramIdentity
    def export(self, outfile, level, namespace_='', name_='ProgramReferenceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProgramReferenceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProgramReferenceType'):
        super(ProgramReferenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ProgramReferenceType')
    def exportChildren(self, outfile, level, namespace_='', name_='ProgramReferenceType', fromsubclass_=False):
        super(ProgramReferenceType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.ProgramIdentity:
            self.ProgramIdentity.export(outfile, level, namespace_, name_='ProgramIdentity')
    def hasContent_(self):
        if (
            self.ProgramIdentity is not None or
            super(ProgramReferenceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ProgramReferenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ProgramReferenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ProgramReferenceType, self).exportLiteralChildren(outfile, level, name_)
        if self.ProgramIdentity is not None:
            showIndent(outfile, level)
            outfile.write('ProgramIdentity=model_.ProgramIdentityType(\n')
            self.ProgramIdentity.exportLiteral(outfile, level, name_='ProgramIdentity')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(ProgramReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ProgramIdentity':
            obj_ = ProgramIdentityType.factory()
            obj_.build(child_)
            self.set_ProgramIdentity(obj_)
        super(ProgramReferenceType, self).buildChildren(child_, node, nodeName_, True)
# end class ProgramReferenceType


class ProgramIdentityType(GeneratedsSuper):
    """Encapsulates the possible attributes that can be used to lookup the
    identity of programs."""
    subclass = None
    superclass = None
    def __init__(self, ProgramId=None, ProgramType=None):
        self.ProgramId = ProgramId
        self.ProgramType = ProgramType
    def factory(*args_, **kwargs_):
        if ProgramIdentityType.subclass:
            return ProgramIdentityType.subclass(*args_, **kwargs_)
        else:
            return ProgramIdentityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ProgramId(self): return self.ProgramId
    def set_ProgramId(self, ProgramId): self.ProgramId = ProgramId
    def validate_ProgramId(self, value):
        # Validate type ProgramId, a restriction on xs:string.
        pass
    def get_ProgramType(self): return self.ProgramType
    def set_ProgramType(self, ProgramType): self.ProgramType = ProgramType
    def validate_ProgramType(self, value):
        # Validate type ProgramType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='ProgramIdentityType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProgramIdentityType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProgramIdentityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ProgramIdentityType', fromsubclass_=False):
        if self.ProgramId is not None:
            showIndent(outfile, level)
            outfile.write('<%sProgramId>%s</%sProgramId>\n' % (namespace_, self.gds_format_string(quote_xml(self.ProgramId).encode(ExternalEncoding), input_name='ProgramId'), namespace_))
        if self.ProgramType is not None:
            showIndent(outfile, level)
            outfile.write('<%sProgramType>%s</%sProgramType>\n' % (namespace_, self.gds_format_string(quote_xml(self.ProgramType).encode(ExternalEncoding), input_name='ProgramType'), namespace_))
    def hasContent_(self):
        if (
            self.ProgramId is not None or
            self.ProgramType is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ProgramIdentityType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ProgramId is not None:
            showIndent(outfile, level)
            outfile.write('ProgramId=%s,\n' % quote_python(self.ProgramId).encode(ExternalEncoding))
        if self.ProgramType is not None:
            showIndent(outfile, level)
            outfile.write('ProgramType=%s,\n' % quote_python(self.ProgramType).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ProgramId':
            ProgramId_ = child_.text
            ProgramId_ = self.gds_validate_string(ProgramId_, node, 'ProgramId')
            self.ProgramId = ProgramId_
            self.validate_ProgramId(self.ProgramId)    # validate type ProgramId
        elif nodeName_ == 'ProgramType':
            ProgramType_ = child_.text
            ProgramType_ = re_.sub(String_cleanup_pat_, " ", ProgramType_).strip()
            ProgramType_ = self.gds_validate_string(ProgramType_, node, 'ProgramType')
            self.ProgramType = ProgramType_
            self.validate_ProgramType(self.ProgramType)    # validate type ProgramType
# end class ProgramIdentityType


class SectionReferenceType(ReferenceType):
    """Provides alternative references for section. Use XML IDREF to
    reference a section record that is included in the interchange"""
    subclass = None
    superclass = ReferenceType
    def __init__(self, ref=None, id=None, SectionIdentity=None):
        super(SectionReferenceType, self).__init__(ref, id, )
        self.SectionIdentity = SectionIdentity
    def factory(*args_, **kwargs_):
        if SectionReferenceType.subclass:
            return SectionReferenceType.subclass(*args_, **kwargs_)
        else:
            return SectionReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SectionIdentity(self): return self.SectionIdentity
    def set_SectionIdentity(self, SectionIdentity): self.SectionIdentity = SectionIdentity
    def export(self, outfile, level, namespace_='', name_='SectionReferenceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SectionReferenceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SectionReferenceType'):
        super(SectionReferenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SectionReferenceType')
    def exportChildren(self, outfile, level, namespace_='', name_='SectionReferenceType', fromsubclass_=False):
        super(SectionReferenceType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.SectionIdentity:
            self.SectionIdentity.export(outfile, level, namespace_, name_='SectionIdentity')
    def hasContent_(self):
        if (
            self.SectionIdentity is not None or
            super(SectionReferenceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SectionReferenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SectionReferenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SectionReferenceType, self).exportLiteralChildren(outfile, level, name_)
        if self.SectionIdentity is not None:
            showIndent(outfile, level)
            outfile.write('SectionIdentity=model_.SectionIdentityType(\n')
            self.SectionIdentity.exportLiteral(outfile, level, name_='SectionIdentity')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(SectionReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SectionIdentity':
            obj_ = SectionIdentityType.factory()
            obj_.build(child_)
            self.set_SectionIdentity(obj_)
        super(SectionReferenceType, self).buildChildren(child_, node, nodeName_, True)
# end class SectionReferenceType


class SectionIdentityType(GeneratedsSuper):
    """Encapsulates the possible attributes that can be used to lookup the
    identity of sections at a school. Two cases are supported: 1.
    SchoolOrganizationID + UniqueSectionCode 2. SchoolOrganizationID
    + Course (StateCourseCode OR LocalCourseCode) + Term +
    ClassPeriod + Location"""
    subclass = None
    superclass = None
    def __init__(self, SchoolOrganizationID=None, UniqueSectionCode=None, CourseCode=None, LocalCourseCode=None, Term=None, ClassPeriodName=None, Location=None):
        self.SchoolOrganizationID = SchoolOrganizationID
        self.UniqueSectionCode = UniqueSectionCode
        self.CourseCode = CourseCode
        self.LocalCourseCode = LocalCourseCode
        self.Term = Term
        self.ClassPeriodName = ClassPeriodName
        self.Location = Location
    def factory(*args_, **kwargs_):
        if SectionIdentityType.subclass:
            return SectionIdentityType.subclass(*args_, **kwargs_)
        else:
            return SectionIdentityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SchoolOrganizationID(self): return self.SchoolOrganizationID
    def set_SchoolOrganizationID(self, SchoolOrganizationID): self.SchoolOrganizationID = SchoolOrganizationID
    def validate_IdentificationCode(self, value):
        # Validate type IdentificationCode, a restriction on xs:string.
        pass
    def get_UniqueSectionCode(self): return self.UniqueSectionCode
    def set_UniqueSectionCode(self, UniqueSectionCode): self.UniqueSectionCode = UniqueSectionCode
    def validate_UniqueSectionCode(self, value):
        # Validate type UniqueSectionCode, a restriction on xs:string.
        pass
    def get_CourseCode(self): return self.CourseCode
    def set_CourseCode(self, CourseCode): self.CourseCode = CourseCode
    def get_LocalCourseCode(self): return self.LocalCourseCode
    def set_LocalCourseCode(self, LocalCourseCode): self.LocalCourseCode = LocalCourseCode
    def validate_LocalCourseCode(self, value):
        # Validate type LocalCourseCode, a restriction on xs:string.
        pass
    def get_Term(self): return self.Term
    def set_Term(self, Term): self.Term = Term
    def validate_TermType(self, value):
        # Validate type TermType, a restriction on xs:token.
        pass
    def get_ClassPeriodName(self): return self.ClassPeriodName
    def set_ClassPeriodName(self, ClassPeriodName): self.ClassPeriodName = ClassPeriodName
    def validate_ClassPeriodNameType(self, value):
        # Validate type ClassPeriodNameType, a restriction on xs:string.
        pass
    def get_Location(self): return self.Location
    def set_Location(self, Location): self.Location = Location
    def validate_ClassroomIdentificationCode(self, value):
        # Validate type ClassroomIdentificationCode, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='SectionIdentityType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SectionIdentityType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SectionIdentityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SectionIdentityType', fromsubclass_=False):
        if self.SchoolOrganizationID is not None:
            showIndent(outfile, level)
            outfile.write('<%sSchoolOrganizationID>%s</%sSchoolOrganizationID>\n' % (namespace_, self.gds_format_string(quote_xml(self.SchoolOrganizationID).encode(ExternalEncoding), input_name='SchoolOrganizationID'), namespace_))
        if self.UniqueSectionCode is not None:
            showIndent(outfile, level)
            outfile.write('<%sUniqueSectionCode>%s</%sUniqueSectionCode>\n' % (namespace_, self.gds_format_string(quote_xml(self.UniqueSectionCode).encode(ExternalEncoding), input_name='UniqueSectionCode'), namespace_))
        if self.CourseCode:
            self.CourseCode.export(outfile, level, namespace_, name_='CourseCode')
        if self.LocalCourseCode is not None:
            showIndent(outfile, level)
            outfile.write('<%sLocalCourseCode>%s</%sLocalCourseCode>\n' % (namespace_, self.gds_format_string(quote_xml(self.LocalCourseCode).encode(ExternalEncoding), input_name='LocalCourseCode'), namespace_))
        if self.Term is not None:
            showIndent(outfile, level)
            outfile.write('<%sTerm>%s</%sTerm>\n' % (namespace_, self.gds_format_string(quote_xml(self.Term).encode(ExternalEncoding), input_name='Term'), namespace_))
        if self.ClassPeriodName is not None:
            showIndent(outfile, level)
            outfile.write('<%sClassPeriodName>%s</%sClassPeriodName>\n' % (namespace_, self.gds_format_string(quote_xml(self.ClassPeriodName).encode(ExternalEncoding), input_name='ClassPeriodName'), namespace_))
        if self.Location is not None:
            showIndent(outfile, level)
            outfile.write('<%sLocation>%s</%sLocation>\n' % (namespace_, self.gds_format_string(quote_xml(self.Location).encode(ExternalEncoding), input_name='Location'), namespace_))
    def hasContent_(self):
        if (
            self.SchoolOrganizationID is not None or
            self.UniqueSectionCode is not None or
            self.CourseCode is not None or
            self.LocalCourseCode is not None or
            self.Term is not None or
            self.ClassPeriodName is not None or
            self.Location is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SectionIdentityType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SchoolOrganizationID is not None:
            showIndent(outfile, level)
            outfile.write('SchoolOrganizationID=%s,\n' % quote_python(self.SchoolOrganizationID).encode(ExternalEncoding))
        if self.UniqueSectionCode is not None:
            showIndent(outfile, level)
            outfile.write('UniqueSectionCode=%s,\n' % quote_python(self.UniqueSectionCode).encode(ExternalEncoding))
        if self.CourseCode is not None:
            showIndent(outfile, level)
            outfile.write('CourseCode=model_.CourseCode(\n')
            self.CourseCode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocalCourseCode is not None:
            showIndent(outfile, level)
            outfile.write('LocalCourseCode=%s,\n' % quote_python(self.LocalCourseCode).encode(ExternalEncoding))
        if self.Term is not None:
            showIndent(outfile, level)
            outfile.write('Term=%s,\n' % quote_python(self.Term).encode(ExternalEncoding))
        if self.ClassPeriodName is not None:
            showIndent(outfile, level)
            outfile.write('ClassPeriodName=%s,\n' % quote_python(self.ClassPeriodName).encode(ExternalEncoding))
        if self.Location is not None:
            showIndent(outfile, level)
            outfile.write('Location=%s,\n' % quote_python(self.Location).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SchoolOrganizationID':
            SchoolOrganizationID_ = child_.text
            SchoolOrganizationID_ = self.gds_validate_string(SchoolOrganizationID_, node, 'SchoolOrganizationID')
            self.SchoolOrganizationID = SchoolOrganizationID_
            self.validate_IdentificationCode(self.SchoolOrganizationID)    # validate type IdentificationCode
        elif nodeName_ == 'UniqueSectionCode':
            UniqueSectionCode_ = child_.text
            UniqueSectionCode_ = self.gds_validate_string(UniqueSectionCode_, node, 'UniqueSectionCode')
            self.UniqueSectionCode = UniqueSectionCode_
            self.validate_UniqueSectionCode(self.UniqueSectionCode)    # validate type UniqueSectionCode
        elif nodeName_ == 'CourseCode':
            obj_ = CourseCode.factory()
            obj_.build(child_)
            self.set_CourseCode(obj_)
        elif nodeName_ == 'LocalCourseCode':
            LocalCourseCode_ = child_.text
            LocalCourseCode_ = self.gds_validate_string(LocalCourseCode_, node, 'LocalCourseCode')
            self.LocalCourseCode = LocalCourseCode_
            self.validate_LocalCourseCode(self.LocalCourseCode)    # validate type LocalCourseCode
        elif nodeName_ == 'Term':
            Term_ = child_.text
            Term_ = re_.sub(String_cleanup_pat_, " ", Term_).strip()
            Term_ = self.gds_validate_string(Term_, node, 'Term')
            self.Term = Term_
            self.validate_TermType(self.Term)    # validate type TermType
        elif nodeName_ == 'ClassPeriodName':
            ClassPeriodName_ = child_.text
            ClassPeriodName_ = self.gds_validate_string(ClassPeriodName_, node, 'ClassPeriodName')
            self.ClassPeriodName = ClassPeriodName_
            self.validate_ClassPeriodNameType(self.ClassPeriodName)    # validate type ClassPeriodNameType
        elif nodeName_ == 'Location':
            Location_ = child_.text
            Location_ = self.gds_validate_string(Location_, node, 'Location')
            self.Location = Location_
            self.validate_ClassroomIdentificationCode(self.Location)    # validate type ClassroomIdentificationCode
# end class SectionIdentityType


class StaffReferenceType(ReferenceType):
    """Provides alternative references for Staff reference during
    interchange (including teachers). Use XML IDREF to reference a
    staff record that is included in the interchange"""
    subclass = None
    superclass = ReferenceType
    def __init__(self, ref=None, id=None, StaffIdentity=None):
        super(StaffReferenceType, self).__init__(ref, id, )
        self.StaffIdentity = StaffIdentity
    def factory(*args_, **kwargs_):
        if StaffReferenceType.subclass:
            return StaffReferenceType.subclass(*args_, **kwargs_)
        else:
            return StaffReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StaffIdentity(self): return self.StaffIdentity
    def set_StaffIdentity(self, StaffIdentity): self.StaffIdentity = StaffIdentity
    def export(self, outfile, level, namespace_='', name_='StaffReferenceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StaffReferenceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StaffReferenceType'):
        super(StaffReferenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StaffReferenceType')
    def exportChildren(self, outfile, level, namespace_='', name_='StaffReferenceType', fromsubclass_=False):
        super(StaffReferenceType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.StaffIdentity:
            self.StaffIdentity.export(outfile, level, namespace_, name_='StaffIdentity')
    def hasContent_(self):
        if (
            self.StaffIdentity is not None or
            super(StaffReferenceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StaffReferenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StaffReferenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StaffReferenceType, self).exportLiteralChildren(outfile, level, name_)
        if self.StaffIdentity is not None:
            showIndent(outfile, level)
            outfile.write('StaffIdentity=model_.StaffIdentityType(\n')
            self.StaffIdentity.exportLiteral(outfile, level, name_='StaffIdentity')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(StaffReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StaffIdentity':
            obj_ = StaffIdentityType.factory()
            obj_.build(child_)
            self.set_StaffIdentity(obj_)
        super(StaffReferenceType, self).buildChildren(child_, node, nodeName_, True)
# end class StaffReferenceType


class StaffIdentityType(GeneratedsSuper):
    """Encapsulates the possible attributes that can be used to lookup the
    identity of staff members, including teachers"""
    subclass = None
    superclass = None
    def __init__(self, StaffUniqueStateId=None, StaffIdentificationCode=None, Name=None, Sex=None, BirthDate=None, HispanicLatinoEthnicity=None, Race=None):
        self.StaffUniqueStateId = StaffUniqueStateId
        if StaffIdentificationCode is None:
            self.StaffIdentificationCode = []
        else:
            self.StaffIdentificationCode = StaffIdentificationCode
        self.Name = Name
        self.Sex = Sex
        self.BirthDate = BirthDate
        self.HispanicLatinoEthnicity = HispanicLatinoEthnicity
        self.Race = Race
    def factory(*args_, **kwargs_):
        if StaffIdentityType.subclass:
            return StaffIdentityType.subclass(*args_, **kwargs_)
        else:
            return StaffIdentityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StaffUniqueStateId(self): return self.StaffUniqueStateId
    def set_StaffUniqueStateId(self, StaffUniqueStateId): self.StaffUniqueStateId = StaffUniqueStateId
    def validate_UniqueStateIdentifier(self, value):
        # Validate type UniqueStateIdentifier, a restriction on xs:int.
        pass
    def get_StaffIdentificationCode(self): return self.StaffIdentificationCode
    def set_StaffIdentificationCode(self, StaffIdentificationCode): self.StaffIdentificationCode = StaffIdentificationCode
    def add_StaffIdentificationCode(self, value): self.StaffIdentificationCode.append(value)
    def insert_StaffIdentificationCode(self, index, value): self.StaffIdentificationCode[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Sex(self): return self.Sex
    def set_Sex(self, Sex): self.Sex = Sex
    def validate_SexType(self, value):
        # Validate type SexType, a restriction on xs:token.
        pass
    def get_BirthDate(self): return self.BirthDate
    def set_BirthDate(self, BirthDate): self.BirthDate = BirthDate
    def get_HispanicLatinoEthnicity(self): return self.HispanicLatinoEthnicity
    def set_HispanicLatinoEthnicity(self, HispanicLatinoEthnicity): self.HispanicLatinoEthnicity = HispanicLatinoEthnicity
    def get_Race(self): return self.Race
    def set_Race(self, Race): self.Race = Race
    def export(self, outfile, level, namespace_='', name_='StaffIdentityType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StaffIdentityType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StaffIdentityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StaffIdentityType', fromsubclass_=False):
        if self.StaffUniqueStateId is not None:
            showIndent(outfile, level)
            outfile.write('<%sStaffUniqueStateId>%s</%sStaffUniqueStateId>\n' % (namespace_, self.gds_format_integer(self.StaffUniqueStateId, input_name='StaffUniqueStateId'), namespace_))
        for StaffIdentificationCode_ in self.StaffIdentificationCode:
            StaffIdentificationCode_.export(outfile, level, namespace_, name_='StaffIdentificationCode')
        if self.Name:
            self.Name.export(outfile, level, namespace_, name_='Name')
        if self.Sex is not None:
            showIndent(outfile, level)
            outfile.write('<%sSex>%s</%sSex>\n' % (namespace_, self.gds_format_string(quote_xml(self.Sex).encode(ExternalEncoding), input_name='Sex'), namespace_))
        if self.BirthDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sBirthDate>%s</%sBirthDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.BirthDate).encode(ExternalEncoding), input_name='BirthDate'), namespace_))
        if self.HispanicLatinoEthnicity is not None:
            showIndent(outfile, level)
            outfile.write('<%sHispanicLatinoEthnicity>%s</%sHispanicLatinoEthnicity>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.HispanicLatinoEthnicity)), input_name='HispanicLatinoEthnicity'), namespace_))
        if self.Race:
            self.Race.export(outfile, level, namespace_, name_='Race')
    def hasContent_(self):
        if (
            self.StaffUniqueStateId is not None or
            self.StaffIdentificationCode or
            self.Name is not None or
            self.Sex is not None or
            self.BirthDate is not None or
            self.HispanicLatinoEthnicity is not None or
            self.Race is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StaffIdentityType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StaffUniqueStateId is not None:
            showIndent(outfile, level)
            outfile.write('StaffUniqueStateId=%d,\n' % self.StaffUniqueStateId)
        showIndent(outfile, level)
        outfile.write('StaffIdentificationCode=[\n')
        level += 1
        for StaffIdentificationCode_ in self.StaffIdentificationCode:
            showIndent(outfile, level)
            outfile.write('model_.StaffIdentificationCode(\n')
            StaffIdentificationCode_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=model_.Name(\n')
            self.Name.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Sex is not None:
            showIndent(outfile, level)
            outfile.write('Sex=%s,\n' % quote_python(self.Sex).encode(ExternalEncoding))
        if self.BirthDate is not None:
            showIndent(outfile, level)
            outfile.write('BirthDate=%s,\n' % quote_python(self.BirthDate).encode(ExternalEncoding))
        if self.HispanicLatinoEthnicity is not None:
            showIndent(outfile, level)
            outfile.write('HispanicLatinoEthnicity=%s,\n' % self.HispanicLatinoEthnicity)
        if self.Race is not None:
            showIndent(outfile, level)
            outfile.write('Race=model_.RaceType(\n')
            self.Race.exportLiteral(outfile, level, name_='Race')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StaffUniqueStateId':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'StaffUniqueStateId')
            self.StaffUniqueStateId = ival_
            self.validate_UniqueStateIdentifier(self.StaffUniqueStateId)    # validate type UniqueStateIdentifier
        elif nodeName_ == 'StaffIdentificationCode':
            obj_ = StaffIdentificationCode.factory()
            obj_.build(child_)
            self.StaffIdentificationCode.append(obj_)
        elif nodeName_ == 'Name':
            obj_ = Name.factory()
            obj_.build(child_)
            self.set_Name(obj_)
        elif nodeName_ == 'Sex':
            Sex_ = child_.text
            Sex_ = re_.sub(String_cleanup_pat_, " ", Sex_).strip()
            Sex_ = self.gds_validate_string(Sex_, node, 'Sex')
            self.Sex = Sex_
            self.validate_SexType(self.Sex)    # validate type SexType
        elif nodeName_ == 'BirthDate':
            BirthDate_ = child_.text
            BirthDate_ = self.gds_validate_string(BirthDate_, node, 'BirthDate')
            self.BirthDate = BirthDate_
        elif nodeName_ == 'HispanicLatinoEthnicity':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'HispanicLatinoEthnicity')
            self.HispanicLatinoEthnicity = ival_
        elif nodeName_ == 'Race':
            obj_ = RaceType.factory()
            obj_.build(child_)
            self.set_Race(obj_)
# end class StaffIdentityType


class StudentExpectationReferenceType(ReferenceType):
    """Provides alternative references for Student Expectation reference
    during interchange. Use XML IDREF to reference a student
    expectation record that is included in the interchange"""
    subclass = None
    superclass = ReferenceType
    def __init__(self, ref=None, id=None, StudentExpectationIdentity=None):
        super(StudentExpectationReferenceType, self).__init__(ref, id, )
        self.StudentExpectationIdentity = StudentExpectationIdentity
    def factory(*args_, **kwargs_):
        if StudentExpectationReferenceType.subclass:
            return StudentExpectationReferenceType.subclass(*args_, **kwargs_)
        else:
            return StudentExpectationReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StudentExpectationIdentity(self): return self.StudentExpectationIdentity
    def set_StudentExpectationIdentity(self, StudentExpectationIdentity): self.StudentExpectationIdentity = StudentExpectationIdentity
    def export(self, outfile, level, namespace_='', name_='StudentExpectationReferenceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StudentExpectationReferenceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StudentExpectationReferenceType'):
        super(StudentExpectationReferenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StudentExpectationReferenceType')
    def exportChildren(self, outfile, level, namespace_='', name_='StudentExpectationReferenceType', fromsubclass_=False):
        super(StudentExpectationReferenceType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.StudentExpectationIdentity:
            self.StudentExpectationIdentity.export(outfile, level, namespace_, name_='StudentExpectationIdentity')
    def hasContent_(self):
        if (
            self.StudentExpectationIdentity is not None or
            super(StudentExpectationReferenceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StudentExpectationReferenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StudentExpectationReferenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StudentExpectationReferenceType, self).exportLiteralChildren(outfile, level, name_)
        if self.StudentExpectationIdentity is not None:
            showIndent(outfile, level)
            outfile.write('StudentExpectationIdentity=model_.StudentExpectationIdentityType(\n')
            self.StudentExpectationIdentity.exportLiteral(outfile, level, name_='StudentExpectationIdentity')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(StudentExpectationReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StudentExpectationIdentity':
            obj_ = StudentExpectationIdentityType.factory()
            obj_.build(child_)
            self.set_StudentExpectationIdentity(obj_)
        super(StudentExpectationReferenceType, self).buildChildren(child_, node, nodeName_, True)
# end class StudentExpectationReferenceType


class StudentExpectationIdentityType(ReferenceType):
    """Encapsulates the possible attributes that can be used to lookup the
    identity of the Student Expectations."""
    subclass = None
    superclass = ReferenceType
    def __init__(self, ref=None, id=None, StudentExpectationId=None):
        super(StudentExpectationIdentityType, self).__init__(ref, id, )
        self.StudentExpectationId = StudentExpectationId
    def factory(*args_, **kwargs_):
        if StudentExpectationIdentityType.subclass:
            return StudentExpectationIdentityType.subclass(*args_, **kwargs_)
        else:
            return StudentExpectationIdentityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StudentExpectationId(self): return self.StudentExpectationId
    def set_StudentExpectationId(self, StudentExpectationId): self.StudentExpectationId = StudentExpectationId
    def validate_StudentExpectationId(self, value):
        # Validate type StudentExpectationId, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='StudentExpectationIdentityType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StudentExpectationIdentityType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StudentExpectationIdentityType'):
        super(StudentExpectationIdentityType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StudentExpectationIdentityType')
    def exportChildren(self, outfile, level, namespace_='', name_='StudentExpectationIdentityType', fromsubclass_=False):
        super(StudentExpectationIdentityType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.StudentExpectationId is not None:
            showIndent(outfile, level)
            outfile.write('<%sStudentExpectationId>%s</%sStudentExpectationId>\n' % (namespace_, self.gds_format_string(quote_xml(self.StudentExpectationId).encode(ExternalEncoding), input_name='StudentExpectationId'), namespace_))
    def hasContent_(self):
        if (
            self.StudentExpectationId is not None or
            super(StudentExpectationIdentityType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StudentExpectationIdentityType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StudentExpectationIdentityType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StudentExpectationIdentityType, self).exportLiteralChildren(outfile, level, name_)
        if self.StudentExpectationId is not None:
            showIndent(outfile, level)
            outfile.write('StudentExpectationId=%s,\n' % quote_python(self.StudentExpectationId).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(StudentExpectationIdentityType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StudentExpectationId':
            StudentExpectationId_ = child_.text
            StudentExpectationId_ = self.gds_validate_string(StudentExpectationId_, node, 'StudentExpectationId')
            self.StudentExpectationId = StudentExpectationId_
            self.validate_StudentExpectationId(self.StudentExpectationId)    # validate type StudentExpectationId
        super(StudentExpectationIdentityType, self).buildChildren(child_, node, nodeName_, True)
# end class StudentExpectationIdentityType


class StudentReferenceType(ReferenceType):
    """Provides alternative references for Student reference during
    interchange. Use XML IDREF to reference a student record that is
    included in the interchange"""
    subclass = None
    superclass = ReferenceType
    def __init__(self, ref=None, id=None, StudentIdentity=None):
        super(StudentReferenceType, self).__init__(ref, id, )
        self.StudentIdentity = StudentIdentity
    def factory(*args_, **kwargs_):
        if StudentReferenceType.subclass:
            return StudentReferenceType.subclass(*args_, **kwargs_)
        else:
            return StudentReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StudentIdentity(self): return self.StudentIdentity
    def set_StudentIdentity(self, StudentIdentity): self.StudentIdentity = StudentIdentity
    def export(self, outfile, level, namespace_='', name_='StudentReferenceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StudentReferenceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StudentReferenceType'):
        super(StudentReferenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StudentReferenceType')
    def exportChildren(self, outfile, level, namespace_='', name_='StudentReferenceType', fromsubclass_=False):
        super(StudentReferenceType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.StudentIdentity:
            self.StudentIdentity.export(outfile, level, namespace_, name_='StudentIdentity')
    def hasContent_(self):
        if (
            self.StudentIdentity is not None or
            super(StudentReferenceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StudentReferenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StudentReferenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StudentReferenceType, self).exportLiteralChildren(outfile, level, name_)
        if self.StudentIdentity is not None:
            showIndent(outfile, level)
            outfile.write('StudentIdentity=model_.StudentIdentityType(\n')
            self.StudentIdentity.exportLiteral(outfile, level, name_='StudentIdentity')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(StudentReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StudentIdentity':
            obj_ = StudentIdentityType.factory()
            obj_.build(child_)
            self.set_StudentIdentity(obj_)
        super(StudentReferenceType, self).buildChildren(child_, node, nodeName_, True)
# end class StudentReferenceType


class StudentIdentityType(GeneratedsSuper):
    """Encapsulates the possible attributes that can be used to lookup the
    identity of students."""
    subclass = None
    superclass = None
    def __init__(self, StudentUniqueStateId=None, StudentIdentificationCode=None, Name=None, OtherName=None, BirthDate=None, Sex=None, HispanicLatinoEthnicity=None, Race=None):
        self.StudentUniqueStateId = StudentUniqueStateId
        if StudentIdentificationCode is None:
            self.StudentIdentificationCode = []
        else:
            self.StudentIdentificationCode = StudentIdentificationCode
        self.Name = Name
        if OtherName is None:
            self.OtherName = []
        else:
            self.OtherName = OtherName
        self.BirthDate = BirthDate
        self.Sex = Sex
        self.HispanicLatinoEthnicity = HispanicLatinoEthnicity
        self.Race = Race
    def factory(*args_, **kwargs_):
        if StudentIdentityType.subclass:
            return StudentIdentityType.subclass(*args_, **kwargs_)
        else:
            return StudentIdentityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StudentUniqueStateId(self): return self.StudentUniqueStateId
    def set_StudentUniqueStateId(self, StudentUniqueStateId): self.StudentUniqueStateId = StudentUniqueStateId
    def validate_UniqueStateIdentifier(self, value):
        # Validate type UniqueStateIdentifier, a restriction on xs:int.
        pass
    def get_StudentIdentificationCode(self): return self.StudentIdentificationCode
    def set_StudentIdentificationCode(self, StudentIdentificationCode): self.StudentIdentificationCode = StudentIdentificationCode
    def add_StudentIdentificationCode(self, value): self.StudentIdentificationCode.append(value)
    def insert_StudentIdentificationCode(self, index, value): self.StudentIdentificationCode[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_OtherName(self): return self.OtherName
    def set_OtherName(self, OtherName): self.OtherName = OtherName
    def add_OtherName(self, value): self.OtherName.append(value)
    def insert_OtherName(self, index, value): self.OtherName[index] = value
    def get_BirthDate(self): return self.BirthDate
    def set_BirthDate(self, BirthDate): self.BirthDate = BirthDate
    def get_Sex(self): return self.Sex
    def set_Sex(self, Sex): self.Sex = Sex
    def validate_SexType(self, value):
        # Validate type SexType, a restriction on xs:token.
        pass
    def get_HispanicLatinoEthnicity(self): return self.HispanicLatinoEthnicity
    def set_HispanicLatinoEthnicity(self, HispanicLatinoEthnicity): self.HispanicLatinoEthnicity = HispanicLatinoEthnicity
    def get_Race(self): return self.Race
    def set_Race(self, Race): self.Race = Race
    def export(self, outfile, level, namespace_='', name_='StudentIdentityType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StudentIdentityType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StudentIdentityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StudentIdentityType', fromsubclass_=False):
        if self.StudentUniqueStateId is not None:
            showIndent(outfile, level)
            outfile.write('<%sStudentUniqueStateId>%s</%sStudentUniqueStateId>\n' % (namespace_, self.gds_format_integer(self.StudentUniqueStateId, input_name='StudentUniqueStateId'), namespace_))
        for StudentIdentificationCode_ in self.StudentIdentificationCode:
            StudentIdentificationCode_.export(outfile, level, namespace_, name_='StudentIdentificationCode')
        if self.Name:
            self.Name.export(outfile, level, namespace_, name_='Name')
        for OtherName_ in self.OtherName:
            OtherName_.export(outfile, level, namespace_, name_='OtherName')
        if self.BirthDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sBirthDate>%s</%sBirthDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.BirthDate).encode(ExternalEncoding), input_name='BirthDate'), namespace_))
        if self.Sex is not None:
            showIndent(outfile, level)
            outfile.write('<%sSex>%s</%sSex>\n' % (namespace_, self.gds_format_string(quote_xml(self.Sex).encode(ExternalEncoding), input_name='Sex'), namespace_))
        if self.HispanicLatinoEthnicity is not None:
            showIndent(outfile, level)
            outfile.write('<%sHispanicLatinoEthnicity>%s</%sHispanicLatinoEthnicity>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.HispanicLatinoEthnicity)), input_name='HispanicLatinoEthnicity'), namespace_))
        if self.Race:
            self.Race.export(outfile, level, namespace_, name_='Race')
    def hasContent_(self):
        if (
            self.StudentUniqueStateId is not None or
            self.StudentIdentificationCode or
            self.Name is not None or
            self.OtherName or
            self.BirthDate is not None or
            self.Sex is not None or
            self.HispanicLatinoEthnicity is not None or
            self.Race is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StudentIdentityType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StudentUniqueStateId is not None:
            showIndent(outfile, level)
            outfile.write('StudentUniqueStateId=%d,\n' % self.StudentUniqueStateId)
        showIndent(outfile, level)
        outfile.write('StudentIdentificationCode=[\n')
        level += 1
        for StudentIdentificationCode_ in self.StudentIdentificationCode:
            showIndent(outfile, level)
            outfile.write('model_.StudentIdentificationCode(\n')
            StudentIdentificationCode_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=model_.Name(\n')
            self.Name.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('OtherName=[\n')
        level += 1
        for OtherName_ in self.OtherName:
            showIndent(outfile, level)
            outfile.write('model_.OtherName(\n')
            OtherName_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.BirthDate is not None:
            showIndent(outfile, level)
            outfile.write('BirthDate=%s,\n' % quote_python(self.BirthDate).encode(ExternalEncoding))
        if self.Sex is not None:
            showIndent(outfile, level)
            outfile.write('Sex=%s,\n' % quote_python(self.Sex).encode(ExternalEncoding))
        if self.HispanicLatinoEthnicity is not None:
            showIndent(outfile, level)
            outfile.write('HispanicLatinoEthnicity=%s,\n' % self.HispanicLatinoEthnicity)
        if self.Race is not None:
            showIndent(outfile, level)
            outfile.write('Race=model_.RaceType(\n')
            self.Race.exportLiteral(outfile, level, name_='Race')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StudentUniqueStateId':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'StudentUniqueStateId')
            self.StudentUniqueStateId = ival_
            self.validate_UniqueStateIdentifier(self.StudentUniqueStateId)    # validate type UniqueStateIdentifier
        elif nodeName_ == 'StudentIdentificationCode':
            obj_ = StudentIdentificationCode.factory()
            obj_.build(child_)
            self.StudentIdentificationCode.append(obj_)
        elif nodeName_ == 'Name':
            obj_ = Name.factory()
            obj_.build(child_)
            self.set_Name(obj_)
        elif nodeName_ == 'OtherName':
            obj_ = OtherName.factory()
            obj_.build(child_)
            self.OtherName.append(obj_)
        elif nodeName_ == 'BirthDate':
            BirthDate_ = child_.text
            BirthDate_ = self.gds_validate_string(BirthDate_, node, 'BirthDate')
            self.BirthDate = BirthDate_
        elif nodeName_ == 'Sex':
            Sex_ = child_.text
            Sex_ = re_.sub(String_cleanup_pat_, " ", Sex_).strip()
            Sex_ = self.gds_validate_string(Sex_, node, 'Sex')
            self.Sex = Sex_
            self.validate_SexType(self.Sex)    # validate type SexType
        elif nodeName_ == 'HispanicLatinoEthnicity':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'HispanicLatinoEthnicity')
            self.HispanicLatinoEthnicity = ival_
        elif nodeName_ == 'Race':
            obj_ = RaceType.factory()
            obj_.build(child_)
            self.set_Race(obj_)
# end class StudentIdentityType


class StudentSectionAssociationReferenceType(ReferenceType):
    """Provides alternative references for the Student-section association.
    Use XML IDREF to reference a program record that is included in
    the interchange"""
    subclass = None
    superclass = ReferenceType
    def __init__(self, ref=None, id=None, StudentSectionAssociationIdentity=None):
        super(StudentSectionAssociationReferenceType, self).__init__(ref, id, )
        self.StudentSectionAssociationIdentity = StudentSectionAssociationIdentity
    def factory(*args_, **kwargs_):
        if StudentSectionAssociationReferenceType.subclass:
            return StudentSectionAssociationReferenceType.subclass(*args_, **kwargs_)
        else:
            return StudentSectionAssociationReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StudentSectionAssociationIdentity(self): return self.StudentSectionAssociationIdentity
    def set_StudentSectionAssociationIdentity(self, StudentSectionAssociationIdentity): self.StudentSectionAssociationIdentity = StudentSectionAssociationIdentity
    def export(self, outfile, level, namespace_='', name_='StudentSectionAssociationReferenceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StudentSectionAssociationReferenceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StudentSectionAssociationReferenceType'):
        super(StudentSectionAssociationReferenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StudentSectionAssociationReferenceType')
    def exportChildren(self, outfile, level, namespace_='', name_='StudentSectionAssociationReferenceType', fromsubclass_=False):
        super(StudentSectionAssociationReferenceType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.StudentSectionAssociationIdentity:
            self.StudentSectionAssociationIdentity.export(outfile, level, namespace_, name_='StudentSectionAssociationIdentity')
    def hasContent_(self):
        if (
            self.StudentSectionAssociationIdentity is not None or
            super(StudentSectionAssociationReferenceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StudentSectionAssociationReferenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StudentSectionAssociationReferenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StudentSectionAssociationReferenceType, self).exportLiteralChildren(outfile, level, name_)
        if self.StudentSectionAssociationIdentity is not None:
            showIndent(outfile, level)
            outfile.write('StudentSectionAssociationIdentity=model_.StudentSectionAssociationIdentityType(\n')
            self.StudentSectionAssociationIdentity.exportLiteral(outfile, level, name_='StudentSectionAssociationIdentity')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(StudentSectionAssociationReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StudentSectionAssociationIdentity':
            obj_ = StudentSectionAssociationIdentityType.factory()
            obj_.build(child_)
            self.set_StudentSectionAssociationIdentity(obj_)
        super(StudentSectionAssociationReferenceType, self).buildChildren(child_, node, nodeName_, True)
# end class StudentSectionAssociationReferenceType


class StudentSectionAssociationIdentityType(GeneratedsSuper):
    """Encapsulates the possible attributes that can be used to lookup the
    student-section association - a composite of the student
    reference type and the section reference type."""
    subclass = None
    superclass = None
    def __init__(self, StudentIdentity=None, SectionIdentity=None):
        self.StudentIdentity = StudentIdentity
        self.SectionIdentity = SectionIdentity
    def factory(*args_, **kwargs_):
        if StudentSectionAssociationIdentityType.subclass:
            return StudentSectionAssociationIdentityType.subclass(*args_, **kwargs_)
        else:
            return StudentSectionAssociationIdentityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StudentIdentity(self): return self.StudentIdentity
    def set_StudentIdentity(self, StudentIdentity): self.StudentIdentity = StudentIdentity
    def get_SectionIdentity(self): return self.SectionIdentity
    def set_SectionIdentity(self, SectionIdentity): self.SectionIdentity = SectionIdentity
    def export(self, outfile, level, namespace_='', name_='StudentSectionAssociationIdentityType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StudentSectionAssociationIdentityType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StudentSectionAssociationIdentityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StudentSectionAssociationIdentityType', fromsubclass_=False):
        if self.StudentIdentity:
            self.StudentIdentity.export(outfile, level, namespace_, name_='StudentIdentity', )
        if self.SectionIdentity:
            self.SectionIdentity.export(outfile, level, namespace_, name_='SectionIdentity', )
    def hasContent_(self):
        if (
            self.StudentIdentity is not None or
            self.SectionIdentity is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StudentSectionAssociationIdentityType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StudentIdentity is not None:
            showIndent(outfile, level)
            outfile.write('StudentIdentity=model_.StudentIdentityType(\n')
            self.StudentIdentity.exportLiteral(outfile, level, name_='StudentIdentity')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SectionIdentity is not None:
            showIndent(outfile, level)
            outfile.write('SectionIdentity=model_.SectionIdentityType(\n')
            self.SectionIdentity.exportLiteral(outfile, level, name_='SectionIdentity')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StudentIdentity':
            obj_ = StudentIdentityType.factory()
            obj_.build(child_)
            self.set_StudentIdentity(obj_)
        elif nodeName_ == 'SectionIdentity':
            obj_ = SectionIdentityType.factory()
            obj_.build(child_)
            self.set_SectionIdentity(obj_)
# end class StudentSectionAssociationIdentityType


class AcademicHonor(GeneratedsSuper):
    """Academic distinctions earned by or awarded to the student"""
    subclass = None
    superclass = None
    def __init__(self, AcademicHonorsType=None, HonorsDescription=None, HonorAwardDate=None):
        self.AcademicHonorsType = AcademicHonorsType
        self.HonorsDescription = HonorsDescription
        self.HonorAwardDate = HonorAwardDate
    def factory(*args_, **kwargs_):
        if AcademicHonor.subclass:
            return AcademicHonor.subclass(*args_, **kwargs_)
        else:
            return AcademicHonor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AcademicHonorsType(self): return self.AcademicHonorsType
    def set_AcademicHonorsType(self, AcademicHonorsType): self.AcademicHonorsType = AcademicHonorsType
    def validate_AcademicHonorsType(self, value):
        # Validate type AcademicHonorsType, a restriction on xs:token.
        pass
    def get_HonorsDescription(self): return self.HonorsDescription
    def set_HonorsDescription(self, HonorsDescription): self.HonorsDescription = HonorsDescription
    def validate_HonorsDescription(self, value):
        # Validate type HonorsDescription, a restriction on xs:string.
        pass
    def get_HonorAwardDate(self): return self.HonorAwardDate
    def set_HonorAwardDate(self, HonorAwardDate): self.HonorAwardDate = HonorAwardDate
    def export(self, outfile, level, namespace_='', name_='AcademicHonor', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AcademicHonor')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AcademicHonor'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AcademicHonor', fromsubclass_=False):
        if self.AcademicHonorsType is not None:
            showIndent(outfile, level)
            outfile.write('<%sAcademicHonorsType>%s</%sAcademicHonorsType>\n' % (namespace_, self.gds_format_string(quote_xml(self.AcademicHonorsType).encode(ExternalEncoding), input_name='AcademicHonorsType'), namespace_))
        if self.HonorsDescription is not None:
            showIndent(outfile, level)
            outfile.write('<%sHonorsDescription>%s</%sHonorsDescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.HonorsDescription).encode(ExternalEncoding), input_name='HonorsDescription'), namespace_))
        if self.HonorAwardDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sHonorAwardDate>%s</%sHonorAwardDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.HonorAwardDate).encode(ExternalEncoding), input_name='HonorAwardDate'), namespace_))
    def hasContent_(self):
        if (
            self.AcademicHonorsType is not None or
            self.HonorsDescription is not None or
            self.HonorAwardDate is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AcademicHonor'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AcademicHonorsType is not None:
            showIndent(outfile, level)
            outfile.write('AcademicHonorsType=%s,\n' % quote_python(self.AcademicHonorsType).encode(ExternalEncoding))
        if self.HonorsDescription is not None:
            showIndent(outfile, level)
            outfile.write('HonorsDescription=%s,\n' % quote_python(self.HonorsDescription).encode(ExternalEncoding))
        if self.HonorAwardDate is not None:
            showIndent(outfile, level)
            outfile.write('HonorAwardDate=%s,\n' % quote_python(self.HonorAwardDate).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AcademicHonorsType':
            AcademicHonorsType_ = child_.text
            AcademicHonorsType_ = re_.sub(String_cleanup_pat_, " ", AcademicHonorsType_).strip()
            AcademicHonorsType_ = self.gds_validate_string(AcademicHonorsType_, node, 'AcademicHonorsType')
            self.AcademicHonorsType = AcademicHonorsType_
            self.validate_AcademicHonorsType(self.AcademicHonorsType)    # validate type AcademicHonorsType
        elif nodeName_ == 'HonorsDescription':
            HonorsDescription_ = child_.text
            HonorsDescription_ = self.gds_validate_string(HonorsDescription_, node, 'HonorsDescription')
            self.HonorsDescription = HonorsDescription_
            self.validate_HonorsDescription(self.HonorsDescription)    # validate type HonorsDescription
        elif nodeName_ == 'HonorAwardDate':
            HonorAwardDate_ = child_.text
            HonorAwardDate_ = self.gds_validate_string(HonorAwardDate_, node, 'HonorAwardDate')
            self.HonorAwardDate = HonorAwardDate_
# end class AcademicHonor


class AccountabilityRating(GeneratedsSuper):
    """An accountability rating for a school or district."""
    subclass = None
    superclass = None
    def __init__(self, RatingTitle=None, Rating=None, RatingDate=None, SchoolYear=None, RatingOrganization=None, RatingProgram=None):
        self.RatingTitle = RatingTitle
        self.Rating = Rating
        self.RatingDate = RatingDate
        self.SchoolYear = SchoolYear
        self.RatingOrganization = RatingOrganization
        self.RatingProgram = RatingProgram
    def factory(*args_, **kwargs_):
        if AccountabilityRating.subclass:
            return AccountabilityRating.subclass(*args_, **kwargs_)
        else:
            return AccountabilityRating(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RatingTitle(self): return self.RatingTitle
    def set_RatingTitle(self, RatingTitle): self.RatingTitle = RatingTitle
    def validate_RatingTitleType(self, value):
        # Validate type RatingTitleType, a restriction on xs:string.
        pass
    def get_Rating(self): return self.Rating
    def set_Rating(self, Rating): self.Rating = Rating
    def validate_Rating(self, value):
        # Validate type Rating, a restriction on xs:string.
        pass
    def get_RatingDate(self): return self.RatingDate
    def set_RatingDate(self, RatingDate): self.RatingDate = RatingDate
    def get_SchoolYear(self): return self.SchoolYear
    def set_SchoolYear(self, SchoolYear): self.SchoolYear = SchoolYear
    def validate_SchoolYearType(self, value):
        # Validate type SchoolYearType, a restriction on xs:token.
        pass
    def get_RatingOrganization(self): return self.RatingOrganization
    def set_RatingOrganization(self, RatingOrganization): self.RatingOrganization = RatingOrganization
    def validate_RatingOrganization(self, value):
        # Validate type RatingOrganization, a restriction on xs:string.
        pass
    def get_RatingProgram(self): return self.RatingProgram
    def set_RatingProgram(self, RatingProgram): self.RatingProgram = RatingProgram
    def validate_RatingProgramType(self, value):
        # Validate type RatingProgramType, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='AccountabilityRating', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccountabilityRating')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccountabilityRating'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AccountabilityRating', fromsubclass_=False):
        if self.RatingTitle is not None:
            showIndent(outfile, level)
            outfile.write('<%sRatingTitle>%s</%sRatingTitle>\n' % (namespace_, self.gds_format_string(quote_xml(self.RatingTitle).encode(ExternalEncoding), input_name='RatingTitle'), namespace_))
        if self.Rating is not None:
            showIndent(outfile, level)
            outfile.write('<%sRating>%s</%sRating>\n' % (namespace_, self.gds_format_string(quote_xml(self.Rating).encode(ExternalEncoding), input_name='Rating'), namespace_))
        if self.RatingDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sRatingDate>%s</%sRatingDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.RatingDate).encode(ExternalEncoding), input_name='RatingDate'), namespace_))
        if self.SchoolYear is not None:
            showIndent(outfile, level)
            outfile.write('<%sSchoolYear>%s</%sSchoolYear>\n' % (namespace_, self.gds_format_string(quote_xml(self.SchoolYear).encode(ExternalEncoding), input_name='SchoolYear'), namespace_))
        if self.RatingOrganization is not None:
            showIndent(outfile, level)
            outfile.write('<%sRatingOrganization>%s</%sRatingOrganization>\n' % (namespace_, self.gds_format_string(quote_xml(self.RatingOrganization).encode(ExternalEncoding), input_name='RatingOrganization'), namespace_))
        if self.RatingProgram is not None:
            showIndent(outfile, level)
            outfile.write('<%sRatingProgram>%s</%sRatingProgram>\n' % (namespace_, self.gds_format_string(quote_xml(self.RatingProgram).encode(ExternalEncoding), input_name='RatingProgram'), namespace_))
    def hasContent_(self):
        if (
            self.RatingTitle is not None or
            self.Rating is not None or
            self.RatingDate is not None or
            self.SchoolYear is not None or
            self.RatingOrganization is not None or
            self.RatingProgram is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AccountabilityRating'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RatingTitle is not None:
            showIndent(outfile, level)
            outfile.write('RatingTitle=%s,\n' % quote_python(self.RatingTitle).encode(ExternalEncoding))
        if self.Rating is not None:
            showIndent(outfile, level)
            outfile.write('Rating=%s,\n' % quote_python(self.Rating).encode(ExternalEncoding))
        if self.RatingDate is not None:
            showIndent(outfile, level)
            outfile.write('RatingDate=%s,\n' % quote_python(self.RatingDate).encode(ExternalEncoding))
        if self.SchoolYear is not None:
            showIndent(outfile, level)
            outfile.write('SchoolYear=%s,\n' % quote_python(self.SchoolYear).encode(ExternalEncoding))
        if self.RatingOrganization is not None:
            showIndent(outfile, level)
            outfile.write('RatingOrganization=%s,\n' % quote_python(self.RatingOrganization).encode(ExternalEncoding))
        if self.RatingProgram is not None:
            showIndent(outfile, level)
            outfile.write('RatingProgram=%s,\n' % quote_python(self.RatingProgram).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RatingTitle':
            RatingTitle_ = child_.text
            RatingTitle_ = self.gds_validate_string(RatingTitle_, node, 'RatingTitle')
            self.RatingTitle = RatingTitle_
            self.validate_RatingTitleType(self.RatingTitle)    # validate type RatingTitleType
        elif nodeName_ == 'Rating':
            Rating_ = child_.text
            Rating_ = self.gds_validate_string(Rating_, node, 'Rating')
            self.Rating = Rating_
            self.validate_Rating(self.Rating)    # validate type Rating
        elif nodeName_ == 'RatingDate':
            RatingDate_ = child_.text
            RatingDate_ = self.gds_validate_string(RatingDate_, node, 'RatingDate')
            self.RatingDate = RatingDate_
        elif nodeName_ == 'SchoolYear':
            SchoolYear_ = child_.text
            SchoolYear_ = re_.sub(String_cleanup_pat_, " ", SchoolYear_).strip()
            SchoolYear_ = self.gds_validate_string(SchoolYear_, node, 'SchoolYear')
            self.SchoolYear = SchoolYear_
            self.validate_SchoolYearType(self.SchoolYear)    # validate type SchoolYearType
        elif nodeName_ == 'RatingOrganization':
            RatingOrganization_ = child_.text
            RatingOrganization_ = self.gds_validate_string(RatingOrganization_, node, 'RatingOrganization')
            self.RatingOrganization = RatingOrganization_
            self.validate_RatingOrganization(self.RatingOrganization)    # validate type RatingOrganization
        elif nodeName_ == 'RatingProgram':
            RatingProgram_ = child_.text
            RatingProgram_ = self.gds_validate_string(RatingProgram_, node, 'RatingProgram')
            self.RatingProgram = RatingProgram_
            self.validate_RatingProgramType(self.RatingProgram)    # validate type RatingProgramType
# end class AccountabilityRating


class AdditionalCredits(GeneratedsSuper):
    """Additional credits or units of value awarded for the completion of a
    course (e.g., AP, IB, Dual credits)The type of credits or units
    of value awarded for the completion of a course"""
    subclass = None
    superclass = None
    def __init__(self, AdditionalCreditType=None, Credit=None):
        self.AdditionalCreditType = _cast(None, AdditionalCreditType)
        self.Credit = Credit
    def factory(*args_, **kwargs_):
        if AdditionalCredits.subclass:
            return AdditionalCredits.subclass(*args_, **kwargs_)
        else:
            return AdditionalCredits(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Credit(self): return self.Credit
    def set_Credit(self, Credit): self.Credit = Credit
    def get_AdditionalCreditType(self): return self.AdditionalCreditType
    def set_AdditionalCreditType(self, AdditionalCreditType): self.AdditionalCreditType = AdditionalCreditType
    def validate_AdditionalCreditType(self, value):
        # Validate type AdditionalCreditType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='AdditionalCredits', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdditionalCredits')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdditionalCredits'):
        if self.AdditionalCreditType is not None and 'AdditionalCreditType' not in already_processed:
            already_processed.append('AdditionalCreditType')
            outfile.write(' AdditionalCreditType=%s' % (quote_attrib(self.AdditionalCreditType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AdditionalCredits', fromsubclass_=False):
        if self.Credit is not None:
            showIndent(outfile, level)
            outfile.write('<%sCredit>%s</%sCredit>\n' % (namespace_, self.gds_format_float(self.Credit, input_name='Credit'), namespace_))
    def hasContent_(self):
        if (
            self.Credit is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AdditionalCredits'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.AdditionalCreditType is not None and 'AdditionalCreditType' not in already_processed:
            already_processed.append('AdditionalCreditType')
            showIndent(outfile, level)
            outfile.write('AdditionalCreditType = "%s",\n' % (self.AdditionalCreditType,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Credit is not None:
            showIndent(outfile, level)
            outfile.write('Credit=%f,\n' % self.Credit)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('AdditionalCreditType', node)
        if value is not None and 'AdditionalCreditType' not in already_processed:
            already_processed.append('AdditionalCreditType')
            self.AdditionalCreditType = value
            self.AdditionalCreditType = ' '.join(self.AdditionalCreditType.split())
            self.validate_AdditionalCreditType(self.AdditionalCreditType)    # validate type AdditionalCreditType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Credit':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Credit')
            self.Credit = fval_
# end class AdditionalCredits


class Credit(GeneratedsSuper):
    """The value of credits or units of value awarded for the completion of
    a course"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Credit.subclass:
            return Credit.subclass(*args_, **kwargs_)
        else:
            return Credit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Credit', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Credit')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Credit'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Credit', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Credit'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Credit


class Address(GeneratedsSuper):
    """The set of elements that describes an address, including the street
    address, city, state, and ZIP code.The type of address listed
    for an individual or organization. For example: Physical
    Address, Mailing Address, Home Address, etc.)"""
    subclass = None
    superclass = None
    def __init__(self, AddressType=None, StreetNumberName=None, ApartmentRoomSuiteNumber=None, BuildingSiteNumber=None, City=None, StateAbbreviation=None, PostalCode=None, NameOfCounty=None, CountyFIPSCode=None, CountryCode=None, Latitude=None, Longitude=None):
        self.AddressType = _cast(None, AddressType)
        self.StreetNumberName = StreetNumberName
        self.ApartmentRoomSuiteNumber = ApartmentRoomSuiteNumber
        self.BuildingSiteNumber = BuildingSiteNumber
        self.City = City
        self.StateAbbreviation = StateAbbreviation
        self.PostalCode = PostalCode
        self.NameOfCounty = NameOfCounty
        self.CountyFIPSCode = CountyFIPSCode
        self.CountryCode = CountryCode
        self.Latitude = Latitude
        self.Longitude = Longitude
    def factory(*args_, **kwargs_):
        if Address.subclass:
            return Address.subclass(*args_, **kwargs_)
        else:
            return Address(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StreetNumberName(self): return self.StreetNumberName
    def set_StreetNumberName(self, StreetNumberName): self.StreetNumberName = StreetNumberName
    def get_ApartmentRoomSuiteNumber(self): return self.ApartmentRoomSuiteNumber
    def set_ApartmentRoomSuiteNumber(self, ApartmentRoomSuiteNumber): self.ApartmentRoomSuiteNumber = ApartmentRoomSuiteNumber
    def validate_ApartmentRoomSuiteNumber(self, value):
        # Validate type ApartmentRoomSuiteNumber, a restriction on xs:string.
        pass
    def get_BuildingSiteNumber(self): return self.BuildingSiteNumber
    def set_BuildingSiteNumber(self, BuildingSiteNumber): self.BuildingSiteNumber = BuildingSiteNumber
    def validate_BuildingSiteNumber(self, value):
        # Validate type BuildingSiteNumber, a restriction on xs:string.
        pass
    def get_City(self): return self.City
    def set_City(self, City): self.City = City
    def validate_City(self, value):
        # Validate type City, a restriction on xs:string.
        pass
    def get_StateAbbreviation(self): return self.StateAbbreviation
    def set_StateAbbreviation(self, StateAbbreviation): self.StateAbbreviation = StateAbbreviation
    def validate_StateAbbreviationType(self, value):
        # Validate type StateAbbreviationType, a restriction on xs:token.
        pass
    def get_PostalCode(self): return self.PostalCode
    def set_PostalCode(self, PostalCode): self.PostalCode = PostalCode
    def validate_PostalCode(self, value):
        # Validate type PostalCode, a restriction on xs:string.
        pass
    def get_NameOfCounty(self): return self.NameOfCounty
    def set_NameOfCounty(self, NameOfCounty): self.NameOfCounty = NameOfCounty
    def validate_NameOfCounty(self, value):
        # Validate type NameOfCounty, a restriction on xs:string.
        pass
    def get_CountyFIPSCode(self): return self.CountyFIPSCode
    def set_CountyFIPSCode(self, CountyFIPSCode): self.CountyFIPSCode = CountyFIPSCode
    def validate_CountyFIPSCode(self, value):
        # Validate type CountyFIPSCode, a restriction on xs:string.
        pass
    def get_CountryCode(self): return self.CountryCode
    def set_CountryCode(self, CountryCode): self.CountryCode = CountryCode
    def validate_CountryCodeType(self, value):
        # Validate type CountryCodeType, a restriction on xs:token.
        pass
    def get_Latitude(self): return self.Latitude
    def set_Latitude(self, Latitude): self.Latitude = Latitude
    def validate_Coordinate(self, value):
        # Validate type Coordinate, a restriction on xs:string.
        pass
    def get_Longitude(self): return self.Longitude
    def set_Longitude(self, Longitude): self.Longitude = Longitude
    def get_AddressType(self): return self.AddressType
    def set_AddressType(self, AddressType): self.AddressType = AddressType
    def validate_AddressType(self, value):
        # Validate type AddressType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='Address', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Address')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Address'):
        if self.AddressType is not None and 'AddressType' not in already_processed:
            already_processed.append('AddressType')
            outfile.write(' AddressType=%s' % (quote_attrib(self.AddressType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Address', fromsubclass_=False):
        if self.StreetNumberName is not None:
            showIndent(outfile, level)
            outfile.write('<%sStreetNumberName>%s</%sStreetNumberName>\n' % (namespace_, self.gds_format_string(quote_xml(self.StreetNumberName).encode(ExternalEncoding), input_name='StreetNumberName'), namespace_))
        if self.ApartmentRoomSuiteNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sApartmentRoomSuiteNumber>%s</%sApartmentRoomSuiteNumber>\n' % (namespace_, self.gds_format_string(quote_xml(self.ApartmentRoomSuiteNumber).encode(ExternalEncoding), input_name='ApartmentRoomSuiteNumber'), namespace_))
        if self.BuildingSiteNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sBuildingSiteNumber>%s</%sBuildingSiteNumber>\n' % (namespace_, self.gds_format_string(quote_xml(self.BuildingSiteNumber).encode(ExternalEncoding), input_name='BuildingSiteNumber'), namespace_))
        if self.City is not None:
            showIndent(outfile, level)
            outfile.write('<%sCity>%s</%sCity>\n' % (namespace_, self.gds_format_string(quote_xml(self.City).encode(ExternalEncoding), input_name='City'), namespace_))
        if self.StateAbbreviation is not None:
            showIndent(outfile, level)
            outfile.write('<%sStateAbbreviation>%s</%sStateAbbreviation>\n' % (namespace_, self.gds_format_string(quote_xml(self.StateAbbreviation).encode(ExternalEncoding), input_name='StateAbbreviation'), namespace_))
        if self.PostalCode is not None:
            showIndent(outfile, level)
            outfile.write('<%sPostalCode>%s</%sPostalCode>\n' % (namespace_, self.gds_format_string(quote_xml(self.PostalCode).encode(ExternalEncoding), input_name='PostalCode'), namespace_))
        if self.NameOfCounty is not None:
            showIndent(outfile, level)
            outfile.write('<%sNameOfCounty>%s</%sNameOfCounty>\n' % (namespace_, self.gds_format_string(quote_xml(self.NameOfCounty).encode(ExternalEncoding), input_name='NameOfCounty'), namespace_))
        if self.CountyFIPSCode is not None:
            showIndent(outfile, level)
            outfile.write('<%sCountyFIPSCode>%s</%sCountyFIPSCode>\n' % (namespace_, self.gds_format_string(quote_xml(self.CountyFIPSCode).encode(ExternalEncoding), input_name='CountyFIPSCode'), namespace_))
        if self.CountryCode is not None:
            showIndent(outfile, level)
            outfile.write('<%sCountryCode>%s</%sCountryCode>\n' % (namespace_, self.gds_format_string(quote_xml(self.CountryCode).encode(ExternalEncoding), input_name='CountryCode'), namespace_))
        if self.Latitude is not None:
            showIndent(outfile, level)
            outfile.write('<%sLatitude>%s</%sLatitude>\n' % (namespace_, self.gds_format_string(quote_xml(self.Latitude).encode(ExternalEncoding), input_name='Latitude'), namespace_))
        if self.Longitude is not None:
            showIndent(outfile, level)
            outfile.write('<%sLongitude>%s</%sLongitude>\n' % (namespace_, self.gds_format_string(quote_xml(self.Longitude).encode(ExternalEncoding), input_name='Longitude'), namespace_))
    def hasContent_(self):
        if (
            self.StreetNumberName is not None or
            self.ApartmentRoomSuiteNumber is not None or
            self.BuildingSiteNumber is not None or
            self.City is not None or
            self.StateAbbreviation is not None or
            self.PostalCode is not None or
            self.NameOfCounty is not None or
            self.CountyFIPSCode is not None or
            self.CountryCode is not None or
            self.Latitude is not None or
            self.Longitude is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Address'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.AddressType is not None and 'AddressType' not in already_processed:
            already_processed.append('AddressType')
            showIndent(outfile, level)
            outfile.write('AddressType = "%s",\n' % (self.AddressType,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StreetNumberName is not None:
            showIndent(outfile, level)
            outfile.write('StreetNumberName=%s,\n' % quote_python(self.StreetNumberName).encode(ExternalEncoding))
        if self.ApartmentRoomSuiteNumber is not None:
            showIndent(outfile, level)
            outfile.write('ApartmentRoomSuiteNumber=%s,\n' % quote_python(self.ApartmentRoomSuiteNumber).encode(ExternalEncoding))
        if self.BuildingSiteNumber is not None:
            showIndent(outfile, level)
            outfile.write('BuildingSiteNumber=%s,\n' % quote_python(self.BuildingSiteNumber).encode(ExternalEncoding))
        if self.City is not None:
            showIndent(outfile, level)
            outfile.write('City=%s,\n' % quote_python(self.City).encode(ExternalEncoding))
        if self.StateAbbreviation is not None:
            showIndent(outfile, level)
            outfile.write('StateAbbreviation=%s,\n' % quote_python(self.StateAbbreviation).encode(ExternalEncoding))
        if self.PostalCode is not None:
            showIndent(outfile, level)
            outfile.write('PostalCode=%s,\n' % quote_python(self.PostalCode).encode(ExternalEncoding))
        if self.NameOfCounty is not None:
            showIndent(outfile, level)
            outfile.write('NameOfCounty=%s,\n' % quote_python(self.NameOfCounty).encode(ExternalEncoding))
        if self.CountyFIPSCode is not None:
            showIndent(outfile, level)
            outfile.write('CountyFIPSCode=%s,\n' % quote_python(self.CountyFIPSCode).encode(ExternalEncoding))
        if self.CountryCode is not None:
            showIndent(outfile, level)
            outfile.write('CountryCode=%s,\n' % quote_python(self.CountryCode).encode(ExternalEncoding))
        if self.Latitude is not None:
            showIndent(outfile, level)
            outfile.write('Latitude=%s,\n' % quote_python(self.Latitude).encode(ExternalEncoding))
        if self.Longitude is not None:
            showIndent(outfile, level)
            outfile.write('Longitude=%s,\n' % quote_python(self.Longitude).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('AddressType', node)
        if value is not None and 'AddressType' not in already_processed:
            already_processed.append('AddressType')
            self.AddressType = value
            self.AddressType = ' '.join(self.AddressType.split())
            self.validate_AddressType(self.AddressType)    # validate type AddressType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StreetNumberName':
            StreetNumberName_ = child_.text
            StreetNumberName_ = self.gds_validate_string(StreetNumberName_, node, 'StreetNumberName')
            self.StreetNumberName = StreetNumberName_
        elif nodeName_ == 'ApartmentRoomSuiteNumber':
            ApartmentRoomSuiteNumber_ = child_.text
            ApartmentRoomSuiteNumber_ = self.gds_validate_string(ApartmentRoomSuiteNumber_, node, 'ApartmentRoomSuiteNumber')
            self.ApartmentRoomSuiteNumber = ApartmentRoomSuiteNumber_
            self.validate_ApartmentRoomSuiteNumber(self.ApartmentRoomSuiteNumber)    # validate type ApartmentRoomSuiteNumber
        elif nodeName_ == 'BuildingSiteNumber':
            BuildingSiteNumber_ = child_.text
            BuildingSiteNumber_ = self.gds_validate_string(BuildingSiteNumber_, node, 'BuildingSiteNumber')
            self.BuildingSiteNumber = BuildingSiteNumber_
            self.validate_BuildingSiteNumber(self.BuildingSiteNumber)    # validate type BuildingSiteNumber
        elif nodeName_ == 'City':
            City_ = child_.text
            City_ = self.gds_validate_string(City_, node, 'City')
            self.City = City_
            self.validate_City(self.City)    # validate type City
        elif nodeName_ == 'StateAbbreviation':
            StateAbbreviation_ = child_.text
            StateAbbreviation_ = re_.sub(String_cleanup_pat_, " ", StateAbbreviation_).strip()
            StateAbbreviation_ = self.gds_validate_string(StateAbbreviation_, node, 'StateAbbreviation')
            self.StateAbbreviation = StateAbbreviation_
            self.validate_StateAbbreviationType(self.StateAbbreviation)    # validate type StateAbbreviationType
        elif nodeName_ == 'PostalCode':
            PostalCode_ = child_.text
            PostalCode_ = self.gds_validate_string(PostalCode_, node, 'PostalCode')
            self.PostalCode = PostalCode_
            self.validate_PostalCode(self.PostalCode)    # validate type PostalCode
        elif nodeName_ == 'NameOfCounty':
            NameOfCounty_ = child_.text
            NameOfCounty_ = self.gds_validate_string(NameOfCounty_, node, 'NameOfCounty')
            self.NameOfCounty = NameOfCounty_
            self.validate_NameOfCounty(self.NameOfCounty)    # validate type NameOfCounty
        elif nodeName_ == 'CountyFIPSCode':
            CountyFIPSCode_ = child_.text
            CountyFIPSCode_ = self.gds_validate_string(CountyFIPSCode_, node, 'CountyFIPSCode')
            self.CountyFIPSCode = CountyFIPSCode_
            self.validate_CountyFIPSCode(self.CountyFIPSCode)    # validate type CountyFIPSCode
        elif nodeName_ == 'CountryCode':
            CountryCode_ = child_.text
            CountryCode_ = re_.sub(String_cleanup_pat_, " ", CountryCode_).strip()
            CountryCode_ = self.gds_validate_string(CountryCode_, node, 'CountryCode')
            self.CountryCode = CountryCode_
            self.validate_CountryCodeType(self.CountryCode)    # validate type CountryCodeType
        elif nodeName_ == 'Latitude':
            Latitude_ = child_.text
            Latitude_ = self.gds_validate_string(Latitude_, node, 'Latitude')
            self.Latitude = Latitude_
            self.validate_Coordinate(self.Latitude)    # validate type Coordinate
        elif nodeName_ == 'Longitude':
            Longitude_ = child_.text
            Longitude_ = self.gds_validate_string(Longitude_, node, 'Longitude')
            self.Longitude = Longitude_
            self.validate_Coordinate(self.Longitude)    # validate type Coordinate
# end class Address


class StreetNumberName(GeneratedsSuper):
    """The street number and street name or post office box number of an
    address."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if StreetNumberName.subclass:
            return StreetNumberName.subclass(*args_, **kwargs_)
        else:
            return StreetNumberName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='StreetNumberName', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StreetNumberName')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StreetNumberName'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StreetNumberName', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StreetNumberName'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class StreetNumberName


class AssessmentIdentificationCode(GeneratedsSuper):
    """A unique number or alphanumeric code assigned to an assessment by a
    school, school system, a state, or other agency or entity.A
    coding scheme that is used for identification and record-keeping
    purposes by schools, social services, or other agencies to refer
    to an assessment.The organization code or name assigning the
    assessment identification code."""
    subclass = None
    superclass = None
    def __init__(self, IdentificationSystem=None, AssigningOrganizationCode=None, ID=None):
        self.IdentificationSystem = _cast(None, IdentificationSystem)
        self.AssigningOrganizationCode = _cast(None, AssigningOrganizationCode)
        self.ID = ID
    def factory(*args_, **kwargs_):
        if AssessmentIdentificationCode.subclass:
            return AssessmentIdentificationCode.subclass(*args_, **kwargs_)
        else:
            return AssessmentIdentificationCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_IdentificationCode(self, value):
        # Validate type IdentificationCode, a restriction on xs:string.
        pass
    def get_IdentificationSystem(self): return self.IdentificationSystem
    def set_IdentificationSystem(self, IdentificationSystem): self.IdentificationSystem = IdentificationSystem
    def validate_AssessmentIdentificationSystemType(self, value):
        # Validate type AssessmentIdentificationSystemType, a restriction on xs:token.
        pass
    def get_AssigningOrganizationCode(self): return self.AssigningOrganizationCode
    def set_AssigningOrganizationCode(self, AssigningOrganizationCode): self.AssigningOrganizationCode = AssigningOrganizationCode
    def export(self, outfile, level, namespace_='', name_='AssessmentIdentificationCode', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssessmentIdentificationCode')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AssessmentIdentificationCode'):
        if self.IdentificationSystem is not None and 'IdentificationSystem' not in already_processed:
            already_processed.append('IdentificationSystem')
            outfile.write(' IdentificationSystem=%s' % (quote_attrib(self.IdentificationSystem), ))
        if self.AssigningOrganizationCode is not None and 'AssigningOrganizationCode' not in already_processed:
            already_processed.append('AssigningOrganizationCode')
            outfile.write(' AssigningOrganizationCode=%s' % (self.gds_format_string(quote_attrib(self.AssigningOrganizationCode).encode(ExternalEncoding), input_name='AssigningOrganizationCode'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AssessmentIdentificationCode', fromsubclass_=False):
        if self.ID is not None:
            showIndent(outfile, level)
            outfile.write('<%sID>%s</%sID>\n' % (namespace_, self.gds_format_string(quote_xml(self.ID).encode(ExternalEncoding), input_name='ID'), namespace_))
    def hasContent_(self):
        if (
            self.ID is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AssessmentIdentificationCode'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.IdentificationSystem is not None and 'IdentificationSystem' not in already_processed:
            already_processed.append('IdentificationSystem')
            showIndent(outfile, level)
            outfile.write('IdentificationSystem = "%s",\n' % (self.IdentificationSystem,))
        if self.AssigningOrganizationCode is not None and 'AssigningOrganizationCode' not in already_processed:
            already_processed.append('AssigningOrganizationCode')
            showIndent(outfile, level)
            outfile.write('AssigningOrganizationCode = "%s",\n' % (self.AssigningOrganizationCode,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ID is not None:
            showIndent(outfile, level)
            outfile.write('ID=%s,\n' % quote_python(self.ID).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IdentificationSystem', node)
        if value is not None and 'IdentificationSystem' not in already_processed:
            already_processed.append('IdentificationSystem')
            self.IdentificationSystem = value
            self.IdentificationSystem = ' '.join(self.IdentificationSystem.split())
            self.validate_AssessmentIdentificationSystemType(self.IdentificationSystem)    # validate type AssessmentIdentificationSystemType
        value = find_attr_value_('AssigningOrganizationCode', node)
        if value is not None and 'AssigningOrganizationCode' not in already_processed:
            already_processed.append('AssigningOrganizationCode')
            self.AssigningOrganizationCode = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
            self.validate_IdentificationCode(self.ID)    # validate type IdentificationCode
# end class AssessmentIdentificationCode


class AssessmentResult(GeneratedsSuper):
    """Additional analytic scores, percentiles, or measures"""
    subclass = None
    superclass = None
    def __init__(self, AssessmentReportingMethod=None, Result=None):
        self.AssessmentReportingMethod = _cast(None, AssessmentReportingMethod)
        self.Result = Result
    def factory(*args_, **kwargs_):
        if AssessmentResult.subclass:
            return AssessmentResult.subclass(*args_, **kwargs_)
        else:
            return AssessmentResult(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Result(self): return self.Result
    def set_Result(self, Result): self.Result = Result
    def get_AssessmentReportingMethod(self): return self.AssessmentReportingMethod
    def set_AssessmentReportingMethod(self, AssessmentReportingMethod): self.AssessmentReportingMethod = AssessmentReportingMethod
    def validate_AssessmentReportingMethodType(self, value):
        # Validate type AssessmentReportingMethodType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='AssessmentResult', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssessmentResult')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AssessmentResult'):
        if self.AssessmentReportingMethod is not None and 'AssessmentReportingMethod' not in already_processed:
            already_processed.append('AssessmentReportingMethod')
            outfile.write(' AssessmentReportingMethod=%s' % (quote_attrib(self.AssessmentReportingMethod), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AssessmentResult', fromsubclass_=False):
        if self.Result is not None:
            showIndent(outfile, level)
            outfile.write('<%sResult>%s</%sResult>\n' % (namespace_, self.gds_format_float(self.Result, input_name='Result'), namespace_))
    def hasContent_(self):
        if (
            self.Result is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AssessmentResult'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.AssessmentReportingMethod is not None and 'AssessmentReportingMethod' not in already_processed:
            already_processed.append('AssessmentReportingMethod')
            showIndent(outfile, level)
            outfile.write('AssessmentReportingMethod = "%s",\n' % (self.AssessmentReportingMethod,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Result is not None:
            showIndent(outfile, level)
            outfile.write('Result=%f,\n' % self.Result)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('AssessmentReportingMethod', node)
        if value is not None and 'AssessmentReportingMethod' not in already_processed:
            already_processed.append('AssessmentReportingMethod')
            self.AssessmentReportingMethod = value
            self.AssessmentReportingMethod = ' '.join(self.AssessmentReportingMethod.split())
            self.validate_AssessmentReportingMethodType(self.AssessmentReportingMethod)    # validate type AssessmentReportingMethodType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Result':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Result')
            self.Result = fval_
# end class AssessmentResult


class BirthData(GeneratedsSuper):
    """The set of elements that capture relevant data regarding a person's
    birth, including birth date and place of birth."""
    subclass = None
    superclass = None
    def __init__(self, BirthDate=None, CityOfBirth=None, StateOfBirthAbbreviation=None, CountryOfBirthCode=None, DateEnteredUS=None, MultipleBirthStatus=None):
        self.BirthDate = BirthDate
        self.CityOfBirth = CityOfBirth
        self.StateOfBirthAbbreviation = StateOfBirthAbbreviation
        self.CountryOfBirthCode = CountryOfBirthCode
        self.DateEnteredUS = DateEnteredUS
        self.MultipleBirthStatus = MultipleBirthStatus
    def factory(*args_, **kwargs_):
        if BirthData.subclass:
            return BirthData.subclass(*args_, **kwargs_)
        else:
            return BirthData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BirthDate(self): return self.BirthDate
    def set_BirthDate(self, BirthDate): self.BirthDate = BirthDate
    def get_CityOfBirth(self): return self.CityOfBirth
    def set_CityOfBirth(self, CityOfBirth): self.CityOfBirth = CityOfBirth
    def validate_City(self, value):
        # Validate type City, a restriction on xs:string.
        pass
    def get_StateOfBirthAbbreviation(self): return self.StateOfBirthAbbreviation
    def set_StateOfBirthAbbreviation(self, StateOfBirthAbbreviation): self.StateOfBirthAbbreviation = StateOfBirthAbbreviation
    def validate_StateAbbreviationType(self, value):
        # Validate type StateAbbreviationType, a restriction on xs:token.
        pass
    def get_CountryOfBirthCode(self): return self.CountryOfBirthCode
    def set_CountryOfBirthCode(self, CountryOfBirthCode): self.CountryOfBirthCode = CountryOfBirthCode
    def validate_CountryCodeType(self, value):
        # Validate type CountryCodeType, a restriction on xs:token.
        pass
    def get_DateEnteredUS(self): return self.DateEnteredUS
    def set_DateEnteredUS(self, DateEnteredUS): self.DateEnteredUS = DateEnteredUS
    def get_MultipleBirthStatus(self): return self.MultipleBirthStatus
    def set_MultipleBirthStatus(self, MultipleBirthStatus): self.MultipleBirthStatus = MultipleBirthStatus
    def export(self, outfile, level, namespace_='', name_='BirthData', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BirthData')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BirthData'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BirthData', fromsubclass_=False):
        if self.BirthDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sBirthDate>%s</%sBirthDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.BirthDate).encode(ExternalEncoding), input_name='BirthDate'), namespace_))
        if self.CityOfBirth is not None:
            showIndent(outfile, level)
            outfile.write('<%sCityOfBirth>%s</%sCityOfBirth>\n' % (namespace_, self.gds_format_string(quote_xml(self.CityOfBirth).encode(ExternalEncoding), input_name='CityOfBirth'), namespace_))
        if self.StateOfBirthAbbreviation is not None:
            showIndent(outfile, level)
            outfile.write('<%sStateOfBirthAbbreviation>%s</%sStateOfBirthAbbreviation>\n' % (namespace_, self.gds_format_string(quote_xml(self.StateOfBirthAbbreviation).encode(ExternalEncoding), input_name='StateOfBirthAbbreviation'), namespace_))
        if self.CountryOfBirthCode is not None:
            showIndent(outfile, level)
            outfile.write('<%sCountryOfBirthCode>%s</%sCountryOfBirthCode>\n' % (namespace_, self.gds_format_string(quote_xml(self.CountryOfBirthCode).encode(ExternalEncoding), input_name='CountryOfBirthCode'), namespace_))
        if self.DateEnteredUS is not None:
            showIndent(outfile, level)
            outfile.write('<%sDateEnteredUS>%s</%sDateEnteredUS>\n' % (namespace_, self.gds_format_string(quote_xml(self.DateEnteredUS).encode(ExternalEncoding), input_name='DateEnteredUS'), namespace_))
        if self.MultipleBirthStatus is not None:
            showIndent(outfile, level)
            outfile.write('<%sMultipleBirthStatus>%s</%sMultipleBirthStatus>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.MultipleBirthStatus)), input_name='MultipleBirthStatus'), namespace_))
    def hasContent_(self):
        if (
            self.BirthDate is not None or
            self.CityOfBirth is not None or
            self.StateOfBirthAbbreviation is not None or
            self.CountryOfBirthCode is not None or
            self.DateEnteredUS is not None or
            self.MultipleBirthStatus is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BirthData'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.BirthDate is not None:
            showIndent(outfile, level)
            outfile.write('BirthDate=%s,\n' % quote_python(self.BirthDate).encode(ExternalEncoding))
        if self.CityOfBirth is not None:
            showIndent(outfile, level)
            outfile.write('CityOfBirth=%s,\n' % quote_python(self.CityOfBirth).encode(ExternalEncoding))
        if self.StateOfBirthAbbreviation is not None:
            showIndent(outfile, level)
            outfile.write('StateOfBirthAbbreviation=%s,\n' % quote_python(self.StateOfBirthAbbreviation).encode(ExternalEncoding))
        if self.CountryOfBirthCode is not None:
            showIndent(outfile, level)
            outfile.write('CountryOfBirthCode=%s,\n' % quote_python(self.CountryOfBirthCode).encode(ExternalEncoding))
        if self.DateEnteredUS is not None:
            showIndent(outfile, level)
            outfile.write('DateEnteredUS=%s,\n' % quote_python(self.DateEnteredUS).encode(ExternalEncoding))
        if self.MultipleBirthStatus is not None:
            showIndent(outfile, level)
            outfile.write('MultipleBirthStatus=%s,\n' % self.MultipleBirthStatus)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BirthDate':
            BirthDate_ = child_.text
            BirthDate_ = self.gds_validate_string(BirthDate_, node, 'BirthDate')
            self.BirthDate = BirthDate_
        elif nodeName_ == 'CityOfBirth':
            CityOfBirth_ = child_.text
            CityOfBirth_ = self.gds_validate_string(CityOfBirth_, node, 'CityOfBirth')
            self.CityOfBirth = CityOfBirth_
            self.validate_City(self.CityOfBirth)    # validate type City
        elif nodeName_ == 'StateOfBirthAbbreviation':
            StateOfBirthAbbreviation_ = child_.text
            StateOfBirthAbbreviation_ = re_.sub(String_cleanup_pat_, " ", StateOfBirthAbbreviation_).strip()
            StateOfBirthAbbreviation_ = self.gds_validate_string(StateOfBirthAbbreviation_, node, 'StateOfBirthAbbreviation')
            self.StateOfBirthAbbreviation = StateOfBirthAbbreviation_
            self.validate_StateAbbreviationType(self.StateOfBirthAbbreviation)    # validate type StateAbbreviationType
        elif nodeName_ == 'CountryOfBirthCode':
            CountryOfBirthCode_ = child_.text
            CountryOfBirthCode_ = re_.sub(String_cleanup_pat_, " ", CountryOfBirthCode_).strip()
            CountryOfBirthCode_ = self.gds_validate_string(CountryOfBirthCode_, node, 'CountryOfBirthCode')
            self.CountryOfBirthCode = CountryOfBirthCode_
            self.validate_CountryCodeType(self.CountryOfBirthCode)    # validate type CountryCodeType
        elif nodeName_ == 'DateEnteredUS':
            DateEnteredUS_ = child_.text
            DateEnteredUS_ = self.gds_validate_string(DateEnteredUS_, node, 'DateEnteredUS')
            self.DateEnteredUS = DateEnteredUS_
        elif nodeName_ == 'MultipleBirthStatus':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'MultipleBirthStatus')
            self.MultipleBirthStatus = ival_
# end class BirthData


class ClassRanking(GeneratedsSuper):
    """The academic rank information of a student in relation to his or her
    graduating class"""
    subclass = None
    superclass = None
    def __init__(self, ClassRank=None, TotalNumberInClass=None, PercentageRanking=None, ClassRankingDate=None):
        self.ClassRank = ClassRank
        self.TotalNumberInClass = TotalNumberInClass
        self.PercentageRanking = PercentageRanking
        self.ClassRankingDate = ClassRankingDate
    def factory(*args_, **kwargs_):
        if ClassRanking.subclass:
            return ClassRanking.subclass(*args_, **kwargs_)
        else:
            return ClassRanking(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ClassRank(self): return self.ClassRank
    def set_ClassRank(self, ClassRank): self.ClassRank = ClassRank
    def get_TotalNumberInClass(self): return self.TotalNumberInClass
    def set_TotalNumberInClass(self, TotalNumberInClass): self.TotalNumberInClass = TotalNumberInClass
    def get_PercentageRanking(self): return self.PercentageRanking
    def set_PercentageRanking(self, PercentageRanking): self.PercentageRanking = PercentageRanking
    def get_ClassRankingDate(self): return self.ClassRankingDate
    def set_ClassRankingDate(self, ClassRankingDate): self.ClassRankingDate = ClassRankingDate
    def export(self, outfile, level, namespace_='', name_='ClassRanking', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClassRanking')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ClassRanking'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ClassRanking', fromsubclass_=False):
        if self.ClassRank is not None:
            showIndent(outfile, level)
            outfile.write('<%sClassRank>%s</%sClassRank>\n' % (namespace_, self.gds_format_integer(self.ClassRank, input_name='ClassRank'), namespace_))
        if self.TotalNumberInClass is not None:
            showIndent(outfile, level)
            outfile.write('<%sTotalNumberInClass>%s</%sTotalNumberInClass>\n' % (namespace_, self.gds_format_integer(self.TotalNumberInClass, input_name='TotalNumberInClass'), namespace_))
        if self.PercentageRanking is not None:
            showIndent(outfile, level)
            outfile.write('<%sPercentageRanking>%s</%sPercentageRanking>\n' % (namespace_, self.gds_format_integer(self.PercentageRanking, input_name='PercentageRanking'), namespace_))
        if self.ClassRankingDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sClassRankingDate>%s</%sClassRankingDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.ClassRankingDate).encode(ExternalEncoding), input_name='ClassRankingDate'), namespace_))
    def hasContent_(self):
        if (
            self.ClassRank is not None or
            self.TotalNumberInClass is not None or
            self.PercentageRanking is not None or
            self.ClassRankingDate is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ClassRanking'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ClassRank is not None:
            showIndent(outfile, level)
            outfile.write('ClassRank=%d,\n' % self.ClassRank)
        if self.TotalNumberInClass is not None:
            showIndent(outfile, level)
            outfile.write('TotalNumberInClass=%d,\n' % self.TotalNumberInClass)
        if self.PercentageRanking is not None:
            showIndent(outfile, level)
            outfile.write('PercentageRanking=%d,\n' % self.PercentageRanking)
        if self.ClassRankingDate is not None:
            showIndent(outfile, level)
            outfile.write('ClassRankingDate=%s,\n' % quote_python(self.ClassRankingDate).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ClassRank':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ClassRank')
            self.ClassRank = ival_
        elif nodeName_ == 'TotalNumberInClass':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TotalNumberInClass')
            self.TotalNumberInClass = ival_
        elif nodeName_ == 'PercentageRanking':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'PercentageRanking')
            self.PercentageRanking = ival_
        elif nodeName_ == 'ClassRankingDate':
            ClassRankingDate_ = child_.text
            ClassRankingDate_ = self.gds_validate_string(ClassRankingDate_, node, 'ClassRankingDate')
            self.ClassRankingDate = ClassRankingDate_
# end class ClassRanking


class CohortYear(GeneratedsSuper):
    """The type and year of a cohort (e.g., 9th grade, graduation) the
    student belongs to.The type of cohort year (9th grade,
    graduation)"""
    subclass = None
    superclass = None
    def __init__(self, CohortYearType=None, Year=None):
        self.CohortYearType = _cast(None, CohortYearType)
        self.Year = Year
    def factory(*args_, **kwargs_):
        if CohortYear.subclass:
            return CohortYear.subclass(*args_, **kwargs_)
        else:
            return CohortYear(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Year(self): return self.Year
    def set_Year(self, Year): self.Year = Year
    def get_CohortYearType(self): return self.CohortYearType
    def set_CohortYearType(self, CohortYearType): self.CohortYearType = CohortYearType
    def validate_CohortYearType(self, value):
        # Validate type CohortYearType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='CohortYear', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CohortYear')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CohortYear'):
        if self.CohortYearType is not None and 'CohortYearType' not in already_processed:
            already_processed.append('CohortYearType')
            outfile.write(' CohortYearType=%s' % (quote_attrib(self.CohortYearType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CohortYear', fromsubclass_=False):
        if self.Year:
            self.Year.export(outfile, level, namespace_, name_='Year', )
    def hasContent_(self):
        if (
            self.Year is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CohortYear'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.CohortYearType is not None and 'CohortYearType' not in already_processed:
            already_processed.append('CohortYearType')
            showIndent(outfile, level)
            outfile.write('CohortYearType = "%s",\n' % (self.CohortYearType,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Year is not None:
            showIndent(outfile, level)
            outfile.write('Year=model_.xs_gYear(\n')
            self.Year.exportLiteral(outfile, level, name_='Year')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('CohortYearType', node)
        if value is not None and 'CohortYearType' not in already_processed:
            already_processed.append('CohortYearType')
            self.CohortYearType = value
            self.CohortYearType = ' '.join(self.CohortYearType.split())
            self.validate_CohortYearType(self.CohortYearType)    # validate type CohortYearType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Year':
            obj_ = xs_gYear.factory()
            obj_.build(child_)
            self.set_Year(obj_)
# end class CohortYear


class CourseCode(GeneratedsSuper):
    """The actual code that identifies the organization of subject matter
    and related learning experiences provided for the instruction of
    students.A system that is used to identify the organization of
    subject matter and related learning experiences provided for the
    instruction of students.The organization code or name assigning
    the staff Identification Code."""
    subclass = None
    superclass = None
    def __init__(self, IdentificationSystem=None, AssigningOrganizationCode=None, ID=None):
        self.IdentificationSystem = _cast(None, IdentificationSystem)
        self.AssigningOrganizationCode = _cast(None, AssigningOrganizationCode)
        self.ID = ID
    def factory(*args_, **kwargs_):
        if CourseCode.subclass:
            return CourseCode.subclass(*args_, **kwargs_)
        else:
            return CourseCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_IdentificationCode(self, value):
        # Validate type IdentificationCode, a restriction on xs:string.
        pass
    def get_IdentificationSystem(self): return self.IdentificationSystem
    def set_IdentificationSystem(self, IdentificationSystem): self.IdentificationSystem = IdentificationSystem
    def validate_CourseCodeSystemType(self, value):
        # Validate type CourseCodeSystemType, a restriction on xs:token.
        pass
    def get_AssigningOrganizationCode(self): return self.AssigningOrganizationCode
    def set_AssigningOrganizationCode(self, AssigningOrganizationCode): self.AssigningOrganizationCode = AssigningOrganizationCode
    def export(self, outfile, level, namespace_='', name_='CourseCode', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CourseCode')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CourseCode'):
        if self.IdentificationSystem is not None and 'IdentificationSystem' not in already_processed:
            already_processed.append('IdentificationSystem')
            outfile.write(' IdentificationSystem=%s' % (quote_attrib(self.IdentificationSystem), ))
        if self.AssigningOrganizationCode is not None and 'AssigningOrganizationCode' not in already_processed:
            already_processed.append('AssigningOrganizationCode')
            outfile.write(' AssigningOrganizationCode=%s' % (self.gds_format_string(quote_attrib(self.AssigningOrganizationCode).encode(ExternalEncoding), input_name='AssigningOrganizationCode'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CourseCode', fromsubclass_=False):
        if self.ID is not None:
            showIndent(outfile, level)
            outfile.write('<%sID>%s</%sID>\n' % (namespace_, self.gds_format_string(quote_xml(self.ID).encode(ExternalEncoding), input_name='ID'), namespace_))
    def hasContent_(self):
        if (
            self.ID is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CourseCode'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.IdentificationSystem is not None and 'IdentificationSystem' not in already_processed:
            already_processed.append('IdentificationSystem')
            showIndent(outfile, level)
            outfile.write('IdentificationSystem = "%s",\n' % (self.IdentificationSystem,))
        if self.AssigningOrganizationCode is not None and 'AssigningOrganizationCode' not in already_processed:
            already_processed.append('AssigningOrganizationCode')
            showIndent(outfile, level)
            outfile.write('AssigningOrganizationCode = "%s",\n' % (self.AssigningOrganizationCode,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ID is not None:
            showIndent(outfile, level)
            outfile.write('ID=%s,\n' % quote_python(self.ID).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IdentificationSystem', node)
        if value is not None and 'IdentificationSystem' not in already_processed:
            already_processed.append('IdentificationSystem')
            self.IdentificationSystem = value
            self.IdentificationSystem = ' '.join(self.IdentificationSystem.split())
            self.validate_CourseCodeSystemType(self.IdentificationSystem)    # validate type CourseCodeSystemType
        value = find_attr_value_('AssigningOrganizationCode', node)
        if value is not None and 'AssigningOrganizationCode' not in already_processed:
            already_processed.append('AssigningOrganizationCode')
            self.AssigningOrganizationCode = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
            self.validate_IdentificationCode(self.ID)    # validate type IdentificationCode
# end class CourseCode


class Credential(GeneratedsSuper):
    """The legal document or authorization giving authorization to perform
    teaching assignment services."""
    subclass = None
    superclass = None
    def __init__(self, CredentialType=None, Field=None, Level=None, TeachingCredentialType=None, CredentialIssuanceDate=None, CredentialExpirationDate=None, TeachingCredentialBasis=None):
        self.CredentialType = CredentialType
        self.Field = Field
        self.Level = Level
        self.TeachingCredentialType = TeachingCredentialType
        self.CredentialIssuanceDate = CredentialIssuanceDate
        self.CredentialExpirationDate = CredentialExpirationDate
        self.TeachingCredentialBasis = TeachingCredentialBasis
    def factory(*args_, **kwargs_):
        if Credential.subclass:
            return Credential.subclass(*args_, **kwargs_)
        else:
            return Credential(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CredentialType(self): return self.CredentialType
    def set_CredentialType(self, CredentialType): self.CredentialType = CredentialType
    def validate_CredentialType(self, value):
        # Validate type CredentialType, a restriction on xs:token.
        pass
    def get_Field(self): return self.Field
    def set_Field(self, Field): self.Field = Field
    def validate_FieldType(self, value):
        # Validate type FieldType, a restriction on xs:token.
        pass
    def get_Level(self): return self.Level
    def set_Level(self, Level): self.Level = Level
    def validate_LevelType(self, value):
        # Validate type LevelType, a restriction on xs:token.
        pass
    def get_TeachingCredentialType(self): return self.TeachingCredentialType
    def set_TeachingCredentialType(self, TeachingCredentialType): self.TeachingCredentialType = TeachingCredentialType
    def validate_TeachingCredentialType(self, value):
        # Validate type TeachingCredentialType, a restriction on xs:token.
        pass
    def get_CredentialIssuanceDate(self): return self.CredentialIssuanceDate
    def set_CredentialIssuanceDate(self, CredentialIssuanceDate): self.CredentialIssuanceDate = CredentialIssuanceDate
    def get_CredentialExpirationDate(self): return self.CredentialExpirationDate
    def set_CredentialExpirationDate(self, CredentialExpirationDate): self.CredentialExpirationDate = CredentialExpirationDate
    def get_TeachingCredentialBasis(self): return self.TeachingCredentialBasis
    def set_TeachingCredentialBasis(self, TeachingCredentialBasis): self.TeachingCredentialBasis = TeachingCredentialBasis
    def validate_TeachingCredentialBasisType(self, value):
        # Validate type TeachingCredentialBasisType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='Credential', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Credential')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Credential'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Credential', fromsubclass_=False):
        if self.CredentialType is not None:
            showIndent(outfile, level)
            outfile.write('<%sCredentialType>%s</%sCredentialType>\n' % (namespace_, self.gds_format_string(quote_xml(self.CredentialType).encode(ExternalEncoding), input_name='CredentialType'), namespace_))
        if self.Field is not None:
            showIndent(outfile, level)
            outfile.write('<%sField>%s</%sField>\n' % (namespace_, self.gds_format_string(quote_xml(self.Field).encode(ExternalEncoding), input_name='Field'), namespace_))
        if self.Level is not None:
            showIndent(outfile, level)
            outfile.write('<%sLevel>%s</%sLevel>\n' % (namespace_, self.gds_format_string(quote_xml(self.Level).encode(ExternalEncoding), input_name='Level'), namespace_))
        if self.TeachingCredentialType is not None:
            showIndent(outfile, level)
            outfile.write('<%sTeachingCredentialType>%s</%sTeachingCredentialType>\n' % (namespace_, self.gds_format_string(quote_xml(self.TeachingCredentialType).encode(ExternalEncoding), input_name='TeachingCredentialType'), namespace_))
        if self.CredentialIssuanceDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sCredentialIssuanceDate>%s</%sCredentialIssuanceDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.CredentialIssuanceDate).encode(ExternalEncoding), input_name='CredentialIssuanceDate'), namespace_))
        if self.CredentialExpirationDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sCredentialExpirationDate>%s</%sCredentialExpirationDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.CredentialExpirationDate).encode(ExternalEncoding), input_name='CredentialExpirationDate'), namespace_))
        if self.TeachingCredentialBasis is not None:
            showIndent(outfile, level)
            outfile.write('<%sTeachingCredentialBasis>%s</%sTeachingCredentialBasis>\n' % (namespace_, self.gds_format_string(quote_xml(self.TeachingCredentialBasis).encode(ExternalEncoding), input_name='TeachingCredentialBasis'), namespace_))
    def hasContent_(self):
        if (
            self.CredentialType is not None or
            self.Field is not None or
            self.Level is not None or
            self.TeachingCredentialType is not None or
            self.CredentialIssuanceDate is not None or
            self.CredentialExpirationDate is not None or
            self.TeachingCredentialBasis is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Credential'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CredentialType is not None:
            showIndent(outfile, level)
            outfile.write('CredentialType=%s,\n' % quote_python(self.CredentialType).encode(ExternalEncoding))
        if self.Field is not None:
            showIndent(outfile, level)
            outfile.write('Field=%s,\n' % quote_python(self.Field).encode(ExternalEncoding))
        if self.Level is not None:
            showIndent(outfile, level)
            outfile.write('Level=%s,\n' % quote_python(self.Level).encode(ExternalEncoding))
        if self.TeachingCredentialType is not None:
            showIndent(outfile, level)
            outfile.write('TeachingCredentialType=%s,\n' % quote_python(self.TeachingCredentialType).encode(ExternalEncoding))
        if self.CredentialIssuanceDate is not None:
            showIndent(outfile, level)
            outfile.write('CredentialIssuanceDate=%s,\n' % quote_python(self.CredentialIssuanceDate).encode(ExternalEncoding))
        if self.CredentialExpirationDate is not None:
            showIndent(outfile, level)
            outfile.write('CredentialExpirationDate=%s,\n' % quote_python(self.CredentialExpirationDate).encode(ExternalEncoding))
        if self.TeachingCredentialBasis is not None:
            showIndent(outfile, level)
            outfile.write('TeachingCredentialBasis=%s,\n' % quote_python(self.TeachingCredentialBasis).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CredentialType':
            CredentialType_ = child_.text
            CredentialType_ = re_.sub(String_cleanup_pat_, " ", CredentialType_).strip()
            CredentialType_ = self.gds_validate_string(CredentialType_, node, 'CredentialType')
            self.CredentialType = CredentialType_
            self.validate_CredentialType(self.CredentialType)    # validate type CredentialType
        elif nodeName_ == 'Field':
            Field_ = child_.text
            Field_ = re_.sub(String_cleanup_pat_, " ", Field_).strip()
            Field_ = self.gds_validate_string(Field_, node, 'Field')
            self.Field = Field_
            self.validate_FieldType(self.Field)    # validate type FieldType
        elif nodeName_ == 'Level':
            Level_ = child_.text
            Level_ = re_.sub(String_cleanup_pat_, " ", Level_).strip()
            Level_ = self.gds_validate_string(Level_, node, 'Level')
            self.Level = Level_
            self.validate_LevelType(self.Level)    # validate type LevelType
        elif nodeName_ == 'TeachingCredentialType':
            TeachingCredentialType_ = child_.text
            TeachingCredentialType_ = re_.sub(String_cleanup_pat_, " ", TeachingCredentialType_).strip()
            TeachingCredentialType_ = self.gds_validate_string(TeachingCredentialType_, node, 'TeachingCredentialType')
            self.TeachingCredentialType = TeachingCredentialType_
            self.validate_TeachingCredentialType(self.TeachingCredentialType)    # validate type TeachingCredentialType
        elif nodeName_ == 'CredentialIssuanceDate':
            CredentialIssuanceDate_ = child_.text
            CredentialIssuanceDate_ = self.gds_validate_string(CredentialIssuanceDate_, node, 'CredentialIssuanceDate')
            self.CredentialIssuanceDate = CredentialIssuanceDate_
        elif nodeName_ == 'CredentialExpirationDate':
            CredentialExpirationDate_ = child_.text
            CredentialExpirationDate_ = self.gds_validate_string(CredentialExpirationDate_, node, 'CredentialExpirationDate')
            self.CredentialExpirationDate = CredentialExpirationDate_
        elif nodeName_ == 'TeachingCredentialBasis':
            TeachingCredentialBasis_ = child_.text
            TeachingCredentialBasis_ = re_.sub(String_cleanup_pat_, " ", TeachingCredentialBasis_).strip()
            TeachingCredentialBasis_ = self.gds_validate_string(TeachingCredentialBasis_, node, 'TeachingCredentialBasis')
            self.TeachingCredentialBasis = TeachingCredentialBasis_
            self.validate_TeachingCredentialBasisType(self.TeachingCredentialBasis)    # validate type TeachingCredentialBasisType
# end class Credential


class Credits(GeneratedsSuper):
    """Credits or units of value awarded for the completion of a courseThe
    type of credits or units of value awarded for the completion of
    a course"""
    subclass = None
    superclass = None
    def __init__(self, CreditType=None, Credit=None):
        self.CreditType = _cast(None, CreditType)
        self.Credit = Credit
    def factory(*args_, **kwargs_):
        if Credits.subclass:
            return Credits.subclass(*args_, **kwargs_)
        else:
            return Credits(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Credit(self): return self.Credit
    def set_Credit(self, Credit): self.Credit = Credit
    def get_CreditType(self): return self.CreditType
    def set_CreditType(self, CreditType): self.CreditType = CreditType
    def validate_CreditType(self, value):
        # Validate type CreditType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='Credits', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Credits')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Credits'):
        if self.CreditType is not None and 'CreditType' not in already_processed:
            already_processed.append('CreditType')
            outfile.write(' CreditType=%s' % (quote_attrib(self.CreditType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Credits', fromsubclass_=False):
        if self.Credit is not None:
            showIndent(outfile, level)
            outfile.write('<%sCredit>%s</%sCredit>\n' % (namespace_, self.gds_format_float(self.Credit, input_name='Credit'), namespace_))
    def hasContent_(self):
        if (
            self.Credit is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Credits'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.CreditType is not None and 'CreditType' not in already_processed:
            already_processed.append('CreditType')
            showIndent(outfile, level)
            outfile.write('CreditType = "%s",\n' % (self.CreditType,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Credit is not None:
            showIndent(outfile, level)
            outfile.write('Credit=%f,\n' % self.Credit)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('CreditType', node)
        if value is not None and 'CreditType' not in already_processed:
            already_processed.append('CreditType')
            self.CreditType = value
            self.CreditType = ' '.join(self.CreditType.split())
            self.validate_CreditType(self.CreditType)    # validate type CreditType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Credit':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Credit')
            self.Credit = fval_
# end class Credits


class Disability(GeneratedsSuper):
    """This type represents an impairment of body structure or function, a
    limitation in activities, or a restriction in participation, as
    ordered by severity of impairment."""
    subclass = None
    superclass = None
    def __init__(self, Disability=None, DisabilityDiagnosis=None, OrderOfDisability=None):
        self.Disability = Disability
        self.DisabilityDiagnosis = DisabilityDiagnosis
        self.OrderOfDisability = OrderOfDisability
    def factory(*args_, **kwargs_):
        if Disability.subclass:
            return Disability.subclass(*args_, **kwargs_)
        else:
            return Disability(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Disability(self): return self.Disability
    def set_Disability(self, Disability): self.Disability = Disability
    def validate_DisabilityType(self, value):
        # Validate type DisabilityType, a restriction on xs:token.
        pass
    def get_DisabilityDiagnosis(self): return self.DisabilityDiagnosis
    def set_DisabilityDiagnosis(self, DisabilityDiagnosis): self.DisabilityDiagnosis = DisabilityDiagnosis
    def validate_DisabilityDiagnosis(self, value):
        # Validate type DisabilityDiagnosis, a restriction on xs:string.
        pass
    def get_OrderOfDisability(self): return self.OrderOfDisability
    def set_OrderOfDisability(self, OrderOfDisability): self.OrderOfDisability = OrderOfDisability
    def export(self, outfile, level, namespace_='', name_='Disability', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Disability')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Disability'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Disability', fromsubclass_=False):
        if self.Disability is not None:
            showIndent(outfile, level)
            outfile.write('<%sDisability>%s</%sDisability>\n' % (namespace_, self.gds_format_string(quote_xml(self.Disability).encode(ExternalEncoding), input_name='Disability'), namespace_))
        if self.DisabilityDiagnosis is not None:
            showIndent(outfile, level)
            outfile.write('<%sDisabilityDiagnosis>%s</%sDisabilityDiagnosis>\n' % (namespace_, self.gds_format_string(quote_xml(self.DisabilityDiagnosis).encode(ExternalEncoding), input_name='DisabilityDiagnosis'), namespace_))
        if self.OrderOfDisability is not None:
            showIndent(outfile, level)
            outfile.write('<%sOrderOfDisability>%s</%sOrderOfDisability>\n' % (namespace_, self.gds_format_integer(self.OrderOfDisability, input_name='OrderOfDisability'), namespace_))
    def hasContent_(self):
        if (
            self.Disability is not None or
            self.DisabilityDiagnosis is not None or
            self.OrderOfDisability is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Disability'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Disability is not None:
            showIndent(outfile, level)
            outfile.write('Disability=%s,\n' % quote_python(self.Disability).encode(ExternalEncoding))
        if self.DisabilityDiagnosis is not None:
            showIndent(outfile, level)
            outfile.write('DisabilityDiagnosis=%s,\n' % quote_python(self.DisabilityDiagnosis).encode(ExternalEncoding))
        if self.OrderOfDisability is not None:
            showIndent(outfile, level)
            outfile.write('OrderOfDisability=%d,\n' % self.OrderOfDisability)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Disability':
            Disability_ = child_.text
            Disability_ = re_.sub(String_cleanup_pat_, " ", Disability_).strip()
            Disability_ = self.gds_validate_string(Disability_, node, 'Disability')
            self.Disability = Disability_
            self.validate_DisabilityType(self.Disability)    # validate type DisabilityType
        elif nodeName_ == 'DisabilityDiagnosis':
            DisabilityDiagnosis_ = child_.text
            DisabilityDiagnosis_ = self.gds_validate_string(DisabilityDiagnosis_, node, 'DisabilityDiagnosis')
            self.DisabilityDiagnosis = DisabilityDiagnosis_
            self.validate_DisabilityDiagnosis(self.DisabilityDiagnosis)    # validate type DisabilityDiagnosis
        elif nodeName_ == 'OrderOfDisability':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OrderOfDisability')
            self.OrderOfDisability = ival_
# end class Disability


class EducationOrgIdentificationCode(GeneratedsSuper):
    """A unique number or alphanumeric code that is assigned to an
    education organization by a school, school system, a state, or
    other agency or entity."""
    subclass = None
    superclass = None
    def __init__(self, IdentificationSystem=None, ID=None):
        self.IdentificationSystem = _cast(None, IdentificationSystem)
        self.ID = ID
    def factory(*args_, **kwargs_):
        if EducationOrgIdentificationCode.subclass:
            return EducationOrgIdentificationCode.subclass(*args_, **kwargs_)
        else:
            return EducationOrgIdentificationCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_IdentificationCode(self, value):
        # Validate type IdentificationCode, a restriction on xs:string.
        pass
    def get_IdentificationSystem(self): return self.IdentificationSystem
    def set_IdentificationSystem(self, IdentificationSystem): self.IdentificationSystem = IdentificationSystem
    def validate_EducationOrgIdentificationSystemType(self, value):
        # Validate type EducationOrgIdentificationSystemType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='EducationOrgIdentificationCode', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EducationOrgIdentificationCode')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EducationOrgIdentificationCode'):
        if self.IdentificationSystem is not None and 'IdentificationSystem' not in already_processed:
            already_processed.append('IdentificationSystem')
            outfile.write(' IdentificationSystem=%s' % (quote_attrib(self.IdentificationSystem), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EducationOrgIdentificationCode', fromsubclass_=False):
        if self.ID is not None:
            showIndent(outfile, level)
            outfile.write('<%sID>%s</%sID>\n' % (namespace_, self.gds_format_string(quote_xml(self.ID).encode(ExternalEncoding), input_name='ID'), namespace_))
    def hasContent_(self):
        if (
            self.ID is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EducationOrgIdentificationCode'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.IdentificationSystem is not None and 'IdentificationSystem' not in already_processed:
            already_processed.append('IdentificationSystem')
            showIndent(outfile, level)
            outfile.write('IdentificationSystem = "%s",\n' % (self.IdentificationSystem,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ID is not None:
            showIndent(outfile, level)
            outfile.write('ID=%s,\n' % quote_python(self.ID).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IdentificationSystem', node)
        if value is not None and 'IdentificationSystem' not in already_processed:
            already_processed.append('IdentificationSystem')
            self.IdentificationSystem = value
            self.IdentificationSystem = ' '.join(self.IdentificationSystem.split())
            self.validate_EducationOrgIdentificationSystemType(self.IdentificationSystem)    # validate type EducationOrgIdentificationSystemType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
            self.validate_IdentificationCode(self.ID)    # validate type IdentificationCode
# end class EducationOrgIdentificationCode


class ElectronicMail(GeneratedsSuper):
    """The numbers, letters, and symbols used to identify an electronic
    mail (e-mail) user within the network to which the individual or
    organization belongs.The type of email listed for an individual
    or organization. For example: Home/Personal, Work, etc.)"""
    subclass = None
    superclass = None
    def __init__(self, EmailAddressType=None, EmailAddress=None):
        self.EmailAddressType = _cast(None, EmailAddressType)
        self.EmailAddress = EmailAddress
    def factory(*args_, **kwargs_):
        if ElectronicMail.subclass:
            return ElectronicMail.subclass(*args_, **kwargs_)
        else:
            return ElectronicMail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EmailAddress(self): return self.EmailAddress
    def set_EmailAddress(self, EmailAddress): self.EmailAddress = EmailAddress
    def validate_ElectronicMailAddress(self, value):
        # Validate type ElectronicMailAddress, a restriction on xs:string.
        pass
    def get_EmailAddressType(self): return self.EmailAddressType
    def set_EmailAddressType(self, EmailAddressType): self.EmailAddressType = EmailAddressType
    def validate_ElectronicMailAddressType(self, value):
        # Validate type ElectronicMailAddressType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='ElectronicMail', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectronicMail')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ElectronicMail'):
        if self.EmailAddressType is not None and 'EmailAddressType' not in already_processed:
            already_processed.append('EmailAddressType')
            outfile.write(' EmailAddressType=%s' % (quote_attrib(self.EmailAddressType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ElectronicMail', fromsubclass_=False):
        if self.EmailAddress is not None:
            showIndent(outfile, level)
            outfile.write('<%sEmailAddress>%s</%sEmailAddress>\n' % (namespace_, self.gds_format_string(quote_xml(self.EmailAddress).encode(ExternalEncoding), input_name='EmailAddress'), namespace_))
    def hasContent_(self):
        if (
            self.EmailAddress is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ElectronicMail'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.EmailAddressType is not None and 'EmailAddressType' not in already_processed:
            already_processed.append('EmailAddressType')
            showIndent(outfile, level)
            outfile.write('EmailAddressType = "%s",\n' % (self.EmailAddressType,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.EmailAddress is not None:
            showIndent(outfile, level)
            outfile.write('EmailAddress=%s,\n' % quote_python(self.EmailAddress).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('EmailAddressType', node)
        if value is not None and 'EmailAddressType' not in already_processed:
            already_processed.append('EmailAddressType')
            self.EmailAddressType = value
            self.EmailAddressType = ' '.join(self.EmailAddressType.split())
            self.validate_ElectronicMailAddressType(self.EmailAddressType)    # validate type ElectronicMailAddressType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EmailAddress':
            EmailAddress_ = child_.text
            EmailAddress_ = self.gds_validate_string(EmailAddress_, node, 'EmailAddress')
            self.EmailAddress = EmailAddress_
            self.validate_ElectronicMailAddress(self.EmailAddress)    # validate type ElectronicMailAddress
# end class ElectronicMail


class EmploymentPeriod(GeneratedsSuper):
    """The set of elements defining and characterizing a person's period of
    employment including start and end dates and the type and reason
    for separation."""
    subclass = None
    superclass = None
    def __init__(self, HireDate=None, EndDate=None, Separation=None, SeparationReason=None):
        self.HireDate = HireDate
        self.EndDate = EndDate
        self.Separation = Separation
        self.SeparationReason = SeparationReason
    def factory(*args_, **kwargs_):
        if EmploymentPeriod.subclass:
            return EmploymentPeriod.subclass(*args_, **kwargs_)
        else:
            return EmploymentPeriod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HireDate(self): return self.HireDate
    def set_HireDate(self, HireDate): self.HireDate = HireDate
    def get_EndDate(self): return self.EndDate
    def set_EndDate(self, EndDate): self.EndDate = EndDate
    def get_Separation(self): return self.Separation
    def set_Separation(self, Separation): self.Separation = Separation
    def validate_SeparationType(self, value):
        # Validate type SeparationType, a restriction on xs:token.
        pass
    def get_SeparationReason(self): return self.SeparationReason
    def set_SeparationReason(self, SeparationReason): self.SeparationReason = SeparationReason
    def validate_SeparationReasonType(self, value):
        # Validate type SeparationReasonType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='EmploymentPeriod', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EmploymentPeriod')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EmploymentPeriod'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EmploymentPeriod', fromsubclass_=False):
        if self.HireDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sHireDate>%s</%sHireDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.HireDate).encode(ExternalEncoding), input_name='HireDate'), namespace_))
        if self.EndDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sEndDate>%s</%sEndDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.EndDate).encode(ExternalEncoding), input_name='EndDate'), namespace_))
        if self.Separation is not None:
            showIndent(outfile, level)
            outfile.write('<%sSeparation>%s</%sSeparation>\n' % (namespace_, self.gds_format_string(quote_xml(self.Separation).encode(ExternalEncoding), input_name='Separation'), namespace_))
        if self.SeparationReason is not None:
            showIndent(outfile, level)
            outfile.write('<%sSeparationReason>%s</%sSeparationReason>\n' % (namespace_, self.gds_format_string(quote_xml(self.SeparationReason).encode(ExternalEncoding), input_name='SeparationReason'), namespace_))
    def hasContent_(self):
        if (
            self.HireDate is not None or
            self.EndDate is not None or
            self.Separation is not None or
            self.SeparationReason is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EmploymentPeriod'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.HireDate is not None:
            showIndent(outfile, level)
            outfile.write('HireDate=%s,\n' % quote_python(self.HireDate).encode(ExternalEncoding))
        if self.EndDate is not None:
            showIndent(outfile, level)
            outfile.write('EndDate=%s,\n' % quote_python(self.EndDate).encode(ExternalEncoding))
        if self.Separation is not None:
            showIndent(outfile, level)
            outfile.write('Separation=%s,\n' % quote_python(self.Separation).encode(ExternalEncoding))
        if self.SeparationReason is not None:
            showIndent(outfile, level)
            outfile.write('SeparationReason=%s,\n' % quote_python(self.SeparationReason).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HireDate':
            HireDate_ = child_.text
            HireDate_ = self.gds_validate_string(HireDate_, node, 'HireDate')
            self.HireDate = HireDate_
        elif nodeName_ == 'EndDate':
            EndDate_ = child_.text
            EndDate_ = self.gds_validate_string(EndDate_, node, 'EndDate')
            self.EndDate = EndDate_
        elif nodeName_ == 'Separation':
            Separation_ = child_.text
            Separation_ = re_.sub(String_cleanup_pat_, " ", Separation_).strip()
            Separation_ = self.gds_validate_string(Separation_, node, 'Separation')
            self.Separation = Separation_
            self.validate_SeparationType(self.Separation)    # validate type SeparationType
        elif nodeName_ == 'SeparationReason':
            SeparationReason_ = child_.text
            SeparationReason_ = re_.sub(String_cleanup_pat_, " ", SeparationReason_).strip()
            SeparationReason_ = self.gds_validate_string(SeparationReason_, node, 'SeparationReason')
            self.SeparationReason = SeparationReason_
            self.validate_SeparationReasonType(self.SeparationReason)    # validate type SeparationReasonType
# end class EmploymentPeriod


class GradePointAverage(GeneratedsSuper):
    """Grade Point Average computed for a gradng period or cumulatively."""
    subclass = None
    superclass = None
    def __init__(self, GPAWeighted=None, GPA=None):
        self.GPAWeighted = _cast(None, GPAWeighted)
        self.GPA = GPA
    def factory(*args_, **kwargs_):
        if GradePointAverage.subclass:
            return GradePointAverage.subclass(*args_, **kwargs_)
        else:
            return GradePointAverage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GPA(self): return self.GPA
    def set_GPA(self, GPA): self.GPA = GPA
    def get_GPAWeighted(self): return self.GPAWeighted
    def set_GPAWeighted(self, GPAWeighted): self.GPAWeighted = GPAWeighted
    def validate_GPAWeightedType(self, value):
        # Validate type GPAWeightedType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='GradePointAverage', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GradePointAverage')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GradePointAverage'):
        if self.GPAWeighted is not None and 'GPAWeighted' not in already_processed:
            already_processed.append('GPAWeighted')
            outfile.write(' GPAWeighted=%s' % (quote_attrib(self.GPAWeighted), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GradePointAverage', fromsubclass_=False):
        if self.GPA is not None:
            showIndent(outfile, level)
            outfile.write('<%sGPA>%s</%sGPA>\n' % (namespace_, self.gds_format_float(self.GPA, input_name='GPA'), namespace_))
    def hasContent_(self):
        if (
            self.GPA is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GradePointAverage'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.GPAWeighted is not None and 'GPAWeighted' not in already_processed:
            already_processed.append('GPAWeighted')
            showIndent(outfile, level)
            outfile.write('GPAWeighted = "%s",\n' % (self.GPAWeighted,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.GPA is not None:
            showIndent(outfile, level)
            outfile.write('GPA=%f,\n' % self.GPA)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('GPAWeighted', node)
        if value is not None and 'GPAWeighted' not in already_processed:
            already_processed.append('GPAWeighted')
            self.GPAWeighted = value
            self.GPAWeighted = ' '.join(self.GPAWeighted.split())
            self.validate_GPAWeightedType(self.GPAWeighted)    # validate type GPAWeightedType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GPA':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'GPA')
            self.GPA = fval_
# end class GradePointAverage


class GPA(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if GPA.subclass:
            return GPA.subclass(*args_, **kwargs_)
        else:
            return GPA(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='GPA', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GPA')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GPA'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GPA', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GPA'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class GPA


class IncidentBehavior(GeneratedsSuper):
    """Definition of the behavior coded for use in describing an
    incident.The category of the incident behavior for
    classification purposes"""
    subclass = None
    superclass = None
    def __init__(self, IncidentCategory=None, Behavior=None):
        self.IncidentCategory = _cast(None, IncidentCategory)
        self.Behavior = Behavior
    def factory(*args_, **kwargs_):
        if IncidentBehavior.subclass:
            return IncidentBehavior.subclass(*args_, **kwargs_)
        else:
            return IncidentBehavior(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Behavior(self): return self.Behavior
    def set_Behavior(self, Behavior): self.Behavior = Behavior
    def validate_IncidentBehaviorType(self, value):
        # Validate type IncidentBehaviorType, a restriction on xs:token.
        pass
    def get_IncidentCategory(self): return self.IncidentCategory
    def set_IncidentCategory(self, IncidentCategory): self.IncidentCategory = IncidentCategory
    def validate_IncidentCategoryType(self, value):
        # Validate type IncidentCategoryType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='IncidentBehavior', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IncidentBehavior')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IncidentBehavior'):
        if self.IncidentCategory is not None and 'IncidentCategory' not in already_processed:
            already_processed.append('IncidentCategory')
            outfile.write(' IncidentCategory=%s' % (quote_attrib(self.IncidentCategory), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IncidentBehavior', fromsubclass_=False):
        if self.Behavior is not None:
            showIndent(outfile, level)
            outfile.write('<%sBehavior>%s</%sBehavior>\n' % (namespace_, self.gds_format_string(quote_xml(self.Behavior).encode(ExternalEncoding), input_name='Behavior'), namespace_))
    def hasContent_(self):
        if (
            self.Behavior is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IncidentBehavior'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.IncidentCategory is not None and 'IncidentCategory' not in already_processed:
            already_processed.append('IncidentCategory')
            showIndent(outfile, level)
            outfile.write('IncidentCategory = "%s",\n' % (self.IncidentCategory,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Behavior is not None:
            showIndent(outfile, level)
            outfile.write('Behavior=%s,\n' % quote_python(self.Behavior).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IncidentCategory', node)
        if value is not None and 'IncidentCategory' not in already_processed:
            already_processed.append('IncidentCategory')
            self.IncidentCategory = value
            self.IncidentCategory = ' '.join(self.IncidentCategory.split())
            self.validate_IncidentCategoryType(self.IncidentCategory)    # validate type IncidentCategoryType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Behavior':
            Behavior_ = child_.text
            Behavior_ = re_.sub(String_cleanup_pat_, " ", Behavior_).strip()
            Behavior_ = self.gds_validate_string(Behavior_, node, 'Behavior')
            self.Behavior = Behavior_
            self.validate_IncidentBehaviorType(self.Behavior)    # validate type IncidentBehaviorType
# end class IncidentBehavior


class InstitutionTelephone(GeneratedsSuper):
    """The 10-digit telephone number, including the area code, for the
    organizationThe type of communication number listed for an
    individual or organization."""
    subclass = None
    superclass = None
    def __init__(self, InstitutionTelephoneNumberType=None, TelephoneNumber=None):
        self.InstitutionTelephoneNumberType = _cast(None, InstitutionTelephoneNumberType)
        self.TelephoneNumber = TelephoneNumber
    def factory(*args_, **kwargs_):
        if InstitutionTelephone.subclass:
            return InstitutionTelephone.subclass(*args_, **kwargs_)
        else:
            return InstitutionTelephone(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TelephoneNumber(self): return self.TelephoneNumber
    def set_TelephoneNumber(self, TelephoneNumber): self.TelephoneNumber = TelephoneNumber
    def validate_TelephoneNumber(self, value):
        # Validate type TelephoneNumber, a restriction on xs:string.
        pass
    def get_InstitutionTelephoneNumberType(self): return self.InstitutionTelephoneNumberType
    def set_InstitutionTelephoneNumberType(self, InstitutionTelephoneNumberType): self.InstitutionTelephoneNumberType = InstitutionTelephoneNumberType
    def validate_InstitutionTelephoneNumberType(self, value):
        # Validate type InstitutionTelephoneNumberType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='InstitutionTelephone', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstitutionTelephone')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InstitutionTelephone'):
        if self.InstitutionTelephoneNumberType is not None and 'InstitutionTelephoneNumberType' not in already_processed:
            already_processed.append('InstitutionTelephoneNumberType')
            outfile.write(' InstitutionTelephoneNumberType=%s' % (quote_attrib(self.InstitutionTelephoneNumberType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='InstitutionTelephone', fromsubclass_=False):
        if self.TelephoneNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sTelephoneNumber>%s</%sTelephoneNumber>\n' % (namespace_, self.gds_format_string(quote_xml(self.TelephoneNumber).encode(ExternalEncoding), input_name='TelephoneNumber'), namespace_))
    def hasContent_(self):
        if (
            self.TelephoneNumber is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='InstitutionTelephone'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.InstitutionTelephoneNumberType is not None and 'InstitutionTelephoneNumberType' not in already_processed:
            already_processed.append('InstitutionTelephoneNumberType')
            showIndent(outfile, level)
            outfile.write('InstitutionTelephoneNumberType = "%s",\n' % (self.InstitutionTelephoneNumberType,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TelephoneNumber is not None:
            showIndent(outfile, level)
            outfile.write('TelephoneNumber=%s,\n' % quote_python(self.TelephoneNumber).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('InstitutionTelephoneNumberType', node)
        if value is not None and 'InstitutionTelephoneNumberType' not in already_processed:
            already_processed.append('InstitutionTelephoneNumberType')
            self.InstitutionTelephoneNumberType = value
            self.InstitutionTelephoneNumberType = ' '.join(self.InstitutionTelephoneNumberType.split())
            self.validate_InstitutionTelephoneNumberType(self.InstitutionTelephoneNumberType)    # validate type InstitutionTelephoneNumberType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TelephoneNumber':
            TelephoneNumber_ = child_.text
            TelephoneNumber_ = self.gds_validate_string(TelephoneNumber_, node, 'TelephoneNumber')
            self.TelephoneNumber = TelephoneNumber_
            self.validate_TelephoneNumber(self.TelephoneNumber)    # validate type TelephoneNumber
# end class InstitutionTelephone


class LearningStyles(GeneratedsSuper):
    """The student's relative preference to visual, auditory and tactile
    learning expressed as percentages."""
    subclass = None
    superclass = None
    def __init__(self, VisualLearning=None, AuditoryLearning=None, TactileLearning=None):
        self.VisualLearning = VisualLearning
        self.AuditoryLearning = AuditoryLearning
        self.TactileLearning = TactileLearning
    def factory(*args_, **kwargs_):
        if LearningStyles.subclass:
            return LearningStyles.subclass(*args_, **kwargs_)
        else:
            return LearningStyles(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VisualLearning(self): return self.VisualLearning
    def set_VisualLearning(self, VisualLearning): self.VisualLearning = VisualLearning
    def validate_percent(self, value):
        # Validate type percent, a restriction on xs:int.
        pass
    def get_AuditoryLearning(self): return self.AuditoryLearning
    def set_AuditoryLearning(self, AuditoryLearning): self.AuditoryLearning = AuditoryLearning
    def get_TactileLearning(self): return self.TactileLearning
    def set_TactileLearning(self, TactileLearning): self.TactileLearning = TactileLearning
    def export(self, outfile, level, namespace_='', name_='LearningStyles', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LearningStyles')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LearningStyles'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LearningStyles', fromsubclass_=False):
        if self.VisualLearning is not None:
            showIndent(outfile, level)
            outfile.write('<%sVisualLearning>%s</%sVisualLearning>\n' % (namespace_, self.gds_format_integer(self.VisualLearning, input_name='VisualLearning'), namespace_))
        if self.AuditoryLearning is not None:
            showIndent(outfile, level)
            outfile.write('<%sAuditoryLearning>%s</%sAuditoryLearning>\n' % (namespace_, self.gds_format_integer(self.AuditoryLearning, input_name='AuditoryLearning'), namespace_))
        if self.TactileLearning is not None:
            showIndent(outfile, level)
            outfile.write('<%sTactileLearning>%s</%sTactileLearning>\n' % (namespace_, self.gds_format_integer(self.TactileLearning, input_name='TactileLearning'), namespace_))
    def hasContent_(self):
        if (
            self.VisualLearning is not None or
            self.AuditoryLearning is not None or
            self.TactileLearning is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LearningStyles'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.VisualLearning is not None:
            showIndent(outfile, level)
            outfile.write('VisualLearning=%d,\n' % self.VisualLearning)
        if self.AuditoryLearning is not None:
            showIndent(outfile, level)
            outfile.write('AuditoryLearning=%d,\n' % self.AuditoryLearning)
        if self.TactileLearning is not None:
            showIndent(outfile, level)
            outfile.write('TactileLearning=%d,\n' % self.TactileLearning)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VisualLearning':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'VisualLearning')
            self.VisualLearning = ival_
            self.validate_percent(self.VisualLearning)    # validate type percent
        elif nodeName_ == 'AuditoryLearning':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'AuditoryLearning')
            self.AuditoryLearning = ival_
            self.validate_percent(self.AuditoryLearning)    # validate type percent
        elif nodeName_ == 'TactileLearning':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TactileLearning')
            self.TactileLearning = ival_
            self.validate_percent(self.TactileLearning)    # validate type percent
# end class LearningStyles


class MeetingTime(GeneratedsSuper):
    """The set of elements defining the meeting time for a class period."""
    subclass = None
    superclass = None
    def __init__(self, WeekNumber=None, MeetingDays=None, AlternateDayName=None, StartTime=None, EndTime=None, OfficialAttendancePeriod=None):
        self.WeekNumber = WeekNumber
        self.MeetingDays = MeetingDays
        self.AlternateDayName = AlternateDayName
        self.StartTime = StartTime
        self.EndTime = EndTime
        self.OfficialAttendancePeriod = OfficialAttendancePeriod
    def factory(*args_, **kwargs_):
        if MeetingTime.subclass:
            return MeetingTime.subclass(*args_, **kwargs_)
        else:
            return MeetingTime(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WeekNumber(self): return self.WeekNumber
    def set_WeekNumber(self, WeekNumber): self.WeekNumber = WeekNumber
    def get_MeetingDays(self): return self.MeetingDays
    def set_MeetingDays(self, MeetingDays): self.MeetingDays = MeetingDays
    def get_AlternateDayName(self): return self.AlternateDayName
    def set_AlternateDayName(self, AlternateDayName): self.AlternateDayName = AlternateDayName
    def validate_AlternateDayName(self, value):
        # Validate type AlternateDayName, a restriction on xs:string.
        pass
    def get_StartTime(self): return self.StartTime
    def set_StartTime(self, StartTime): self.StartTime = StartTime
    def get_EndTime(self): return self.EndTime
    def set_EndTime(self, EndTime): self.EndTime = EndTime
    def get_OfficialAttendancePeriod(self): return self.OfficialAttendancePeriod
    def set_OfficialAttendancePeriod(self, OfficialAttendancePeriod): self.OfficialAttendancePeriod = OfficialAttendancePeriod
    def export(self, outfile, level, namespace_='', name_='MeetingTime', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeetingTime')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MeetingTime'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MeetingTime', fromsubclass_=False):
        if self.WeekNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sWeekNumber>%s</%sWeekNumber>\n' % (namespace_, self.gds_format_integer(self.WeekNumber, input_name='WeekNumber'), namespace_))
        if self.MeetingDays:
            self.MeetingDays.export(outfile, level, namespace_, name_='MeetingDays', )
        if self.AlternateDayName is not None:
            showIndent(outfile, level)
            outfile.write('<%sAlternateDayName>%s</%sAlternateDayName>\n' % (namespace_, self.gds_format_string(quote_xml(self.AlternateDayName).encode(ExternalEncoding), input_name='AlternateDayName'), namespace_))
        if self.StartTime:
            self.StartTime.export(outfile, level, namespace_, name_='StartTime', )
        if self.EndTime:
            self.EndTime.export(outfile, level, namespace_, name_='EndTime', )
        if self.OfficialAttendancePeriod is not None:
            showIndent(outfile, level)
            outfile.write('<%sOfficialAttendancePeriod>%s</%sOfficialAttendancePeriod>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.OfficialAttendancePeriod)), input_name='OfficialAttendancePeriod'), namespace_))
    def hasContent_(self):
        if (
            self.WeekNumber is not None or
            self.MeetingDays is not None or
            self.AlternateDayName is not None or
            self.StartTime is not None or
            self.EndTime is not None or
            self.OfficialAttendancePeriod is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MeetingTime'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.WeekNumber is not None:
            showIndent(outfile, level)
            outfile.write('WeekNumber=%d,\n' % self.WeekNumber)
        if self.MeetingDays is not None:
            showIndent(outfile, level)
            outfile.write('MeetingDays=model_.MeetingDaysType(\n')
            self.MeetingDays.exportLiteral(outfile, level, name_='MeetingDays')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AlternateDayName is not None:
            showIndent(outfile, level)
            outfile.write('AlternateDayName=%s,\n' % quote_python(self.AlternateDayName).encode(ExternalEncoding))
        if self.StartTime is not None:
            showIndent(outfile, level)
            outfile.write('StartTime=model_.xs_time(\n')
            self.StartTime.exportLiteral(outfile, level, name_='StartTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.EndTime is not None:
            showIndent(outfile, level)
            outfile.write('EndTime=model_.xs_time(\n')
            self.EndTime.exportLiteral(outfile, level, name_='EndTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OfficialAttendancePeriod is not None:
            showIndent(outfile, level)
            outfile.write('OfficialAttendancePeriod=%s,\n' % self.OfficialAttendancePeriod)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WeekNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'WeekNumber')
            self.WeekNumber = ival_
        elif nodeName_ == 'MeetingDays':
            obj_ = MeetingDaysType.factory()
            obj_.build(child_)
            self.set_MeetingDays(obj_)
        elif nodeName_ == 'AlternateDayName':
            AlternateDayName_ = child_.text
            AlternateDayName_ = self.gds_validate_string(AlternateDayName_, node, 'AlternateDayName')
            self.AlternateDayName = AlternateDayName_
            self.validate_AlternateDayName(self.AlternateDayName)    # validate type AlternateDayName
        elif nodeName_ == 'StartTime':
            obj_ = xs_time.factory()
            obj_.build(child_)
            self.set_StartTime(obj_)
        elif nodeName_ == 'EndTime':
            obj_ = xs_time.factory()
            obj_.build(child_)
            self.set_EndTime(obj_)
        elif nodeName_ == 'OfficialAttendancePeriod':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'OfficialAttendancePeriod')
            self.OfficialAttendancePeriod = ival_
# end class MeetingTime


class WeekNumber(GeneratedsSuper):
    """The week number (out of the number of weeks in the cycle) for this
    meeting time."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if WeekNumber.subclass:
            return WeekNumber.subclass(*args_, **kwargs_)
        else:
            return WeekNumber(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='WeekNumber', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WeekNumber')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WeekNumber'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='WeekNumber', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='WeekNumber'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WeekNumber


class Name(GeneratedsSuper):
    """The set of elements that comprise a person's legal name."""
    subclass = None
    superclass = None
    def __init__(self, Verification=None, PersonalTitlePrefix=None, FirstName=None, MiddleName=None, LastSurname=None, GenerationCodeSuffix=None, MaidenName=None):
        self.Verification = _cast(None, Verification)
        self.PersonalTitlePrefix = PersonalTitlePrefix
        self.FirstName = FirstName
        self.MiddleName = MiddleName
        self.LastSurname = LastSurname
        self.GenerationCodeSuffix = GenerationCodeSuffix
        self.MaidenName = MaidenName
        #self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Name.subclass:
            return Name.subclass(*args_, **kwargs_)
        else:
            return Name(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PersonalTitlePrefix(self): return self.PersonalTitlePrefix
    def set_PersonalTitlePrefix(self, PersonalTitlePrefix): self.PersonalTitlePrefix = PersonalTitlePrefix
    def validate_PersonalTitlePrefixType(self, value):
        # Validate type PersonalTitlePrefixType, a restriction on xs:token.
        pass
    def get_FirstName(self): return self.FirstName
    def set_FirstName(self, FirstName): self.FirstName = FirstName
    def validate_FirstName(self, value):
        # Validate type FirstName, a restriction on xs:string.
        pass
    def get_MiddleName(self): return self.MiddleName
    def set_MiddleName(self, MiddleName): self.MiddleName = MiddleName
    def validate_MiddleName(self, value):
        # Validate type MiddleName, a restriction on xs:string.
        pass
    def get_LastSurname(self): return self.LastSurname
    def set_LastSurname(self, LastSurname): self.LastSurname = LastSurname
    def validate_LastSurname(self, value):
        # Validate type LastSurname, a restriction on xs:string.
        pass
    def get_GenerationCodeSuffix(self): return self.GenerationCodeSuffix
    def set_GenerationCodeSuffix(self, GenerationCodeSuffix): self.GenerationCodeSuffix = GenerationCodeSuffix
    def validate_GenerationCodeSuffixType(self, value):
        # Validate type GenerationCodeSuffixType, a restriction on xs:token.
        pass
    def get_MaidenName(self): return self.MaidenName
    def set_MaidenName(self, MaidenName): self.MaidenName = MaidenName
    def get_Verification(self): return self.Verification
    def set_Verification(self, Verification): self.Verification = Verification
    def validate_PersonalInformationVerificationType(self, value):
        # Validate type PersonalInformationVerificationType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='Name', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Name')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Name'):
        if self.Verification is not None and 'Verification' not in already_processed:
            already_processed.append('Verification')
            outfile.write(' Verification=%s' % (quote_attrib(self.Verification), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Name', fromsubclass_=False):
        if self.PersonalTitlePrefix is not None:
            showIndent(outfile, level)
            outfile.write('<%sPersonalTitlePrefix>%s</%sPersonalTitlePrefix>\n' % (namespace_, self.gds_format_string(quote_xml(self.PersonalTitlePrefix).encode(ExternalEncoding), input_name='PersonalTitlePrefix'), namespace_))
        if self.FirstName is not None:
            showIndent(outfile, level)
            outfile.write('<%sFirstName>%s</%sFirstName>\n' % (namespace_, self.gds_format_string(quote_xml(self.FirstName).encode(ExternalEncoding), input_name='FirstName'), namespace_))
        if self.MiddleName is not None:
            showIndent(outfile, level)
            outfile.write('<%sMiddleName>%s</%sMiddleName>\n' % (namespace_, self.gds_format_string(quote_xml(self.MiddleName).encode(ExternalEncoding), input_name='MiddleName'), namespace_))
        if self.LastSurname is not None:
            showIndent(outfile, level)
            outfile.write('<%sLastSurname>%s</%sLastSurname>\n' % (namespace_, self.gds_format_string(quote_xml(self.LastSurname).encode(ExternalEncoding), input_name='LastSurname'), namespace_))
        if self.GenerationCodeSuffix is not None:
            showIndent(outfile, level)
            outfile.write('<%sGenerationCodeSuffix>%s</%sGenerationCodeSuffix>\n' % (namespace_, self.gds_format_string(quote_xml(self.GenerationCodeSuffix).encode(ExternalEncoding), input_name='GenerationCodeSuffix'), namespace_))
        if self.MaidenName is not None:
            showIndent(outfile, level)
            outfile.write('<%sMaidenName>%s</%sMaidenName>\n' % (namespace_, self.gds_format_string(quote_xml(self.MaidenName).encode(ExternalEncoding), input_name='MaidenName'), namespace_))
    def hasContent_(self):
        if (
            self.PersonalTitlePrefix is not None or
            self.FirstName is not None or
            self.MiddleName is not None or
            self.LastSurname is not None or
            self.GenerationCodeSuffix is not None or
            self.MaidenName is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Name'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Verification is not None and 'Verification' not in already_processed:
            already_processed.append('Verification')
            showIndent(outfile, level)
            outfile.write('Verification = "%s",\n' % (self.Verification,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PersonalTitlePrefix is not None:
            showIndent(outfile, level)
            outfile.write('PersonalTitlePrefix=%s,\n' % quote_python(self.PersonalTitlePrefix).encode(ExternalEncoding))
        if self.FirstName is not None:
            showIndent(outfile, level)
            outfile.write('FirstName=%s,\n' % quote_python(self.FirstName).encode(ExternalEncoding))
        if self.MiddleName is not None:
            showIndent(outfile, level)
            outfile.write('MiddleName=%s,\n' % quote_python(self.MiddleName).encode(ExternalEncoding))
        if self.LastSurname is not None:
            showIndent(outfile, level)
            outfile.write('LastSurname=%s,\n' % quote_python(self.LastSurname).encode(ExternalEncoding))
        if self.GenerationCodeSuffix is not None:
            showIndent(outfile, level)
            outfile.write('GenerationCodeSuffix=%s,\n' % quote_python(self.GenerationCodeSuffix).encode(ExternalEncoding))
        if self.MaidenName is not None:
            showIndent(outfile, level)
            outfile.write('MaidenName=%s,\n' % quote_python(self.MaidenName).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Verification', node)
        if value is not None and 'Verification' not in already_processed:
            already_processed.append('Verification')
            self.Verification = value
            self.Verification = ' '.join(self.Verification.split())
            self.validate_PersonalInformationVerificationType(self.Verification)    # validate type PersonalInformationVerificationType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PersonalTitlePrefix':
            PersonalTitlePrefix_ = child_.text
            PersonalTitlePrefix_ = re_.sub(String_cleanup_pat_, " ", PersonalTitlePrefix_).strip()
            PersonalTitlePrefix_ = self.gds_validate_string(PersonalTitlePrefix_, node, 'PersonalTitlePrefix')
            self.PersonalTitlePrefix = PersonalTitlePrefix_
            self.validate_PersonalTitlePrefixType(self.PersonalTitlePrefix)    # validate type PersonalTitlePrefixType
        elif nodeName_ == 'FirstName':
            FirstName_ = child_.text
            FirstName_ = self.gds_validate_string(FirstName_, node, 'FirstName')
            self.FirstName = FirstName_
            self.validate_FirstName(self.FirstName)    # validate type FirstName
        elif nodeName_ == 'MiddleName':
            MiddleName_ = child_.text
            MiddleName_ = self.gds_validate_string(MiddleName_, node, 'MiddleName')
            self.MiddleName = MiddleName_
            self.validate_MiddleName(self.MiddleName)    # validate type MiddleName
        elif nodeName_ == 'LastSurname':
            LastSurname_ = child_.text
            LastSurname_ = self.gds_validate_string(LastSurname_, node, 'LastSurname')
            self.LastSurname = LastSurname_
            self.validate_LastSurname(self.LastSurname)    # validate type LastSurname
        elif nodeName_ == 'GenerationCodeSuffix':
            GenerationCodeSuffix_ = child_.text
            GenerationCodeSuffix_ = re_.sub(String_cleanup_pat_, " ", GenerationCodeSuffix_).strip()
            GenerationCodeSuffix_ = self.gds_validate_string(GenerationCodeSuffix_, node, 'GenerationCodeSuffix')
            self.GenerationCodeSuffix = GenerationCodeSuffix_
            self.validate_GenerationCodeSuffixType(self.GenerationCodeSuffix)    # validate type GenerationCodeSuffixType
        elif nodeName_ == 'MaidenName':
            MaidenName_ = child_.text
            MaidenName_ = self.gds_validate_string(MaidenName_, node, 'MaidenName')
            self.MaidenName = MaidenName_
            self.validate_LastSurname(self.MaidenName)    # validate type LastSurname
# end class Name


class OtherName(GeneratedsSuper):
    """Other names (e.g., alias, nickname, previous legal name) associated
    with a person."""
    subclass = None
    superclass = None
    def __init__(self, OtherNameType=None, PersonalTitlePrefix=None, FirstName=None, MiddleName=None, LastSurname=None, GenerationCodeSuffix=None):
        self.OtherNameType = _cast(None, OtherNameType)
        self.PersonalTitlePrefix = PersonalTitlePrefix
        self.FirstName = FirstName
        self.MiddleName = MiddleName
        self.LastSurname = LastSurname
        self.GenerationCodeSuffix = GenerationCodeSuffix
    def factory(*args_, **kwargs_):
        if OtherName.subclass:
            return OtherName.subclass(*args_, **kwargs_)
        else:
            return OtherName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PersonalTitlePrefix(self): return self.PersonalTitlePrefix
    def set_PersonalTitlePrefix(self, PersonalTitlePrefix): self.PersonalTitlePrefix = PersonalTitlePrefix
    def validate_PersonalTitlePrefixType(self, value):
        # Validate type PersonalTitlePrefixType, a restriction on xs:token.
        pass
    def get_FirstName(self): return self.FirstName
    def set_FirstName(self, FirstName): self.FirstName = FirstName
    def validate_FirstName(self, value):
        # Validate type FirstName, a restriction on xs:string.
        pass
    def get_MiddleName(self): return self.MiddleName
    def set_MiddleName(self, MiddleName): self.MiddleName = MiddleName
    def validate_MiddleName(self, value):
        # Validate type MiddleName, a restriction on xs:string.
        pass
    def get_LastSurname(self): return self.LastSurname
    def set_LastSurname(self, LastSurname): self.LastSurname = LastSurname
    def validate_LastSurname(self, value):
        # Validate type LastSurname, a restriction on xs:string.
        pass
    def get_GenerationCodeSuffix(self): return self.GenerationCodeSuffix
    def set_GenerationCodeSuffix(self, GenerationCodeSuffix): self.GenerationCodeSuffix = GenerationCodeSuffix
    def validate_GenerationCodeSuffixType(self, value):
        # Validate type GenerationCodeSuffixType, a restriction on xs:token.
        pass
    def get_OtherNameType(self): return self.OtherNameType
    def set_OtherNameType(self, OtherNameType): self.OtherNameType = OtherNameType
    def validate_OtherNameType(self, value):
        # Validate type OtherNameType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='OtherName', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OtherName')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OtherName'):
        if self.OtherNameType is not None and 'OtherNameType' not in already_processed:
            already_processed.append('OtherNameType')
            outfile.write(' OtherNameType=%s' % (quote_attrib(self.OtherNameType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OtherName', fromsubclass_=False):
        if self.PersonalTitlePrefix is not None:
            showIndent(outfile, level)
            outfile.write('<%sPersonalTitlePrefix>%s</%sPersonalTitlePrefix>\n' % (namespace_, self.gds_format_string(quote_xml(self.PersonalTitlePrefix).encode(ExternalEncoding), input_name='PersonalTitlePrefix'), namespace_))
        if self.FirstName is not None:
            showIndent(outfile, level)
            outfile.write('<%sFirstName>%s</%sFirstName>\n' % (namespace_, self.gds_format_string(quote_xml(self.FirstName).encode(ExternalEncoding), input_name='FirstName'), namespace_))
        if self.MiddleName is not None:
            showIndent(outfile, level)
            outfile.write('<%sMiddleName>%s</%sMiddleName>\n' % (namespace_, self.gds_format_string(quote_xml(self.MiddleName).encode(ExternalEncoding), input_name='MiddleName'), namespace_))
        if self.LastSurname is not None:
            showIndent(outfile, level)
            outfile.write('<%sLastSurname>%s</%sLastSurname>\n' % (namespace_, self.gds_format_string(quote_xml(self.LastSurname).encode(ExternalEncoding), input_name='LastSurname'), namespace_))
        if self.GenerationCodeSuffix is not None:
            showIndent(outfile, level)
            outfile.write('<%sGenerationCodeSuffix>%s</%sGenerationCodeSuffix>\n' % (namespace_, self.gds_format_string(quote_xml(self.GenerationCodeSuffix).encode(ExternalEncoding), input_name='GenerationCodeSuffix'), namespace_))
    def hasContent_(self):
        if (
            self.PersonalTitlePrefix is not None or
            self.FirstName is not None or
            self.MiddleName is not None or
            self.LastSurname is not None or
            self.GenerationCodeSuffix is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OtherName'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.OtherNameType is not None and 'OtherNameType' not in already_processed:
            already_processed.append('OtherNameType')
            showIndent(outfile, level)
            outfile.write('OtherNameType = "%s",\n' % (self.OtherNameType,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PersonalTitlePrefix is not None:
            showIndent(outfile, level)
            outfile.write('PersonalTitlePrefix=%s,\n' % quote_python(self.PersonalTitlePrefix).encode(ExternalEncoding))
        if self.FirstName is not None:
            showIndent(outfile, level)
            outfile.write('FirstName=%s,\n' % quote_python(self.FirstName).encode(ExternalEncoding))
        if self.MiddleName is not None:
            showIndent(outfile, level)
            outfile.write('MiddleName=%s,\n' % quote_python(self.MiddleName).encode(ExternalEncoding))
        if self.LastSurname is not None:
            showIndent(outfile, level)
            outfile.write('LastSurname=%s,\n' % quote_python(self.LastSurname).encode(ExternalEncoding))
        if self.GenerationCodeSuffix is not None:
            showIndent(outfile, level)
            outfile.write('GenerationCodeSuffix=%s,\n' % quote_python(self.GenerationCodeSuffix).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('OtherNameType', node)
        if value is not None and 'OtherNameType' not in already_processed:
            already_processed.append('OtherNameType')
            self.OtherNameType = value
            self.OtherNameType = ' '.join(self.OtherNameType.split())
            self.validate_OtherNameType(self.OtherNameType)    # validate type OtherNameType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PersonalTitlePrefix':
            PersonalTitlePrefix_ = child_.text
            PersonalTitlePrefix_ = re_.sub(String_cleanup_pat_, " ", PersonalTitlePrefix_).strip()
            PersonalTitlePrefix_ = self.gds_validate_string(PersonalTitlePrefix_, node, 'PersonalTitlePrefix')
            self.PersonalTitlePrefix = PersonalTitlePrefix_
            self.validate_PersonalTitlePrefixType(self.PersonalTitlePrefix)    # validate type PersonalTitlePrefixType
        elif nodeName_ == 'FirstName':
            FirstName_ = child_.text
            FirstName_ = self.gds_validate_string(FirstName_, node, 'FirstName')
            self.FirstName = FirstName_
            self.validate_FirstName(self.FirstName)    # validate type FirstName
        elif nodeName_ == 'MiddleName':
            MiddleName_ = child_.text
            MiddleName_ = self.gds_validate_string(MiddleName_, node, 'MiddleName')
            self.MiddleName = MiddleName_
            self.validate_MiddleName(self.MiddleName)    # validate type MiddleName
        elif nodeName_ == 'LastSurname':
            LastSurname_ = child_.text
            LastSurname_ = self.gds_validate_string(LastSurname_, node, 'LastSurname')
            self.LastSurname = LastSurname_
            self.validate_LastSurname(self.LastSurname)    # validate type LastSurname
        elif nodeName_ == 'GenerationCodeSuffix':
            GenerationCodeSuffix_ = child_.text
            GenerationCodeSuffix_ = re_.sub(String_cleanup_pat_, " ", GenerationCodeSuffix_).strip()
            GenerationCodeSuffix_ = self.gds_validate_string(GenerationCodeSuffix_, node, 'GenerationCodeSuffix')
            self.GenerationCodeSuffix = GenerationCodeSuffix_
            self.validate_GenerationCodeSuffixType(self.GenerationCodeSuffix)    # validate type GenerationCodeSuffixType
# end class OtherName


class ProgramParticipation(GeneratedsSuper):
    """Programs the student is participating in or receiving services."""
    subclass = None
    superclass = None
    def __init__(self, Program=None, BeginDate=None, EndDate=None, DesignatedBy=None):
        self.Program = Program
        self.BeginDate = BeginDate
        self.EndDate = EndDate
        self.DesignatedBy = DesignatedBy
    def factory(*args_, **kwargs_):
        if ProgramParticipation.subclass:
            return ProgramParticipation.subclass(*args_, **kwargs_)
        else:
            return ProgramParticipation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Program(self): return self.Program
    def set_Program(self, Program): self.Program = Program
    def validate_ProgramType(self, value):
        # Validate type ProgramType, a restriction on xs:token.
        pass
    def get_BeginDate(self): return self.BeginDate
    def set_BeginDate(self, BeginDate): self.BeginDate = BeginDate
    def get_EndDate(self): return self.EndDate
    def set_EndDate(self, EndDate): self.EndDate = EndDate
    def get_DesignatedBy(self): return self.DesignatedBy
    def set_DesignatedBy(self, DesignatedBy): self.DesignatedBy = DesignatedBy
    def validate_DesignatedBy(self, value):
        # Validate type DesignatedBy, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='ProgramParticipation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProgramParticipation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProgramParticipation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ProgramParticipation', fromsubclass_=False):
        if self.Program is not None:
            showIndent(outfile, level)
            outfile.write('<%sProgram>%s</%sProgram>\n' % (namespace_, self.gds_format_string(quote_xml(self.Program).encode(ExternalEncoding), input_name='Program'), namespace_))
        if self.BeginDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sBeginDate>%s</%sBeginDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.BeginDate).encode(ExternalEncoding), input_name='BeginDate'), namespace_))
        if self.EndDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sEndDate>%s</%sEndDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.EndDate).encode(ExternalEncoding), input_name='EndDate'), namespace_))
        if self.DesignatedBy is not None:
            showIndent(outfile, level)
            outfile.write('<%sDesignatedBy>%s</%sDesignatedBy>\n' % (namespace_, self.gds_format_string(quote_xml(self.DesignatedBy).encode(ExternalEncoding), input_name='DesignatedBy'), namespace_))
    def hasContent_(self):
        if (
            self.Program is not None or
            self.BeginDate is not None or
            self.EndDate is not None or
            self.DesignatedBy is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ProgramParticipation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Program is not None:
            showIndent(outfile, level)
            outfile.write('Program=%s,\n' % quote_python(self.Program).encode(ExternalEncoding))
        if self.BeginDate is not None:
            showIndent(outfile, level)
            outfile.write('BeginDate=%s,\n' % quote_python(self.BeginDate).encode(ExternalEncoding))
        if self.EndDate is not None:
            showIndent(outfile, level)
            outfile.write('EndDate=%s,\n' % quote_python(self.EndDate).encode(ExternalEncoding))
        if self.DesignatedBy is not None:
            showIndent(outfile, level)
            outfile.write('DesignatedBy=%s,\n' % quote_python(self.DesignatedBy).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Program':
            Program_ = child_.text
            Program_ = re_.sub(String_cleanup_pat_, " ", Program_).strip()
            Program_ = self.gds_validate_string(Program_, node, 'Program')
            self.Program = Program_
            self.validate_ProgramType(self.Program)    # validate type ProgramType
        elif nodeName_ == 'BeginDate':
            BeginDate_ = child_.text
            BeginDate_ = self.gds_validate_string(BeginDate_, node, 'BeginDate')
            self.BeginDate = BeginDate_
        elif nodeName_ == 'EndDate':
            EndDate_ = child_.text
            EndDate_ = self.gds_validate_string(EndDate_, node, 'EndDate')
            self.EndDate = EndDate_
        elif nodeName_ == 'DesignatedBy':
            DesignatedBy_ = child_.text
            DesignatedBy_ = self.gds_validate_string(DesignatedBy_, node, 'DesignatedBy')
            self.DesignatedBy = DesignatedBy_
            self.validate_DesignatedBy(self.DesignatedBy)    # validate type DesignatedBy
# end class ProgramParticipation


class RatingStandardOutcome(GeneratedsSuper):
    """The assessment rating standards achieved. The name of the level of
    performance rating standard reported. For example: Passing,
    Standard, or Commended."""
    subclass = None
    superclass = None
    def __init__(self, RatingStandardName=None, RatingStandardMet=None):
        self.RatingStandardName = _cast(None, RatingStandardName)
        self.RatingStandardMet = RatingStandardMet
    def factory(*args_, **kwargs_):
        if RatingStandardOutcome.subclass:
            return RatingStandardOutcome.subclass(*args_, **kwargs_)
        else:
            return RatingStandardOutcome(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RatingStandardMet(self): return self.RatingStandardMet
    def set_RatingStandardMet(self, RatingStandardMet): self.RatingStandardMet = RatingStandardMet
    def get_RatingStandardName(self): return self.RatingStandardName
    def set_RatingStandardName(self, RatingStandardName): self.RatingStandardName = RatingStandardName
    def validate_RatingStandardNameType(self, value):
        # Validate type RatingStandardNameType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='RatingStandardOutcome', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RatingStandardOutcome')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RatingStandardOutcome'):
        if self.RatingStandardName is not None and 'RatingStandardName' not in already_processed:
            already_processed.append('RatingStandardName')
            outfile.write(' RatingStandardName=%s' % (quote_attrib(self.RatingStandardName), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RatingStandardOutcome', fromsubclass_=False):
        if self.RatingStandardMet is not None:
            showIndent(outfile, level)
            outfile.write('<%sRatingStandardMet>%s</%sRatingStandardMet>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.RatingStandardMet)), input_name='RatingStandardMet'), namespace_))
    def hasContent_(self):
        if (
            self.RatingStandardMet is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RatingStandardOutcome'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.RatingStandardName is not None and 'RatingStandardName' not in already_processed:
            already_processed.append('RatingStandardName')
            showIndent(outfile, level)
            outfile.write('RatingStandardName = "%s",\n' % (self.RatingStandardName,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RatingStandardMet is not None:
            showIndent(outfile, level)
            outfile.write('RatingStandardMet=%s,\n' % self.RatingStandardMet)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('RatingStandardName', node)
        if value is not None and 'RatingStandardName' not in already_processed:
            already_processed.append('RatingStandardName')
            self.RatingStandardName = value
            self.RatingStandardName = ' '.join(self.RatingStandardName.split())
            self.validate_RatingStandardNameType(self.RatingStandardName)    # validate type RatingStandardNameType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RatingStandardMet':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'RatingStandardMet')
            self.RatingStandardMet = ival_
# end class RatingStandardOutcome


class Recognition(GeneratedsSuper):
    """Recognition given to the student for accomplishments in a co-
    curricular, or extra-curricular activity."""
    subclass = None
    superclass = None
    def __init__(self, RecognitionType=None, RecognitionDescription=None, RecognitionAwardDate=None):
        self.RecognitionType = RecognitionType
        self.RecognitionDescription = RecognitionDescription
        self.RecognitionAwardDate = RecognitionAwardDate
    def factory(*args_, **kwargs_):
        if Recognition.subclass:
            return Recognition.subclass(*args_, **kwargs_)
        else:
            return Recognition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RecognitionType(self): return self.RecognitionType
    def set_RecognitionType(self, RecognitionType): self.RecognitionType = RecognitionType
    def validate_RecognitionType(self, value):
        # Validate type RecognitionType, a restriction on xs:token.
        pass
    def get_RecognitionDescription(self): return self.RecognitionDescription
    def set_RecognitionDescription(self, RecognitionDescription): self.RecognitionDescription = RecognitionDescription
    def validate_RecognitionDescription(self, value):
        # Validate type RecognitionDescription, a restriction on xs:string.
        pass
    def get_RecognitionAwardDate(self): return self.RecognitionAwardDate
    def set_RecognitionAwardDate(self, RecognitionAwardDate): self.RecognitionAwardDate = RecognitionAwardDate
    def export(self, outfile, level, namespace_='', name_='Recognition', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Recognition')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Recognition'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Recognition', fromsubclass_=False):
        if self.RecognitionType is not None:
            showIndent(outfile, level)
            outfile.write('<%sRecognitionType>%s</%sRecognitionType>\n' % (namespace_, self.gds_format_string(quote_xml(self.RecognitionType).encode(ExternalEncoding), input_name='RecognitionType'), namespace_))
        if self.RecognitionDescription is not None:
            showIndent(outfile, level)
            outfile.write('<%sRecognitionDescription>%s</%sRecognitionDescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.RecognitionDescription).encode(ExternalEncoding), input_name='RecognitionDescription'), namespace_))
        if self.RecognitionAwardDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sRecognitionAwardDate>%s</%sRecognitionAwardDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.RecognitionAwardDate).encode(ExternalEncoding), input_name='RecognitionAwardDate'), namespace_))
    def hasContent_(self):
        if (
            self.RecognitionType is not None or
            self.RecognitionDescription is not None or
            self.RecognitionAwardDate is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Recognition'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RecognitionType is not None:
            showIndent(outfile, level)
            outfile.write('RecognitionType=%s,\n' % quote_python(self.RecognitionType).encode(ExternalEncoding))
        if self.RecognitionDescription is not None:
            showIndent(outfile, level)
            outfile.write('RecognitionDescription=%s,\n' % quote_python(self.RecognitionDescription).encode(ExternalEncoding))
        if self.RecognitionAwardDate is not None:
            showIndent(outfile, level)
            outfile.write('RecognitionAwardDate=%s,\n' % quote_python(self.RecognitionAwardDate).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RecognitionType':
            RecognitionType_ = child_.text
            RecognitionType_ = re_.sub(String_cleanup_pat_, " ", RecognitionType_).strip()
            RecognitionType_ = self.gds_validate_string(RecognitionType_, node, 'RecognitionType')
            self.RecognitionType = RecognitionType_
            self.validate_RecognitionType(self.RecognitionType)    # validate type RecognitionType
        elif nodeName_ == 'RecognitionDescription':
            RecognitionDescription_ = child_.text
            RecognitionDescription_ = self.gds_validate_string(RecognitionDescription_, node, 'RecognitionDescription')
            self.RecognitionDescription = RecognitionDescription_
            self.validate_RecognitionDescription(self.RecognitionDescription)    # validate type RecognitionDescription
        elif nodeName_ == 'RecognitionAwardDate':
            RecognitionAwardDate_ = child_.text
            RecognitionAwardDate_ = self.gds_validate_string(RecognitionAwardDate_, node, 'RecognitionAwardDate')
            self.RecognitionAwardDate = RecognitionAwardDate_
# end class Recognition


class ScoreResult(GeneratedsSuper):
    """A meaningful raw score or statistical expression of the performance
    of an individual. The results can be expressed as a number,
    percentile, range, level, etc.The method that the instructor of
    the class uses to report the performance and achievement of all
    students. It may be a qualitative method such as individualized
    teacher comments or a quantitative method such as a letter or a
    numerical grade. In some cases, more than one type of reporting
    method may be used."""
    subclass = None
    superclass = None
    def __init__(self, AssessmentReportingMethod=None, Result=None):
        self.AssessmentReportingMethod = _cast(None, AssessmentReportingMethod)
        self.Result = Result
    def factory(*args_, **kwargs_):
        if ScoreResult.subclass:
            return ScoreResult.subclass(*args_, **kwargs_)
        else:
            return ScoreResult(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Result(self): return self.Result
    def set_Result(self, Result): self.Result = Result
    def validate_Result(self, value):
        # Validate type Result, a restriction on xs:string.
        pass
    def get_AssessmentReportingMethod(self): return self.AssessmentReportingMethod
    def set_AssessmentReportingMethod(self, AssessmentReportingMethod): self.AssessmentReportingMethod = AssessmentReportingMethod
    def validate_AssessmentReportingMethodType(self, value):
        # Validate type AssessmentReportingMethodType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='ScoreResult', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ScoreResult')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ScoreResult'):
        if self.AssessmentReportingMethod is not None and 'AssessmentReportingMethod' not in already_processed:
            already_processed.append('AssessmentReportingMethod')
            outfile.write(' AssessmentReportingMethod=%s' % (quote_attrib(self.AssessmentReportingMethod), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ScoreResult', fromsubclass_=False):
        if self.Result is not None:
            showIndent(outfile, level)
            outfile.write('<%sResult>%s</%sResult>\n' % (namespace_, self.gds_format_string(quote_xml(self.Result).encode(ExternalEncoding), input_name='Result'), namespace_))
    def hasContent_(self):
        if (
            self.Result is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ScoreResult'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.AssessmentReportingMethod is not None and 'AssessmentReportingMethod' not in already_processed:
            already_processed.append('AssessmentReportingMethod')
            showIndent(outfile, level)
            outfile.write('AssessmentReportingMethod = "%s",\n' % (self.AssessmentReportingMethod,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Result is not None:
            showIndent(outfile, level)
            outfile.write('Result=%s,\n' % quote_python(self.Result).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('AssessmentReportingMethod', node)
        if value is not None and 'AssessmentReportingMethod' not in already_processed:
            already_processed.append('AssessmentReportingMethod')
            self.AssessmentReportingMethod = value
            self.AssessmentReportingMethod = ' '.join(self.AssessmentReportingMethod.split())
            self.validate_AssessmentReportingMethodType(self.AssessmentReportingMethod)    # validate type AssessmentReportingMethodType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Result':
            Result_ = child_.text
            Result_ = self.gds_validate_string(Result_, node, 'Result')
            self.Result = Result_
            self.validate_Result(self.Result)    # validate type Result
# end class ScoreResult


class SecondaryIncidentBehavior(GeneratedsSuper):
    """Definition of the behavior coded for use in describing an
    incident.The category of the incident behavior for
    classification purposes"""
    subclass = None
    superclass = None
    def __init__(self, IncidentCategory=None, SecondaryBehavior=None):
        self.IncidentCategory = _cast(None, IncidentCategory)
        self.SecondaryBehavior = SecondaryBehavior
    def factory(*args_, **kwargs_):
        if SecondaryIncidentBehavior.subclass:
            return SecondaryIncidentBehavior.subclass(*args_, **kwargs_)
        else:
            return SecondaryIncidentBehavior(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SecondaryBehavior(self): return self.SecondaryBehavior
    def set_SecondaryBehavior(self, SecondaryBehavior): self.SecondaryBehavior = SecondaryBehavior
    def validate_SecondaryIncidentBehaviorsType(self, value):
        # Validate type SecondaryIncidentBehaviorsType, a restriction on xs:string.
        pass
    def get_IncidentCategory(self): return self.IncidentCategory
    def set_IncidentCategory(self, IncidentCategory): self.IncidentCategory = IncidentCategory
    def validate_IncidentCategoryType(self, value):
        # Validate type IncidentCategoryType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='SecondaryIncidentBehavior', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SecondaryIncidentBehavior')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SecondaryIncidentBehavior'):
        if self.IncidentCategory is not None and 'IncidentCategory' not in already_processed:
            already_processed.append('IncidentCategory')
            outfile.write(' IncidentCategory=%s' % (quote_attrib(self.IncidentCategory), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SecondaryIncidentBehavior', fromsubclass_=False):
        if self.SecondaryBehavior is not None:
            showIndent(outfile, level)
            outfile.write('<%sSecondaryBehavior>%s</%sSecondaryBehavior>\n' % (namespace_, self.gds_format_string(quote_xml(self.SecondaryBehavior).encode(ExternalEncoding), input_name='SecondaryBehavior'), namespace_))
    def hasContent_(self):
        if (
            self.SecondaryBehavior is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SecondaryIncidentBehavior'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.IncidentCategory is not None and 'IncidentCategory' not in already_processed:
            already_processed.append('IncidentCategory')
            showIndent(outfile, level)
            outfile.write('IncidentCategory = "%s",\n' % (self.IncidentCategory,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SecondaryBehavior is not None:
            showIndent(outfile, level)
            outfile.write('SecondaryBehavior=%s,\n' % quote_python(self.SecondaryBehavior).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IncidentCategory', node)
        if value is not None and 'IncidentCategory' not in already_processed:
            already_processed.append('IncidentCategory')
            self.IncidentCategory = value
            self.IncidentCategory = ' '.join(self.IncidentCategory.split())
            self.validate_IncidentCategoryType(self.IncidentCategory)    # validate type IncidentCategoryType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SecondaryBehavior':
            SecondaryBehavior_ = child_.text
            SecondaryBehavior_ = self.gds_validate_string(SecondaryBehavior_, node, 'SecondaryBehavior')
            self.SecondaryBehavior = SecondaryBehavior_
            self.validate_SecondaryIncidentBehaviorsType(self.SecondaryBehavior)    # validate type SecondaryIncidentBehaviorsType
# end class SecondaryIncidentBehavior


class StaffIdentificationCode(GeneratedsSuper):
    """A coding scheme that is used for identification and record-keeping
    purposes by schools, social services, or other agencies to refer
    to staff member.A coding scheme that is used for identification
    and record-keeping purposes by schools, social services, or
    other agencies to refer to a staff member.The organization code
    or name assigning the staff Identification Code."""
    subclass = None
    superclass = None
    def __init__(self, IdentificationSystem=None, AssigningOrganizationCode=None, ID=None):
        self.IdentificationSystem = _cast(None, IdentificationSystem)
        self.AssigningOrganizationCode = _cast(None, AssigningOrganizationCode)
        self.ID = ID
    def factory(*args_, **kwargs_):
        if StaffIdentificationCode.subclass:
            return StaffIdentificationCode.subclass(*args_, **kwargs_)
        else:
            return StaffIdentificationCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_IdentificationCode(self, value):
        # Validate type IdentificationCode, a restriction on xs:string.
        pass
    def get_IdentificationSystem(self): return self.IdentificationSystem
    def set_IdentificationSystem(self, IdentificationSystem): self.IdentificationSystem = IdentificationSystem
    def validate_StaffIdentificationSystemType(self, value):
        # Validate type StaffIdentificationSystemType, a restriction on xs:token.
        pass
    def get_AssigningOrganizationCode(self): return self.AssigningOrganizationCode
    def set_AssigningOrganizationCode(self, AssigningOrganizationCode): self.AssigningOrganizationCode = AssigningOrganizationCode
    def export(self, outfile, level, namespace_='', name_='StaffIdentificationCode', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StaffIdentificationCode')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StaffIdentificationCode'):
        if self.IdentificationSystem is not None and 'IdentificationSystem' not in already_processed:
            already_processed.append('IdentificationSystem')
            outfile.write(' IdentificationSystem=%s' % (quote_attrib(self.IdentificationSystem), ))
        if self.AssigningOrganizationCode is not None and 'AssigningOrganizationCode' not in already_processed:
            already_processed.append('AssigningOrganizationCode')
            outfile.write(' AssigningOrganizationCode=%s' % (self.gds_format_string(quote_attrib(self.AssigningOrganizationCode).encode(ExternalEncoding), input_name='AssigningOrganizationCode'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StaffIdentificationCode', fromsubclass_=False):
        if self.ID is not None:
            showIndent(outfile, level)
            outfile.write('<%sID>%s</%sID>\n' % (namespace_, self.gds_format_string(quote_xml(self.ID).encode(ExternalEncoding), input_name='ID'), namespace_))
    def hasContent_(self):
        if (
            self.ID is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StaffIdentificationCode'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.IdentificationSystem is not None and 'IdentificationSystem' not in already_processed:
            already_processed.append('IdentificationSystem')
            showIndent(outfile, level)
            outfile.write('IdentificationSystem = "%s",\n' % (self.IdentificationSystem,))
        if self.AssigningOrganizationCode is not None and 'AssigningOrganizationCode' not in already_processed:
            already_processed.append('AssigningOrganizationCode')
            showIndent(outfile, level)
            outfile.write('AssigningOrganizationCode = "%s",\n' % (self.AssigningOrganizationCode,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ID is not None:
            showIndent(outfile, level)
            outfile.write('ID=%s,\n' % quote_python(self.ID).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IdentificationSystem', node)
        if value is not None and 'IdentificationSystem' not in already_processed:
            already_processed.append('IdentificationSystem')
            self.IdentificationSystem = value
            self.IdentificationSystem = ' '.join(self.IdentificationSystem.split())
            self.validate_StaffIdentificationSystemType(self.IdentificationSystem)    # validate type StaffIdentificationSystemType
        value = find_attr_value_('AssigningOrganizationCode', node)
        if value is not None and 'AssigningOrganizationCode' not in already_processed:
            already_processed.append('AssigningOrganizationCode')
            self.AssigningOrganizationCode = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
            self.validate_IdentificationCode(self.ID)    # validate type IdentificationCode
# end class StaffIdentificationCode


class StudentCharacteristic(GeneratedsSuper):
    """Reflects important characteristics of the student's home situation:
    Displaced Homemaker, Homeless, Immigrant, Migratory, Military
    Parent, Pregnant Teen, Single Parent, Unaccompanied Youth"""
    subclass = None
    superclass = None
    def __init__(self, Characteristic=None, BeginDate=None, EndDate=None, DesignatedBy=None):
        self.Characteristic = Characteristic
        self.BeginDate = BeginDate
        self.EndDate = EndDate
        self.DesignatedBy = DesignatedBy
    def factory(*args_, **kwargs_):
        if StudentCharacteristic.subclass:
            return StudentCharacteristic.subclass(*args_, **kwargs_)
        else:
            return StudentCharacteristic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Characteristic(self): return self.Characteristic
    def set_Characteristic(self, Characteristic): self.Characteristic = Characteristic
    def validate_StudentCharacteristicType(self, value):
        # Validate type StudentCharacteristicType, a restriction on xs:token.
        pass
    def get_BeginDate(self): return self.BeginDate
    def set_BeginDate(self, BeginDate): self.BeginDate = BeginDate
    def get_EndDate(self): return self.EndDate
    def set_EndDate(self, EndDate): self.EndDate = EndDate
    def get_DesignatedBy(self): return self.DesignatedBy
    def set_DesignatedBy(self, DesignatedBy): self.DesignatedBy = DesignatedBy
    def validate_DesignatedBy(self, value):
        # Validate type DesignatedBy, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='StudentCharacteristic', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StudentCharacteristic')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StudentCharacteristic'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StudentCharacteristic', fromsubclass_=False):
        if self.Characteristic is not None:
            showIndent(outfile, level)
            outfile.write('<%sCharacteristic>%s</%sCharacteristic>\n' % (namespace_, self.gds_format_string(quote_xml(self.Characteristic).encode(ExternalEncoding), input_name='Characteristic'), namespace_))
        if self.BeginDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sBeginDate>%s</%sBeginDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.BeginDate).encode(ExternalEncoding), input_name='BeginDate'), namespace_))
        if self.EndDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sEndDate>%s</%sEndDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.EndDate).encode(ExternalEncoding), input_name='EndDate'), namespace_))
        if self.DesignatedBy is not None:
            showIndent(outfile, level)
            outfile.write('<%sDesignatedBy>%s</%sDesignatedBy>\n' % (namespace_, self.gds_format_string(quote_xml(self.DesignatedBy).encode(ExternalEncoding), input_name='DesignatedBy'), namespace_))
    def hasContent_(self):
        if (
            self.Characteristic is not None or
            self.BeginDate is not None or
            self.EndDate is not None or
            self.DesignatedBy is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StudentCharacteristic'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Characteristic is not None:
            showIndent(outfile, level)
            outfile.write('Characteristic=%s,\n' % quote_python(self.Characteristic).encode(ExternalEncoding))
        if self.BeginDate is not None:
            showIndent(outfile, level)
            outfile.write('BeginDate=%s,\n' % quote_python(self.BeginDate).encode(ExternalEncoding))
        if self.EndDate is not None:
            showIndent(outfile, level)
            outfile.write('EndDate=%s,\n' % quote_python(self.EndDate).encode(ExternalEncoding))
        if self.DesignatedBy is not None:
            showIndent(outfile, level)
            outfile.write('DesignatedBy=%s,\n' % quote_python(self.DesignatedBy).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Characteristic':
            Characteristic_ = child_.text
            Characteristic_ = re_.sub(String_cleanup_pat_, " ", Characteristic_).strip()
            Characteristic_ = self.gds_validate_string(Characteristic_, node, 'Characteristic')
            self.Characteristic = Characteristic_
            self.validate_StudentCharacteristicType(self.Characteristic)    # validate type StudentCharacteristicType
        elif nodeName_ == 'BeginDate':
            BeginDate_ = child_.text
            BeginDate_ = self.gds_validate_string(BeginDate_, node, 'BeginDate')
            self.BeginDate = BeginDate_
        elif nodeName_ == 'EndDate':
            EndDate_ = child_.text
            EndDate_ = self.gds_validate_string(EndDate_, node, 'EndDate')
            self.EndDate = EndDate_
        elif nodeName_ == 'DesignatedBy':
            DesignatedBy_ = child_.text
            DesignatedBy_ = self.gds_validate_string(DesignatedBy_, node, 'DesignatedBy')
            self.DesignatedBy = DesignatedBy_
            self.validate_DesignatedBy(self.DesignatedBy)    # validate type DesignatedBy
# end class StudentCharacteristic


class StudentIdentificationCode(GeneratedsSuper):
    """A coding scheme that is used for identification and record-keeping
    purposes by schools, social services, or other agencies to refer
    to a student.A coding scheme that is used for identification and
    record-keeping purposes by schools, social services, or other
    agencies to refer to a student.The organization code or name
    assigning the student Identification Code."""
    subclass = None
    superclass = None
    def __init__(self, IdentificationSystem=None, AssigningOrganizationCode=None, IdentificationCode=None):
        self.IdentificationSystem = _cast(None, IdentificationSystem)
        self.AssigningOrganizationCode = _cast(None, AssigningOrganizationCode)
        self.IdentificationCode = IdentificationCode
    def factory(*args_, **kwargs_):
        if StudentIdentificationCode.subclass:
            return StudentIdentificationCode.subclass(*args_, **kwargs_)
        else:
            return StudentIdentificationCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IdentificationCode(self): return self.IdentificationCode
    def set_IdentificationCode(self, IdentificationCode): self.IdentificationCode = IdentificationCode
    def validate_IdentificationCode(self, value):
        # Validate type IdentificationCode, a restriction on xs:string.
        pass
    def get_IdentificationSystem(self): return self.IdentificationSystem
    def set_IdentificationSystem(self, IdentificationSystem): self.IdentificationSystem = IdentificationSystem
    def validate_StudentIdentificationSystemType(self, value):
        # Validate type StudentIdentificationSystemType, a restriction on xs:token.
        pass
    def get_AssigningOrganizationCode(self): return self.AssigningOrganizationCode
    def set_AssigningOrganizationCode(self, AssigningOrganizationCode): self.AssigningOrganizationCode = AssigningOrganizationCode
    def export(self, outfile, level, namespace_='', name_='StudentIdentificationCode', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StudentIdentificationCode')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StudentIdentificationCode'):
        if self.IdentificationSystem is not None and 'IdentificationSystem' not in already_processed:
            already_processed.append('IdentificationSystem')
            outfile.write(' IdentificationSystem=%s' % (quote_attrib(self.IdentificationSystem), ))
        if self.AssigningOrganizationCode is not None and 'AssigningOrganizationCode' not in already_processed:
            already_processed.append('AssigningOrganizationCode')
            outfile.write(' AssigningOrganizationCode=%s' % (self.gds_format_string(quote_attrib(self.AssigningOrganizationCode).encode(ExternalEncoding), input_name='AssigningOrganizationCode'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StudentIdentificationCode', fromsubclass_=False):
        if self.IdentificationCode is not None:
            showIndent(outfile, level)
            outfile.write('<%sIdentificationCode>%s</%sIdentificationCode>\n' % (namespace_, self.gds_format_string(quote_xml(self.IdentificationCode).encode(ExternalEncoding), input_name='IdentificationCode'), namespace_))
    def hasContent_(self):
        if (
            self.IdentificationCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StudentIdentificationCode'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.IdentificationSystem is not None and 'IdentificationSystem' not in already_processed:
            already_processed.append('IdentificationSystem')
            showIndent(outfile, level)
            outfile.write('IdentificationSystem = "%s",\n' % (self.IdentificationSystem,))
        if self.AssigningOrganizationCode is not None and 'AssigningOrganizationCode' not in already_processed:
            already_processed.append('AssigningOrganizationCode')
            showIndent(outfile, level)
            outfile.write('AssigningOrganizationCode = "%s",\n' % (self.AssigningOrganizationCode,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.IdentificationCode is not None:
            showIndent(outfile, level)
            outfile.write('IdentificationCode=%s,\n' % quote_python(self.IdentificationCode).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IdentificationSystem', node)
        if value is not None and 'IdentificationSystem' not in already_processed:
            already_processed.append('IdentificationSystem')
            self.IdentificationSystem = value
            self.IdentificationSystem = ' '.join(self.IdentificationSystem.split())
            self.validate_StudentIdentificationSystemType(self.IdentificationSystem)    # validate type StudentIdentificationSystemType
        value = find_attr_value_('AssigningOrganizationCode', node)
        if value is not None and 'AssigningOrganizationCode' not in already_processed:
            already_processed.append('AssigningOrganizationCode')
            self.AssigningOrganizationCode = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IdentificationCode':
            IdentificationCode_ = child_.text
            IdentificationCode_ = self.gds_validate_string(IdentificationCode_, node, 'IdentificationCode')
            self.IdentificationCode = IdentificationCode_
            self.validate_IdentificationCode(self.IdentificationCode)    # validate type IdentificationCode
# end class StudentIdentificationCode


class StudentIndicator(GeneratedsSuper):
    """An indicator or metric computed for the student (e.g., at risk) to
    influence more effective education or direct specific
    interventions."""
    subclass = None
    superclass = None
    def __init__(self, IndicatorName=None, Indicator=None, BeginDate=None, EndDate=None, DesignatedBy=None):
        self.IndicatorName = IndicatorName
        self.Indicator = Indicator
        self.BeginDate = BeginDate
        self.EndDate = EndDate
        self.DesignatedBy = DesignatedBy
    def factory(*args_, **kwargs_):
        if StudentIndicator.subclass:
            return StudentIndicator.subclass(*args_, **kwargs_)
        else:
            return StudentIndicator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IndicatorName(self): return self.IndicatorName
    def set_IndicatorName(self, IndicatorName): self.IndicatorName = IndicatorName
    def validate_IndicationName(self, value):
        # Validate type IndicationName, a restriction on xs:string.
        pass
    def get_Indicator(self): return self.Indicator
    def set_Indicator(self, Indicator): self.Indicator = Indicator
    def validate_Indication(self, value):
        # Validate type Indication, a restriction on xs:string.
        pass
    def get_BeginDate(self): return self.BeginDate
    def set_BeginDate(self, BeginDate): self.BeginDate = BeginDate
    def get_EndDate(self): return self.EndDate
    def set_EndDate(self, EndDate): self.EndDate = EndDate
    def get_DesignatedBy(self): return self.DesignatedBy
    def set_DesignatedBy(self, DesignatedBy): self.DesignatedBy = DesignatedBy
    def validate_DesignatedBy(self, value):
        # Validate type DesignatedBy, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='StudentIndicator', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StudentIndicator')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StudentIndicator'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StudentIndicator', fromsubclass_=False):
        if self.IndicatorName is not None:
            showIndent(outfile, level)
            outfile.write('<%sIndicatorName>%s</%sIndicatorName>\n' % (namespace_, self.gds_format_string(quote_xml(self.IndicatorName).encode(ExternalEncoding), input_name='IndicatorName'), namespace_))
        if self.Indicator is not None:
            showIndent(outfile, level)
            outfile.write('<%sIndicator>%s</%sIndicator>\n' % (namespace_, self.gds_format_string(quote_xml(self.Indicator).encode(ExternalEncoding), input_name='Indicator'), namespace_))
        if self.BeginDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sBeginDate>%s</%sBeginDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.BeginDate).encode(ExternalEncoding), input_name='BeginDate'), namespace_))
        if self.EndDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sEndDate>%s</%sEndDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.EndDate).encode(ExternalEncoding), input_name='EndDate'), namespace_))
        if self.DesignatedBy is not None:
            showIndent(outfile, level)
            outfile.write('<%sDesignatedBy>%s</%sDesignatedBy>\n' % (namespace_, self.gds_format_string(quote_xml(self.DesignatedBy).encode(ExternalEncoding), input_name='DesignatedBy'), namespace_))
    def hasContent_(self):
        if (
            self.IndicatorName is not None or
            self.Indicator is not None or
            self.BeginDate is not None or
            self.EndDate is not None or
            self.DesignatedBy is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StudentIndicator'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.IndicatorName is not None:
            showIndent(outfile, level)
            outfile.write('IndicatorName=%s,\n' % quote_python(self.IndicatorName).encode(ExternalEncoding))
        if self.Indicator is not None:
            showIndent(outfile, level)
            outfile.write('Indicator=%s,\n' % quote_python(self.Indicator).encode(ExternalEncoding))
        if self.BeginDate is not None:
            showIndent(outfile, level)
            outfile.write('BeginDate=%s,\n' % quote_python(self.BeginDate).encode(ExternalEncoding))
        if self.EndDate is not None:
            showIndent(outfile, level)
            outfile.write('EndDate=%s,\n' % quote_python(self.EndDate).encode(ExternalEncoding))
        if self.DesignatedBy is not None:
            showIndent(outfile, level)
            outfile.write('DesignatedBy=%s,\n' % quote_python(self.DesignatedBy).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IndicatorName':
            IndicatorName_ = child_.text
            IndicatorName_ = self.gds_validate_string(IndicatorName_, node, 'IndicatorName')
            self.IndicatorName = IndicatorName_
            self.validate_IndicationName(self.IndicatorName)    # validate type IndicationName
        elif nodeName_ == 'Indicator':
            Indicator_ = child_.text
            Indicator_ = self.gds_validate_string(Indicator_, node, 'Indicator')
            self.Indicator = Indicator_
            self.validate_Indication(self.Indicator)    # validate type Indication
        elif nodeName_ == 'BeginDate':
            BeginDate_ = child_.text
            BeginDate_ = self.gds_validate_string(BeginDate_, node, 'BeginDate')
            self.BeginDate = BeginDate_
        elif nodeName_ == 'EndDate':
            EndDate_ = child_.text
            EndDate_ = self.gds_validate_string(EndDate_, node, 'EndDate')
            self.EndDate = EndDate_
        elif nodeName_ == 'DesignatedBy':
            DesignatedBy_ = child_.text
            DesignatedBy_ = self.gds_validate_string(DesignatedBy_, node, 'DesignatedBy')
            self.DesignatedBy = DesignatedBy_
            self.validate_DesignatedBy(self.DesignatedBy)    # validate type DesignatedBy
# end class StudentIndicator


class Telephone(GeneratedsSuper):
    """The 10-digit telephone number, including the area code, for the
    person.The type of communication number listed for an individual
    or organization.An indication that the telephone number should
    be used as the principal number for an individual or
    organization."""
    subclass = None
    superclass = None
    def __init__(self, TelephoneNumberType=None, PrimaryTelephoneNumberIndicator=None, TelephoneNumber=None):
        self.TelephoneNumberType = _cast(None, TelephoneNumberType)
        self.PrimaryTelephoneNumberIndicator = _cast(bool, PrimaryTelephoneNumberIndicator)
        self.TelephoneNumber = TelephoneNumber
    def factory(*args_, **kwargs_):
        if Telephone.subclass:
            return Telephone.subclass(*args_, **kwargs_)
        else:
            return Telephone(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TelephoneNumber(self): return self.TelephoneNumber
    def set_TelephoneNumber(self, TelephoneNumber): self.TelephoneNumber = TelephoneNumber
    def validate_TelephoneNumber(self, value):
        # Validate type TelephoneNumber, a restriction on xs:string.
        pass
    def get_TelephoneNumberType(self): return self.TelephoneNumberType
    def set_TelephoneNumberType(self, TelephoneNumberType): self.TelephoneNumberType = TelephoneNumberType
    def validate_TelephoneNumberType(self, value):
        # Validate type TelephoneNumberType, a restriction on xs:token.
        pass
    def get_PrimaryTelephoneNumberIndicator(self): return self.PrimaryTelephoneNumberIndicator
    def set_PrimaryTelephoneNumberIndicator(self, PrimaryTelephoneNumberIndicator): self.PrimaryTelephoneNumberIndicator = PrimaryTelephoneNumberIndicator
    def export(self, outfile, level, namespace_='', name_='Telephone', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Telephone')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Telephone'):
        if self.TelephoneNumberType is not None and 'TelephoneNumberType' not in already_processed:
            already_processed.append('TelephoneNumberType')
            outfile.write(' TelephoneNumberType=%s' % (quote_attrib(self.TelephoneNumberType), ))
        if self.PrimaryTelephoneNumberIndicator is not None and 'PrimaryTelephoneNumberIndicator' not in already_processed:
            already_processed.append('PrimaryTelephoneNumberIndicator')
            outfile.write(' PrimaryTelephoneNumberIndicator="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.PrimaryTelephoneNumberIndicator)), input_name='PrimaryTelephoneNumberIndicator'))
    def exportChildren(self, outfile, level, namespace_='', name_='Telephone', fromsubclass_=False):
        if self.TelephoneNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sTelephoneNumber>%s</%sTelephoneNumber>\n' % (namespace_, self.gds_format_string(quote_xml(self.TelephoneNumber).encode(ExternalEncoding), input_name='TelephoneNumber'), namespace_))
    def hasContent_(self):
        if (
            self.TelephoneNumber is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Telephone'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.TelephoneNumberType is not None and 'TelephoneNumberType' not in already_processed:
            already_processed.append('TelephoneNumberType')
            showIndent(outfile, level)
            outfile.write('TelephoneNumberType = "%s",\n' % (self.TelephoneNumberType,))
        if self.PrimaryTelephoneNumberIndicator is not None and 'PrimaryTelephoneNumberIndicator' not in already_processed:
            already_processed.append('PrimaryTelephoneNumberIndicator')
            showIndent(outfile, level)
            outfile.write('PrimaryTelephoneNumberIndicator = %s,\n' % (self.PrimaryTelephoneNumberIndicator,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TelephoneNumber is not None:
            showIndent(outfile, level)
            outfile.write('TelephoneNumber=%s,\n' % quote_python(self.TelephoneNumber).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TelephoneNumberType', node)
        if value is not None and 'TelephoneNumberType' not in already_processed:
            already_processed.append('TelephoneNumberType')
            self.TelephoneNumberType = value
            self.TelephoneNumberType = ' '.join(self.TelephoneNumberType.split())
            self.validate_TelephoneNumberType(self.TelephoneNumberType)    # validate type TelephoneNumberType
        value = find_attr_value_('PrimaryTelephoneNumberIndicator', node)
        if value is not None and 'PrimaryTelephoneNumberIndicator' not in already_processed:
            already_processed.append('PrimaryTelephoneNumberIndicator')
            if value in ('true', '1'):
                self.PrimaryTelephoneNumberIndicator = True
            elif value in ('false', '0'):
                self.PrimaryTelephoneNumberIndicator = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TelephoneNumber':
            TelephoneNumber_ = child_.text
            TelephoneNumber_ = self.gds_validate_string(TelephoneNumber_, node, 'TelephoneNumber')
            self.TelephoneNumber = TelephoneNumber_
            self.validate_TelephoneNumber(self.TelephoneNumber)    # validate type TelephoneNumber
# end class Telephone


class AcademicSubjectsType(GeneratedsSuper):
    """The teaching field(s) taught by an individual, for example
    English/Language Arts, Reading, Mathematics, Science, Social
    Sciences, etc."""
    subclass = None
    superclass = None
    def __init__(self, AcademicSubject=None):
        if AcademicSubject is None:
            self.AcademicSubject = []
        else:
            self.AcademicSubject = AcademicSubject
    def factory(*args_, **kwargs_):
        if AcademicSubjectsType.subclass:
            return AcademicSubjectsType.subclass(*args_, **kwargs_)
        else:
            return AcademicSubjectsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AcademicSubject(self): return self.AcademicSubject
    def set_AcademicSubject(self, AcademicSubject): self.AcademicSubject = AcademicSubject
    def add_AcademicSubject(self, value): self.AcademicSubject.append(value)
    def insert_AcademicSubject(self, index, value): self.AcademicSubject[index] = value
    def validate_AcademicSubjectType(self, value):
        # Validate type AcademicSubjectType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='AcademicSubjectsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AcademicSubjectsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AcademicSubjectsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AcademicSubjectsType', fromsubclass_=False):
        for AcademicSubject_ in self.AcademicSubject:
            showIndent(outfile, level)
            outfile.write('<%sAcademicSubject>%s</%sAcademicSubject>\n' % (namespace_, self.gds_format_string(quote_xml(AcademicSubject_).encode(ExternalEncoding), input_name='AcademicSubject'), namespace_))
    def hasContent_(self):
        if (
            self.AcademicSubject
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AcademicSubjectsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('AcademicSubject=[\n')
        level += 1
        for AcademicSubject_ in self.AcademicSubject:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AcademicSubject_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AcademicSubject':
            AcademicSubject_ = child_.text
            AcademicSubject_ = re_.sub(String_cleanup_pat_, " ", AcademicSubject_).strip()
            AcademicSubject_ = self.gds_validate_string(AcademicSubject_, node, 'AcademicSubject')
            self.AcademicSubject.append(AcademicSubject_)
            self.validate_AcademicSubjectType(self.AcademicSubject)    # validate type AcademicSubjectType
# end class AcademicSubjectsType


class CourseLevelCharacteristicsType(GeneratedsSuper):
    """Indication of the nature and difficulty of instruction: remedial,
    basic, honors, Ap, IB, Dual Credit, CTE. etc."""
    subclass = None
    superclass = None
    def __init__(self, CourseLevelCharacteristic=None):
        if CourseLevelCharacteristic is None:
            self.CourseLevelCharacteristic = []
        else:
            self.CourseLevelCharacteristic = CourseLevelCharacteristic
    def factory(*args_, **kwargs_):
        if CourseLevelCharacteristicsType.subclass:
            return CourseLevelCharacteristicsType.subclass(*args_, **kwargs_)
        else:
            return CourseLevelCharacteristicsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CourseLevelCharacteristic(self): return self.CourseLevelCharacteristic
    def set_CourseLevelCharacteristic(self, CourseLevelCharacteristic): self.CourseLevelCharacteristic = CourseLevelCharacteristic
    def add_CourseLevelCharacteristic(self, value): self.CourseLevelCharacteristic.append(value)
    def insert_CourseLevelCharacteristic(self, index, value): self.CourseLevelCharacteristic[index] = value
    def validate_CourseLevelCharacteristicItemType(self, value):
        # Validate type CourseLevelCharacteristicItemType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='CourseLevelCharacteristicsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CourseLevelCharacteristicsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CourseLevelCharacteristicsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CourseLevelCharacteristicsType', fromsubclass_=False):
        for CourseLevelCharacteristic_ in self.CourseLevelCharacteristic:
            showIndent(outfile, level)
            outfile.write('<%sCourseLevelCharacteristic>%s</%sCourseLevelCharacteristic>\n' % (namespace_, self.gds_format_string(quote_xml(CourseLevelCharacteristic_).encode(ExternalEncoding), input_name='CourseLevelCharacteristic'), namespace_))
    def hasContent_(self):
        if (
            self.CourseLevelCharacteristic
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CourseLevelCharacteristicsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('CourseLevelCharacteristic=[\n')
        level += 1
        for CourseLevelCharacteristic_ in self.CourseLevelCharacteristic:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(CourseLevelCharacteristic_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CourseLevelCharacteristic':
            CourseLevelCharacteristic_ = child_.text
            CourseLevelCharacteristic_ = re_.sub(String_cleanup_pat_, " ", CourseLevelCharacteristic_).strip()
            CourseLevelCharacteristic_ = self.gds_validate_string(CourseLevelCharacteristic_, node, 'CourseLevelCharacteristic')
            self.CourseLevelCharacteristic.append(CourseLevelCharacteristic_)
            self.validate_CourseLevelCharacteristicItemType(self.CourseLevelCharacteristic)    # validate type CourseLevelCharacteristicItemType
# end class CourseLevelCharacteristicsType


class CTEServicesType(GeneratedsSuper):
    """Special CTE program services provided to student."""
    subclass = None
    superclass = None
    def __init__(self, CTEService=None):
        if CTEService is None:
            self.CTEService = []
        else:
            self.CTEService = CTEService
    def factory(*args_, **kwargs_):
        if CTEServicesType.subclass:
            return CTEServicesType.subclass(*args_, **kwargs_)
        else:
            return CTEServicesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CTEService(self): return self.CTEService
    def set_CTEService(self, CTEService): self.CTEService = CTEService
    def add_CTEService(self, value): self.CTEService.append(value)
    def insert_CTEService(self, index, value): self.CTEService[index] = value
    def validate_CTEServiceItemType(self, value):
        # Validate type CTEServiceItemType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='CTEServicesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CTEServicesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CTEServicesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CTEServicesType', fromsubclass_=False):
        for CTEService_ in self.CTEService:
            showIndent(outfile, level)
            outfile.write('<%sCTEService>%s</%sCTEService>\n' % (namespace_, self.gds_format_string(quote_xml(CTEService_).encode(ExternalEncoding), input_name='CTEService'), namespace_))
    def hasContent_(self):
        if (
            self.CTEService
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CTEServicesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('CTEService=[\n')
        level += 1
        for CTEService_ in self.CTEService:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(CTEService_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CTEService':
            CTEService_ = child_.text
            CTEService_ = re_.sub(String_cleanup_pat_, " ", CTEService_).strip()
            CTEService_ = self.gds_validate_string(CTEService_, node, 'CTEService')
            self.CTEService.append(CTEService_)
            self.validate_CTEServiceItemType(self.CTEService)    # validate type CTEServiceItemType
# end class CTEServicesType


class EducationalPlansType(GeneratedsSuper):
    """The type of education plan(s) the student is following, if
    appropriate. For example: Special education Vocational"""
    subclass = None
    superclass = None
    def __init__(self, EducationalPlan=None):
        if EducationalPlan is None:
            self.EducationalPlan = []
        else:
            self.EducationalPlan = EducationalPlan
    def factory(*args_, **kwargs_):
        if EducationalPlansType.subclass:
            return EducationalPlansType.subclass(*args_, **kwargs_)
        else:
            return EducationalPlansType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EducationalPlan(self): return self.EducationalPlan
    def set_EducationalPlan(self, EducationalPlan): self.EducationalPlan = EducationalPlan
    def add_EducationalPlan(self, value): self.EducationalPlan.append(value)
    def insert_EducationalPlan(self, index, value): self.EducationalPlan[index] = value
    def validate_EducationalPlanItemType(self, value):
        # Validate type EducationalPlanItemType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='EducationalPlansType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EducationalPlansType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EducationalPlansType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EducationalPlansType', fromsubclass_=False):
        for EducationalPlan_ in self.EducationalPlan:
            showIndent(outfile, level)
            outfile.write('<%sEducationalPlan>%s</%sEducationalPlan>\n' % (namespace_, self.gds_format_string(quote_xml(EducationalPlan_).encode(ExternalEncoding), input_name='EducationalPlan'), namespace_))
    def hasContent_(self):
        if (
            self.EducationalPlan
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EducationalPlansType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('EducationalPlan=[\n')
        level += 1
        for EducationalPlan_ in self.EducationalPlan:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(EducationalPlan_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EducationalPlan':
            EducationalPlan_ = child_.text
            EducationalPlan_ = re_.sub(String_cleanup_pat_, " ", EducationalPlan_).strip()
            EducationalPlan_ = self.gds_validate_string(EducationalPlan_, node, 'EducationalPlan')
            self.EducationalPlan.append(EducationalPlan_)
            self.validate_EducationalPlanItemType(self.EducationalPlan)    # validate type EducationalPlanItemType
# end class EducationalPlansType


class GradeLevelsType(GeneratedsSuper):
    """The enumerated collection for specifying one or more grade levels."""
    subclass = None
    superclass = None
    def __init__(self, GradeLevel=None):
        if GradeLevel is None:
            self.GradeLevel = []
        else:
            self.GradeLevel = GradeLevel
    def factory(*args_, **kwargs_):
        if GradeLevelsType.subclass:
            return GradeLevelsType.subclass(*args_, **kwargs_)
        else:
            return GradeLevelsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GradeLevel(self): return self.GradeLevel
    def set_GradeLevel(self, GradeLevel): self.GradeLevel = GradeLevel
    def add_GradeLevel(self, value): self.GradeLevel.append(value)
    def insert_GradeLevel(self, index, value): self.GradeLevel[index] = value
    def validate_GradeLevelType(self, value):
        # Validate type GradeLevelType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='GradeLevelsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GradeLevelsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GradeLevelsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GradeLevelsType', fromsubclass_=False):
        for GradeLevel_ in self.GradeLevel:
            showIndent(outfile, level)
            outfile.write('<%sGradeLevel>%s</%sGradeLevel>\n' % (namespace_, self.gds_format_string(quote_xml(GradeLevel_).encode(ExternalEncoding), input_name='GradeLevel'), namespace_))
    def hasContent_(self):
        if (
            self.GradeLevel
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GradeLevelsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('GradeLevel=[\n')
        level += 1
        for GradeLevel_ in self.GradeLevel:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(GradeLevel_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GradeLevel':
            GradeLevel_ = child_.text
            GradeLevel_ = re_.sub(String_cleanup_pat_, " ", GradeLevel_).strip()
            GradeLevel_ = self.gds_validate_string(GradeLevel_, node, 'GradeLevel')
            self.GradeLevel.append(GradeLevel_)
            self.validate_GradeLevelType(self.GradeLevel)    # validate type GradeLevelType
# end class GradeLevelsType


class LanguagesType(GeneratedsSuper):
    """Language the individual uses to communicate."""
    subclass = None
    superclass = None
    def __init__(self, Language=None):
        if Language is None:
            self.Language = []
        else:
            self.Language = Language
    def factory(*args_, **kwargs_):
        if LanguagesType.subclass:
            return LanguagesType.subclass(*args_, **kwargs_)
        else:
            return LanguagesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Language(self): return self.Language
    def set_Language(self, Language): self.Language = Language
    def add_Language(self, value): self.Language.append(value)
    def insert_Language(self, index, value): self.Language[index] = value
    def validate_LanguageItemType(self, value):
        # Validate type LanguageItemType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='LanguagesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LanguagesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LanguagesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LanguagesType', fromsubclass_=False):
        for Language_ in self.Language:
            showIndent(outfile, level)
            outfile.write('<%sLanguage>%s</%sLanguage>\n' % (namespace_, self.gds_format_string(quote_xml(Language_).encode(ExternalEncoding), input_name='Language'), namespace_))
    def hasContent_(self):
        if (
            self.Language
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LanguagesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Language=[\n')
        level += 1
        for Language_ in self.Language:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Language_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Language':
            Language_ = child_.text
            Language_ = re_.sub(String_cleanup_pat_, " ", Language_).strip()
            Language_ = self.gds_validate_string(Language_, node, 'Language')
            self.Language.append(Language_)
            self.validate_LanguageItemType(self.Language)    # validate type LanguageItemType
# end class LanguagesType


class LinguisticAccommodationsType(GeneratedsSuper):
    """Linguistic accommodations used with the student for the test."""
    subclass = None
    superclass = None
    def __init__(self, LinguisticAccommodation=None):
        if LinguisticAccommodation is None:
            self.LinguisticAccommodation = []
        else:
            self.LinguisticAccommodation = LinguisticAccommodation
    def factory(*args_, **kwargs_):
        if LinguisticAccommodationsType.subclass:
            return LinguisticAccommodationsType.subclass(*args_, **kwargs_)
        else:
            return LinguisticAccommodationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LinguisticAccommodation(self): return self.LinguisticAccommodation
    def set_LinguisticAccommodation(self, LinguisticAccommodation): self.LinguisticAccommodation = LinguisticAccommodation
    def add_LinguisticAccommodation(self, value): self.LinguisticAccommodation.append(value)
    def insert_LinguisticAccommodation(self, index, value): self.LinguisticAccommodation[index] = value
    def validate_LinguisticAccommodationItemType(self, value):
        # Validate type LinguisticAccommodationItemType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='LinguisticAccommodationsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinguisticAccommodationsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinguisticAccommodationsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LinguisticAccommodationsType', fromsubclass_=False):
        for LinguisticAccommodation_ in self.LinguisticAccommodation:
            showIndent(outfile, level)
            outfile.write('<%sLinguisticAccommodation>%s</%sLinguisticAccommodation>\n' % (namespace_, self.gds_format_string(quote_xml(LinguisticAccommodation_).encode(ExternalEncoding), input_name='LinguisticAccommodation'), namespace_))
    def hasContent_(self):
        if (
            self.LinguisticAccommodation
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LinguisticAccommodationsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('LinguisticAccommodation=[\n')
        level += 1
        for LinguisticAccommodation_ in self.LinguisticAccommodation:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(LinguisticAccommodation_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LinguisticAccommodation':
            LinguisticAccommodation_ = child_.text
            LinguisticAccommodation_ = re_.sub(String_cleanup_pat_, " ", LinguisticAccommodation_).strip()
            LinguisticAccommodation_ = self.gds_validate_string(LinguisticAccommodation_, node, 'LinguisticAccommodation')
            self.LinguisticAccommodation.append(LinguisticAccommodation_)
            self.validate_LinguisticAccommodationItemType(self.LinguisticAccommodation)    # validate type LinguisticAccommodationItemType
# end class LinguisticAccommodationsType


class MeetingDaysType(GeneratedsSuper):
    """The day(s) of the week (e.g., Monday, Wednesday) that the class
    meets or an indication that a class meets "out-of-school" or
    "self-paced"."""
    subclass = None
    superclass = None
    def __init__(self, MeetingDay=None):
        if MeetingDay is None:
            self.MeetingDay = []
        else:
            self.MeetingDay = MeetingDay
    def factory(*args_, **kwargs_):
        if MeetingDaysType.subclass:
            return MeetingDaysType.subclass(*args_, **kwargs_)
        else:
            return MeetingDaysType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MeetingDay(self): return self.MeetingDay
    def set_MeetingDay(self, MeetingDay): self.MeetingDay = MeetingDay
    def add_MeetingDay(self, value): self.MeetingDay.append(value)
    def insert_MeetingDay(self, index, value): self.MeetingDay[index] = value
    def validate_MeetingDayItemType(self, value):
        # Validate type MeetingDayItemType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='MeetingDaysType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeetingDaysType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MeetingDaysType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MeetingDaysType', fromsubclass_=False):
        for MeetingDay_ in self.MeetingDay:
            showIndent(outfile, level)
            outfile.write('<%sMeetingDay>%s</%sMeetingDay>\n' % (namespace_, self.gds_format_string(quote_xml(MeetingDay_).encode(ExternalEncoding), input_name='MeetingDay'), namespace_))
    def hasContent_(self):
        if (
            self.MeetingDay
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MeetingDaysType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('MeetingDay=[\n')
        level += 1
        for MeetingDay_ in self.MeetingDay:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MeetingDay_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeetingDay':
            MeetingDay_ = child_.text
            MeetingDay_ = re_.sub(String_cleanup_pat_, " ", MeetingDay_).strip()
            MeetingDay_ = self.gds_validate_string(MeetingDay_, node, 'MeetingDay')
            self.MeetingDay.append(MeetingDay_)
            self.validate_MeetingDayItemType(self.MeetingDay)    # validate type MeetingDayItemType
# end class MeetingDaysType


class RaceType(GeneratedsSuper):
    """The general racial category which most clearly reflects the
    individual's recognition of his or her community or with which
    the individual most identifies."""
    subclass = None
    superclass = None
    def __init__(self, RacialCategory=None):
        if RacialCategory is None:
            self.RacialCategory = []
        else:
            self.RacialCategory = RacialCategory
    def factory(*args_, **kwargs_):
        if RaceType.subclass:
            return RaceType.subclass(*args_, **kwargs_)
        else:
            return RaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RacialCategory(self): return self.RacialCategory
    def set_RacialCategory(self, RacialCategory): self.RacialCategory = RacialCategory
    def add_RacialCategory(self, value): self.RacialCategory.append(value)
    def insert_RacialCategory(self, index, value): self.RacialCategory[index] = value
    def validate_RaceItemType(self, value):
        # Validate type RaceItemType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='RaceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RaceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RaceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RaceType', fromsubclass_=False):
        for RacialCategory_ in self.RacialCategory:
            showIndent(outfile, level)
            outfile.write('<%sRacialCategory>%s</%sRacialCategory>\n' % (namespace_, self.gds_format_string(quote_xml(RacialCategory_).encode(ExternalEncoding), input_name='RacialCategory'), namespace_))
    def hasContent_(self):
        if (
            self.RacialCategory
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RaceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('RacialCategory=[\n')
        level += 1
        for RacialCategory_ in self.RacialCategory:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(RacialCategory_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RacialCategory':
            RacialCategory_ = child_.text
            RacialCategory_ = re_.sub(String_cleanup_pat_, " ", RacialCategory_).strip()
            RacialCategory_ = self.gds_validate_string(RacialCategory_, node, 'RacialCategory')
            self.RacialCategory.append(RacialCategory_)
            self.validate_RaceItemType(self.RacialCategory)    # validate type RaceItemType
# end class RaceType


class RestraintEventReasonsType(GeneratedsSuper):
    """The categorization of the circumstances or reason for the restraint."""
    subclass = None
    superclass = None
    def __init__(self, RetraintEventReason=None):
        if RetraintEventReason is None:
            self.RetraintEventReason = []
        else:
            self.RetraintEventReason = RetraintEventReason
    def factory(*args_, **kwargs_):
        if RestraintEventReasonsType.subclass:
            return RestraintEventReasonsType.subclass(*args_, **kwargs_)
        else:
            return RestraintEventReasonsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RetraintEventReason(self): return self.RetraintEventReason
    def set_RetraintEventReason(self, RetraintEventReason): self.RetraintEventReason = RetraintEventReason
    def add_RetraintEventReason(self, value): self.RetraintEventReason.append(value)
    def insert_RetraintEventReason(self, index, value): self.RetraintEventReason[index] = value
    def validate_RestraintEventReasonItemType(self, value):
        # Validate type RestraintEventReasonItemType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='RestraintEventReasonsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RestraintEventReasonsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RestraintEventReasonsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RestraintEventReasonsType', fromsubclass_=False):
        for RetraintEventReason_ in self.RetraintEventReason:
            showIndent(outfile, level)
            outfile.write('<%sRetraintEventReason>%s</%sRetraintEventReason>\n' % (namespace_, self.gds_format_string(quote_xml(RetraintEventReason_).encode(ExternalEncoding), input_name='RetraintEventReason'), namespace_))
    def hasContent_(self):
        if (
            self.RetraintEventReason
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RestraintEventReasonsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('RetraintEventReason=[\n')
        level += 1
        for RetraintEventReason_ in self.RetraintEventReason:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(RetraintEventReason_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RetraintEventReason':
            RetraintEventReason_ = child_.text
            RetraintEventReason_ = re_.sub(String_cleanup_pat_, " ", RetraintEventReason_).strip()
            RetraintEventReason_ = self.gds_validate_string(RetraintEventReason_, node, 'RetraintEventReason')
            self.RetraintEventReason.append(RetraintEventReason_)
            self.validate_RestraintEventReasonItemType(self.RetraintEventReason)    # validate type RestraintEventReasonItemType
# end class RestraintEventReasonsType


class SchoolCategoriesType(GeneratedsSuper):
    """The one or more categories of school. For example: High School,
    Middle School, and/or Elementary School."""
    subclass = None
    superclass = None
    def __init__(self, SchoolCategory=None):
        if SchoolCategory is None:
            self.SchoolCategory = []
        else:
            self.SchoolCategory = SchoolCategory
    def factory(*args_, **kwargs_):
        if SchoolCategoriesType.subclass:
            return SchoolCategoriesType.subclass(*args_, **kwargs_)
        else:
            return SchoolCategoriesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SchoolCategory(self): return self.SchoolCategory
    def set_SchoolCategory(self, SchoolCategory): self.SchoolCategory = SchoolCategory
    def add_SchoolCategory(self, value): self.SchoolCategory.append(value)
    def insert_SchoolCategory(self, index, value): self.SchoolCategory[index] = value
    def validate_SchoolCategoryItemType(self, value):
        # Validate type SchoolCategoryItemType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='SchoolCategoriesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SchoolCategoriesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SchoolCategoriesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SchoolCategoriesType', fromsubclass_=False):
        for SchoolCategory_ in self.SchoolCategory:
            showIndent(outfile, level)
            outfile.write('<%sSchoolCategory>%s</%sSchoolCategory>\n' % (namespace_, self.gds_format_string(quote_xml(SchoolCategory_).encode(ExternalEncoding), input_name='SchoolCategory'), namespace_))
    def hasContent_(self):
        if (
            self.SchoolCategory
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SchoolCategoriesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('SchoolCategory=[\n')
        level += 1
        for SchoolCategory_ in self.SchoolCategory:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(SchoolCategory_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SchoolCategory':
            SchoolCategory_ = child_.text
            SchoolCategory_ = re_.sub(String_cleanup_pat_, " ", SchoolCategory_).strip()
            SchoolCategory_ = self.gds_validate_string(SchoolCategory_, node, 'SchoolCategory')
            self.SchoolCategory.append(SchoolCategory_)
            self.validate_SchoolCategoryItemType(self.SchoolCategory)    # validate type SchoolCategoryItemType
# end class SchoolCategoriesType


class Section504DisabilitiesType(GeneratedsSuper):
    """A categorization o fthe disabilities associated with a student
    pursuant to Section 504."""
    subclass = None
    superclass = None
    def __init__(self, Section504Disability=None):
        if Section504Disability is None:
            self.Section504Disability = []
        else:
            self.Section504Disability = Section504Disability
    def factory(*args_, **kwargs_):
        if Section504DisabilitiesType.subclass:
            return Section504DisabilitiesType.subclass(*args_, **kwargs_)
        else:
            return Section504DisabilitiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Section504Disability(self): return self.Section504Disability
    def set_Section504Disability(self, Section504Disability): self.Section504Disability = Section504Disability
    def add_Section504Disability(self, value): self.Section504Disability.append(value)
    def insert_Section504Disability(self, index, value): self.Section504Disability[index] = value
    def validate_Section504DisabilityItemType(self, value):
        # Validate type Section504DisabilityItemType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='Section504DisabilitiesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Section504DisabilitiesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Section504DisabilitiesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Section504DisabilitiesType', fromsubclass_=False):
        for Section504Disability_ in self.Section504Disability:
            showIndent(outfile, level)
            outfile.write('<%sSection504Disability>%s</%sSection504Disability>\n' % (namespace_, self.gds_format_string(quote_xml(Section504Disability_).encode(ExternalEncoding), input_name='Section504Disability'), namespace_))
    def hasContent_(self):
        if (
            self.Section504Disability
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Section504DisabilitiesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Section504Disability=[\n')
        level += 1
        for Section504Disability_ in self.Section504Disability:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Section504Disability_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Section504Disability':
            Section504Disability_ = child_.text
            Section504Disability_ = re_.sub(String_cleanup_pat_, " ", Section504Disability_).strip()
            Section504Disability_ = self.gds_validate_string(Section504Disability_, node, 'Section504Disability')
            self.Section504Disability.append(Section504Disability_)
            self.validate_Section504DisabilityItemType(self.Section504Disability)    # validate type Section504DisabilityItemType
# end class Section504DisabilitiesType


class SpecialAccommodationsType(GeneratedsSuper):
    """The specific type of special variation used in how an examination is
    presented, how it is administered, or how the test taker is
    allowed to respond. This generally refers to changes that do not
    substantially alter what the examination measures. The proper
    use of accommodations does not substantially change academic
    level or performance criteria."""
    subclass = None
    superclass = None
    def __init__(self, SpecialAccommodation=None):
        if SpecialAccommodation is None:
            self.SpecialAccommodation = []
        else:
            self.SpecialAccommodation = SpecialAccommodation
    def factory(*args_, **kwargs_):
        if SpecialAccommodationsType.subclass:
            return SpecialAccommodationsType.subclass(*args_, **kwargs_)
        else:
            return SpecialAccommodationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SpecialAccommodation(self): return self.SpecialAccommodation
    def set_SpecialAccommodation(self, SpecialAccommodation): self.SpecialAccommodation = SpecialAccommodation
    def add_SpecialAccommodation(self, value): self.SpecialAccommodation.append(value)
    def insert_SpecialAccommodation(self, index, value): self.SpecialAccommodation[index] = value
    def validate_SpecialAccommodationItemType(self, value):
        # Validate type SpecialAccommodationItemType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='SpecialAccommodationsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpecialAccommodationsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SpecialAccommodationsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SpecialAccommodationsType', fromsubclass_=False):
        for SpecialAccommodation_ in self.SpecialAccommodation:
            showIndent(outfile, level)
            outfile.write('<%sSpecialAccommodation>%s</%sSpecialAccommodation>\n' % (namespace_, self.gds_format_string(quote_xml(SpecialAccommodation_).encode(ExternalEncoding), input_name='SpecialAccommodation'), namespace_))
    def hasContent_(self):
        if (
            self.SpecialAccommodation
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SpecialAccommodationsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('SpecialAccommodation=[\n')
        level += 1
        for SpecialAccommodation_ in self.SpecialAccommodation:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(SpecialAccommodation_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SpecialAccommodation':
            SpecialAccommodation_ = child_.text
            SpecialAccommodation_ = re_.sub(String_cleanup_pat_, " ", SpecialAccommodation_).strip()
            SpecialAccommodation_ = self.gds_validate_string(SpecialAccommodation_, node, 'SpecialAccommodation')
            self.SpecialAccommodation.append(SpecialAccommodation_)
            self.validate_SpecialAccommodationItemType(self.SpecialAccommodation)    # validate type SpecialAccommodationItemType
# end class SpecialAccommodationsType


class SpecialEdServicesType(GeneratedsSuper):
    """Special education services provided to student"""
    subclass = None
    superclass = None
    def __init__(self, SpecialEdService=None):
        if SpecialEdService is None:
            self.SpecialEdService = []
        else:
            self.SpecialEdService = SpecialEdService
    def factory(*args_, **kwargs_):
        if SpecialEdServicesType.subclass:
            return SpecialEdServicesType.subclass(*args_, **kwargs_)
        else:
            return SpecialEdServicesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SpecialEdService(self): return self.SpecialEdService
    def set_SpecialEdService(self, SpecialEdService): self.SpecialEdService = SpecialEdService
    def add_SpecialEdService(self, value): self.SpecialEdService.append(value)
    def insert_SpecialEdService(self, index, value): self.SpecialEdService[index] = value
    def validate_SpecialEdServiceItemType(self, value):
        # Validate type SpecialEdServiceItemType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='SpecialEdServicesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpecialEdServicesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SpecialEdServicesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SpecialEdServicesType', fromsubclass_=False):
        for SpecialEdService_ in self.SpecialEdService:
            showIndent(outfile, level)
            outfile.write('<%sSpecialEdService>%s</%sSpecialEdService>\n' % (namespace_, self.gds_format_string(quote_xml(SpecialEdService_).encode(ExternalEncoding), input_name='SpecialEdService'), namespace_))
    def hasContent_(self):
        if (
            self.SpecialEdService
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SpecialEdServicesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('SpecialEdService=[\n')
        level += 1
        for SpecialEdService_ in self.SpecialEdService:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(SpecialEdService_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SpecialEdService':
            SpecialEdService_ = child_.text
            SpecialEdService_ = re_.sub(String_cleanup_pat_, " ", SpecialEdService_).strip()
            SpecialEdService_ = self.gds_validate_string(SpecialEdService_, node, 'SpecialEdService')
            self.SpecialEdService.append(SpecialEdService_)
            self.validate_SpecialEdServiceItemType(self.SpecialEdService)    # validate type SpecialEdServiceItemType
# end class SpecialEdServicesType


class TitleIPartAServicesType(GeneratedsSuper):
    """An indication of what Title I supplemental educational services
    received by students within the school during the school year."""
    subclass = None
    superclass = None
    def __init__(self, TitleIPartAService=None):
        if TitleIPartAService is None:
            self.TitleIPartAService = []
        else:
            self.TitleIPartAService = TitleIPartAService
    def factory(*args_, **kwargs_):
        if TitleIPartAServicesType.subclass:
            return TitleIPartAServicesType.subclass(*args_, **kwargs_)
        else:
            return TitleIPartAServicesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TitleIPartAService(self): return self.TitleIPartAService
    def set_TitleIPartAService(self, TitleIPartAService): self.TitleIPartAService = TitleIPartAService
    def add_TitleIPartAService(self, value): self.TitleIPartAService.append(value)
    def insert_TitleIPartAService(self, index, value): self.TitleIPartAService[index] = value
    def validate_TitleIPartAServiceItemType(self, value):
        # Validate type TitleIPartAServiceItemType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='TitleIPartAServicesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TitleIPartAServicesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TitleIPartAServicesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TitleIPartAServicesType', fromsubclass_=False):
        for TitleIPartAService_ in self.TitleIPartAService:
            showIndent(outfile, level)
            outfile.write('<%sTitleIPartAService>%s</%sTitleIPartAService>\n' % (namespace_, self.gds_format_string(quote_xml(TitleIPartAService_).encode(ExternalEncoding), input_name='TitleIPartAService'), namespace_))
    def hasContent_(self):
        if (
            self.TitleIPartAService
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TitleIPartAServicesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('TitleIPartAService=[\n')
        level += 1
        for TitleIPartAService_ in self.TitleIPartAService:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(TitleIPartAService_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TitleIPartAService':
            TitleIPartAService_ = child_.text
            TitleIPartAService_ = re_.sub(String_cleanup_pat_, " ", TitleIPartAService_).strip()
            TitleIPartAService_ = self.gds_validate_string(TitleIPartAService_, node, 'TitleIPartAService')
            self.TitleIPartAService.append(TitleIPartAService_)
            self.validate_TitleIPartAServiceItemType(self.TitleIPartAService)    # validate type TitleIPartAServiceItemType
# end class TitleIPartAServicesType


class TitleIPartASupportServicesType(GeneratedsSuper):
    """The type of support services offered to students in Title I
    programs."""
    subclass = None
    superclass = None
    def __init__(self, TitleIPartASupportService=None):
        if TitleIPartASupportService is None:
            self.TitleIPartASupportService = []
        else:
            self.TitleIPartASupportService = TitleIPartASupportService
    def factory(*args_, **kwargs_):
        if TitleIPartASupportServicesType.subclass:
            return TitleIPartASupportServicesType.subclass(*args_, **kwargs_)
        else:
            return TitleIPartASupportServicesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TitleIPartASupportService(self): return self.TitleIPartASupportService
    def set_TitleIPartASupportService(self, TitleIPartASupportService): self.TitleIPartASupportService = TitleIPartASupportService
    def add_TitleIPartASupportService(self, value): self.TitleIPartASupportService.append(value)
    def insert_TitleIPartASupportService(self, index, value): self.TitleIPartASupportService[index] = value
    def validate_TitleIPartASupportServiceItemType(self, value):
        # Validate type TitleIPartASupportServiceItemType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='TitleIPartASupportServicesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TitleIPartASupportServicesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TitleIPartASupportServicesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TitleIPartASupportServicesType', fromsubclass_=False):
        for TitleIPartASupportService_ in self.TitleIPartASupportService:
            showIndent(outfile, level)
            outfile.write('<%sTitleIPartASupportService>%s</%sTitleIPartASupportService>\n' % (namespace_, self.gds_format_string(quote_xml(TitleIPartASupportService_).encode(ExternalEncoding), input_name='TitleIPartASupportService'), namespace_))
    def hasContent_(self):
        if (
            self.TitleIPartASupportService
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TitleIPartASupportServicesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('TitleIPartASupportService=[\n')
        level += 1
        for TitleIPartASupportService_ in self.TitleIPartASupportService:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(TitleIPartASupportService_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TitleIPartASupportService':
            TitleIPartASupportService_ = child_.text
            TitleIPartASupportService_ = re_.sub(String_cleanup_pat_, " ", TitleIPartASupportService_).strip()
            TitleIPartASupportService_ = self.gds_validate_string(TitleIPartASupportService_, node, 'TitleIPartASupportService')
            self.TitleIPartASupportService.append(TitleIPartASupportService_)
            self.validate_TitleIPartASupportServiceItemType(self.TitleIPartASupportService)    # validate type TitleIPartASupportServiceItemType
# end class TitleIPartASupportServicesType


class WeaponsType(GeneratedsSuper):
    """Identifies the type of weapon used during an incident."""
    subclass = None
    superclass = None
    def __init__(self, Weapon=None):
        if Weapon is None:
            self.Weapon = []
        else:
            self.Weapon = Weapon
    def factory(*args_, **kwargs_):
        if WeaponsType.subclass:
            return WeaponsType.subclass(*args_, **kwargs_)
        else:
            return WeaponsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Weapon(self): return self.Weapon
    def set_Weapon(self, Weapon): self.Weapon = Weapon
    def add_Weapon(self, value): self.Weapon.append(value)
    def insert_Weapon(self, index, value): self.Weapon[index] = value
    def validate_WeaponItemType(self, value):
        # Validate type WeaponItemType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='WeaponsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WeaponsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WeaponsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='WeaponsType', fromsubclass_=False):
        for Weapon_ in self.Weapon:
            showIndent(outfile, level)
            outfile.write('<%sWeapon>%s</%sWeapon>\n' % (namespace_, self.gds_format_string(quote_xml(Weapon_).encode(ExternalEncoding), input_name='Weapon'), namespace_))
    def hasContent_(self):
        if (
            self.Weapon
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='WeaponsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Weapon=[\n')
        level += 1
        for Weapon_ in self.Weapon:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Weapon_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Weapon':
            Weapon_ = child_.text
            Weapon_ = re_.sub(String_cleanup_pat_, " ", Weapon_).strip()
            Weapon_ = self.gds_validate_string(Weapon_, node, 'Weapon')
            self.Weapon.append(Weapon_)
            self.validate_WeaponItemType(self.Weapon)    # validate type WeaponItemType
# end class WeaponsType


class StudentESLProgramAssociation(StudentProgramAssociation):
    """This association is the StudentProgramAssociation specialization
    particular for ESL programs. The StudentProgramAssociation
    represents the program(s) that a student participates in or
    receives services from."""
    subclass = None
    superclass = StudentProgramAssociation
    def __init__(self, StudentReference=None, ProgramReference=None, BeginDate=None, EndDate=None, ReasonExited=None, EducationOrganizationReference=None, ESLProgram=None):
        super(StudentESLProgramAssociation, self).__init__(StudentReference, ProgramReference, BeginDate, EndDate, ReasonExited, EducationOrganizationReference, )
        self.ESLProgram = ESLProgram
    def factory(*args_, **kwargs_):
        if StudentESLProgramAssociation.subclass:
            return StudentESLProgramAssociation.subclass(*args_, **kwargs_)
        else:
            return StudentESLProgramAssociation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ESLProgram(self): return self.ESLProgram
    def set_ESLProgram(self, ESLProgram): self.ESLProgram = ESLProgram
    def validate_ESLProgramType(self, value):
        # Validate type ESLProgramType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='StudentESLProgramAssociation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StudentESLProgramAssociation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StudentESLProgramAssociation'):
        super(StudentESLProgramAssociation, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StudentESLProgramAssociation')
    def exportChildren(self, outfile, level, namespace_='', name_='StudentESLProgramAssociation', fromsubclass_=False):
        super(StudentESLProgramAssociation, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.ESLProgram is not None:
            showIndent(outfile, level)
            outfile.write('<%sESLProgram>%s</%sESLProgram>\n' % (namespace_, self.gds_format_string(quote_xml(self.ESLProgram).encode(ExternalEncoding), input_name='ESLProgram'), namespace_))
    def hasContent_(self):
        if (
            self.ESLProgram is not None or
            super(StudentESLProgramAssociation, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StudentESLProgramAssociation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StudentESLProgramAssociation, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StudentESLProgramAssociation, self).exportLiteralChildren(outfile, level, name_)
        if self.ESLProgram is not None:
            showIndent(outfile, level)
            outfile.write('ESLProgram=%s,\n' % quote_python(self.ESLProgram).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(StudentESLProgramAssociation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ESLProgram':
            ESLProgram_ = child_.text
            ESLProgram_ = re_.sub(String_cleanup_pat_, " ", ESLProgram_).strip()
            ESLProgram_ = self.gds_validate_string(ESLProgram_, node, 'ESLProgram')
            self.ESLProgram = ESLProgram_
            self.validate_ESLProgramType(self.ESLProgram)    # validate type ESLProgramType
        super(StudentESLProgramAssociation, self).buildChildren(child_, node, nodeName_, True)
# end class StudentESLProgramAssociation


class StudentCTEProgramAssociation(StudentProgramAssociation):
    """This association represents the career and technical education (CTE)
    program that a student participates in. The association is an
    extension of the StudentProgramAssociation particular for CTE
    programs."""
    subclass = None
    superclass = StudentProgramAssociation
    def __init__(self, StudentReference=None, ProgramReference=None, BeginDate=None, EndDate=None, ReasonExited=None, EducationOrganizationReference=None, CTEProgram=None, CTEServices=None, CIPCode=None):
        super(StudentCTEProgramAssociation, self).__init__(StudentReference, ProgramReference, BeginDate, EndDate, ReasonExited, EducationOrganizationReference, )
        self.CTEProgram = CTEProgram
        if CTEServices is None:
            self.CTEServices = []
        else:
            self.CTEServices = CTEServices
        self.CIPCode = CIPCode
    def factory(*args_, **kwargs_):
        if StudentCTEProgramAssociation.subclass:
            return StudentCTEProgramAssociation.subclass(*args_, **kwargs_)
        else:
            return StudentCTEProgramAssociation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CTEProgram(self): return self.CTEProgram
    def set_CTEProgram(self, CTEProgram): self.CTEProgram = CTEProgram
    def validate_CTEProgramType(self, value):
        # Validate type CTEProgramType, a restriction on xs:token.
        pass
    def get_CTEServices(self): return self.CTEServices
    def set_CTEServices(self, CTEServices): self.CTEServices = CTEServices
    def add_CTEServices(self, value): self.CTEServices.append(value)
    def insert_CTEServices(self, index, value): self.CTEServices[index] = value
    def get_CIPCode(self): return self.CIPCode
    def set_CIPCode(self, CIPCode): self.CIPCode = CIPCode
    def validate_CIPCode(self, value):
        # Validate type CIPCode, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='StudentCTEProgramAssociation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StudentCTEProgramAssociation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StudentCTEProgramAssociation'):
        super(StudentCTEProgramAssociation, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StudentCTEProgramAssociation')
    def exportChildren(self, outfile, level, namespace_='', name_='StudentCTEProgramAssociation', fromsubclass_=False):
        super(StudentCTEProgramAssociation, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.CTEProgram is not None:
            showIndent(outfile, level)
            outfile.write('<%sCTEProgram>%s</%sCTEProgram>\n' % (namespace_, self.gds_format_string(quote_xml(self.CTEProgram).encode(ExternalEncoding), input_name='CTEProgram'), namespace_))
        for CTEServices_ in self.CTEServices:
            CTEServices_.export(outfile, level, namespace_, name_='CTEServices')
        if self.CIPCode is not None:
            showIndent(outfile, level)
            outfile.write('<%sCIPCode>%s</%sCIPCode>\n' % (namespace_, self.gds_format_string(quote_xml(self.CIPCode).encode(ExternalEncoding), input_name='CIPCode'), namespace_))
    def hasContent_(self):
        if (
            self.CTEProgram is not None or
            self.CTEServices or
            self.CIPCode is not None or
            super(StudentCTEProgramAssociation, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StudentCTEProgramAssociation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StudentCTEProgramAssociation, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StudentCTEProgramAssociation, self).exportLiteralChildren(outfile, level, name_)
        if self.CTEProgram is not None:
            showIndent(outfile, level)
            outfile.write('CTEProgram=%s,\n' % quote_python(self.CTEProgram).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('CTEServices=[\n')
        level += 1
        for CTEServices_ in self.CTEServices:
            showIndent(outfile, level)
            outfile.write('model_.CTEServicesType(\n')
            CTEServices_.exportLiteral(outfile, level, name_='CTEServicesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.CIPCode is not None:
            showIndent(outfile, level)
            outfile.write('CIPCode=%s,\n' % quote_python(self.CIPCode).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(StudentCTEProgramAssociation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CTEProgram':
            CTEProgram_ = child_.text
            CTEProgram_ = re_.sub(String_cleanup_pat_, " ", CTEProgram_).strip()
            CTEProgram_ = self.gds_validate_string(CTEProgram_, node, 'CTEProgram')
            self.CTEProgram = CTEProgram_
            self.validate_CTEProgramType(self.CTEProgram)    # validate type CTEProgramType
        elif nodeName_ == 'CTEServices':
            obj_ = CTEServicesType.factory()
            obj_.build(child_)
            self.CTEServices.append(obj_)
        elif nodeName_ == 'CIPCode':
            CIPCode_ = child_.text
            CIPCode_ = self.gds_validate_string(CIPCode_, node, 'CIPCode')
            self.CIPCode = CIPCode_
            self.validate_CIPCode(self.CIPCode)    # validate type CIPCode
        super(StudentCTEProgramAssociation, self).buildChildren(child_, node, nodeName_, True)
# end class StudentCTEProgramAssociation


class StudentBilingualProgramAssociation(StudentProgramAssociation):
    """This association is the StudentProgramAssociation specialization
    particular for Bilingual programs. The StudentProgramAssociation
    represents the program(s) that a student participates in or
    receives services from."""
    subclass = None
    superclass = StudentProgramAssociation
    def __init__(self, StudentReference=None, ProgramReference=None, BeginDate=None, EndDate=None, ReasonExited=None, EducationOrganizationReference=None, BilingualProgram=None):
        super(StudentBilingualProgramAssociation, self).__init__(StudentReference, ProgramReference, BeginDate, EndDate, ReasonExited, EducationOrganizationReference, )
        self.BilingualProgram = BilingualProgram
    def factory(*args_, **kwargs_):
        if StudentBilingualProgramAssociation.subclass:
            return StudentBilingualProgramAssociation.subclass(*args_, **kwargs_)
        else:
            return StudentBilingualProgramAssociation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BilingualProgram(self): return self.BilingualProgram
    def set_BilingualProgram(self, BilingualProgram): self.BilingualProgram = BilingualProgram
    def validate_BilingualProgramType(self, value):
        # Validate type BilingualProgramType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='StudentBilingualProgramAssociation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StudentBilingualProgramAssociation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StudentBilingualProgramAssociation'):
        super(StudentBilingualProgramAssociation, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StudentBilingualProgramAssociation')
    def exportChildren(self, outfile, level, namespace_='', name_='StudentBilingualProgramAssociation', fromsubclass_=False):
        super(StudentBilingualProgramAssociation, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.BilingualProgram is not None:
            showIndent(outfile, level)
            outfile.write('<%sBilingualProgram>%s</%sBilingualProgram>\n' % (namespace_, self.gds_format_string(quote_xml(self.BilingualProgram).encode(ExternalEncoding), input_name='BilingualProgram'), namespace_))
    def hasContent_(self):
        if (
            self.BilingualProgram is not None or
            super(StudentBilingualProgramAssociation, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StudentBilingualProgramAssociation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StudentBilingualProgramAssociation, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StudentBilingualProgramAssociation, self).exportLiteralChildren(outfile, level, name_)
        if self.BilingualProgram is not None:
            showIndent(outfile, level)
            outfile.write('BilingualProgram=%s,\n' % quote_python(self.BilingualProgram).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(StudentBilingualProgramAssociation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BilingualProgram':
            BilingualProgram_ = child_.text
            BilingualProgram_ = re_.sub(String_cleanup_pat_, " ", BilingualProgram_).strip()
            BilingualProgram_ = self.gds_validate_string(BilingualProgram_, node, 'BilingualProgram')
            self.BilingualProgram = BilingualProgram_
            self.validate_BilingualProgramType(self.BilingualProgram)    # validate type BilingualProgramType
        super(StudentBilingualProgramAssociation, self).buildChildren(child_, node, nodeName_, True)
# end class StudentBilingualProgramAssociation


class StudentObjectiveAssessment(ComplexObjectType):
    """The raw score for the objective assessment for the student."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, RawScoreResult=None, ScoreResults=None, RatingStandardsOutcome=None, StudentTestAssessmentReference=None, ObjectiveAssessmentReference=None):
        super(StudentObjectiveAssessment, self).__init__(id, )
        self.RawScoreResult = RawScoreResult
        if ScoreResults is None:
            self.ScoreResults = []
        else:
            self.ScoreResults = ScoreResults
        if RatingStandardsOutcome is None:
            self.RatingStandardsOutcome = []
        else:
            self.RatingStandardsOutcome = RatingStandardsOutcome
        self.StudentTestAssessmentReference = StudentTestAssessmentReference
        self.ObjectiveAssessmentReference = ObjectiveAssessmentReference
    def factory(*args_, **kwargs_):
        if StudentObjectiveAssessment.subclass:
            return StudentObjectiveAssessment.subclass(*args_, **kwargs_)
        else:
            return StudentObjectiveAssessment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RawScoreResult(self): return self.RawScoreResult
    def set_RawScoreResult(self, RawScoreResult): self.RawScoreResult = RawScoreResult
    def get_ScoreResults(self): return self.ScoreResults
    def set_ScoreResults(self, ScoreResults): self.ScoreResults = ScoreResults
    def add_ScoreResults(self, value): self.ScoreResults.append(value)
    def insert_ScoreResults(self, index, value): self.ScoreResults[index] = value
    def get_RatingStandardsOutcome(self): return self.RatingStandardsOutcome
    def set_RatingStandardsOutcome(self, RatingStandardsOutcome): self.RatingStandardsOutcome = RatingStandardsOutcome
    def add_RatingStandardsOutcome(self, value): self.RatingStandardsOutcome.append(value)
    def insert_RatingStandardsOutcome(self, index, value): self.RatingStandardsOutcome[index] = value
    def get_StudentTestAssessmentReference(self): return self.StudentTestAssessmentReference
    def set_StudentTestAssessmentReference(self, StudentTestAssessmentReference): self.StudentTestAssessmentReference = StudentTestAssessmentReference
    def get_ObjectiveAssessmentReference(self): return self.ObjectiveAssessmentReference
    def set_ObjectiveAssessmentReference(self, ObjectiveAssessmentReference): self.ObjectiveAssessmentReference = ObjectiveAssessmentReference
    def export(self, outfile, level, namespace_='', name_='StudentObjectiveAssessment', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StudentObjectiveAssessment')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StudentObjectiveAssessment'):
        super(StudentObjectiveAssessment, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StudentObjectiveAssessment')
    def exportChildren(self, outfile, level, namespace_='', name_='StudentObjectiveAssessment', fromsubclass_=False):
        super(StudentObjectiveAssessment, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.RawScoreResult is not None:
            showIndent(outfile, level)
            outfile.write('<%sRawScoreResult>%s</%sRawScoreResult>\n' % (namespace_, self.gds_format_integer(self.RawScoreResult, input_name='RawScoreResult'), namespace_))
        for ScoreResults_ in self.ScoreResults:
            ScoreResults_.export(outfile, level, namespace_, name_='ScoreResults')
        for RatingStandardsOutcome_ in self.RatingStandardsOutcome:
            RatingStandardsOutcome_.export(outfile, level, namespace_, name_='RatingStandardsOutcome')
        if self.StudentTestAssessmentReference:
            self.StudentTestAssessmentReference.export(outfile, level, namespace_, name_='StudentTestAssessmentReference', )
        if self.ObjectiveAssessmentReference:
            self.ObjectiveAssessmentReference.export(outfile, level, namespace_, name_='ObjectiveAssessmentReference', )
    def hasContent_(self):
        if (
            self.RawScoreResult is not None or
            self.ScoreResults or
            self.RatingStandardsOutcome or
            self.StudentTestAssessmentReference is not None or
            self.ObjectiveAssessmentReference is not None or
            super(StudentObjectiveAssessment, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StudentObjectiveAssessment'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StudentObjectiveAssessment, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StudentObjectiveAssessment, self).exportLiteralChildren(outfile, level, name_)
        if self.RawScoreResult is not None:
            showIndent(outfile, level)
            outfile.write('RawScoreResult=%d,\n' % self.RawScoreResult)
        showIndent(outfile, level)
        outfile.write('ScoreResults=[\n')
        level += 1
        for ScoreResults_ in self.ScoreResults:
            showIndent(outfile, level)
            outfile.write('model_.ScoreResult(\n')
            ScoreResults_.exportLiteral(outfile, level, name_='ScoreResult')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RatingStandardsOutcome=[\n')
        level += 1
        for RatingStandardsOutcome_ in self.RatingStandardsOutcome:
            showIndent(outfile, level)
            outfile.write('model_.RatingStandardOutcome(\n')
            RatingStandardsOutcome_.exportLiteral(outfile, level, name_='RatingStandardOutcome')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.StudentTestAssessmentReference is not None:
            showIndent(outfile, level)
            outfile.write('StudentTestAssessmentReference=model_.ReferenceType(\n')
            self.StudentTestAssessmentReference.exportLiteral(outfile, level, name_='StudentTestAssessmentReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ObjectiveAssessmentReference is not None:
            showIndent(outfile, level)
            outfile.write('ObjectiveAssessmentReference=model_.ObjectiveAssessmentReferenceType(\n')
            self.ObjectiveAssessmentReference.exportLiteral(outfile, level, name_='ObjectiveAssessmentReference')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(StudentObjectiveAssessment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RawScoreResult':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RawScoreResult')
            self.RawScoreResult = ival_
        elif nodeName_ == 'ScoreResults':
            obj_ = ScoreResult.factory()
            obj_.build(child_)
            self.ScoreResults.append(obj_)
        elif nodeName_ == 'RatingStandardsOutcome':
            obj_ = RatingStandardOutcome.factory()
            obj_.build(child_)
            self.RatingStandardsOutcome.append(obj_)
        elif nodeName_ == 'StudentTestAssessmentReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_StudentTestAssessmentReference(obj_)
        elif nodeName_ == 'ObjectiveAssessmentReference':
            obj_ = ObjectiveAssessmentReferenceType.factory()
            obj_.build(child_)
            self.set_ObjectiveAssessmentReference(obj_)
        super(StudentObjectiveAssessment, self).buildChildren(child_, node, nodeName_, True)
# end class StudentObjectiveAssessment


class StudentExpectation(ComplexObjectType):
    """A subelement of a learning objective consisting of a precise
    statement of the expectation of a student's proficiency."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, StudentExpectationId=None, Description=None, ContentStandard=None, GradeLevel=None, SubjectArea=None, CourseTitle=None):
        super(StudentExpectation, self).__init__(id, )
        self.StudentExpectationId = StudentExpectationId
        self.Description = Description
        self.ContentStandard = ContentStandard
        self.GradeLevel = GradeLevel
        self.SubjectArea = SubjectArea
        self.CourseTitle = CourseTitle
    def factory(*args_, **kwargs_):
        if StudentExpectation.subclass:
            return StudentExpectation.subclass(*args_, **kwargs_)
        else:
            return StudentExpectation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StudentExpectationId(self): return self.StudentExpectationId
    def set_StudentExpectationId(self, StudentExpectationId): self.StudentExpectationId = StudentExpectationId
    def validate_StudentExpectationId(self, value):
        # Validate type StudentExpectationId, a restriction on xs:string.
        pass
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def validate_Description(self, value):
        # Validate type Description, a restriction on xs:string.
        pass
    def get_ContentStandard(self): return self.ContentStandard
    def set_ContentStandard(self, ContentStandard): self.ContentStandard = ContentStandard
    def validate_ContentStandardType(self, value):
        # Validate type ContentStandardType, a restriction on xs:token.
        pass
    def get_GradeLevel(self): return self.GradeLevel
    def set_GradeLevel(self, GradeLevel): self.GradeLevel = GradeLevel
    def validate_GradeLevelType(self, value):
        # Validate type GradeLevelType, a restriction on xs:token.
        pass
    def get_SubjectArea(self): return self.SubjectArea
    def set_SubjectArea(self, SubjectArea): self.SubjectArea = SubjectArea
    def validate_SubjectAreaType(self, value):
        # Validate type SubjectAreaType, a restriction on xs:token.
        pass
    def get_CourseTitle(self): return self.CourseTitle
    def set_CourseTitle(self, CourseTitle): self.CourseTitle = CourseTitle
    def validate_CourseTitle(self, value):
        # Validate type CourseTitle, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='StudentExpectation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StudentExpectation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StudentExpectation'):
        super(StudentExpectation, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StudentExpectation')
    def exportChildren(self, outfile, level, namespace_='', name_='StudentExpectation', fromsubclass_=False):
        super(StudentExpectation, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.StudentExpectationId is not None:
            showIndent(outfile, level)
            outfile.write('<%sStudentExpectationId>%s</%sStudentExpectationId>\n' % (namespace_, self.gds_format_string(quote_xml(self.StudentExpectationId).encode(ExternalEncoding), input_name='StudentExpectationId'), namespace_))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('<%sDescription>%s</%sDescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_))
        if self.ContentStandard is not None:
            showIndent(outfile, level)
            outfile.write('<%sContentStandard>%s</%sContentStandard>\n' % (namespace_, self.gds_format_string(quote_xml(self.ContentStandard).encode(ExternalEncoding), input_name='ContentStandard'), namespace_))
        if self.GradeLevel is not None:
            showIndent(outfile, level)
            outfile.write('<%sGradeLevel>%s</%sGradeLevel>\n' % (namespace_, self.gds_format_string(quote_xml(self.GradeLevel).encode(ExternalEncoding), input_name='GradeLevel'), namespace_))
        if self.SubjectArea is not None:
            showIndent(outfile, level)
            outfile.write('<%sSubjectArea>%s</%sSubjectArea>\n' % (namespace_, self.gds_format_string(quote_xml(self.SubjectArea).encode(ExternalEncoding), input_name='SubjectArea'), namespace_))
        if self.CourseTitle is not None:
            showIndent(outfile, level)
            outfile.write('<%sCourseTitle>%s</%sCourseTitle>\n' % (namespace_, self.gds_format_string(quote_xml(self.CourseTitle).encode(ExternalEncoding), input_name='CourseTitle'), namespace_))
    def hasContent_(self):
        if (
            self.StudentExpectationId is not None or
            self.Description is not None or
            self.ContentStandard is not None or
            self.GradeLevel is not None or
            self.SubjectArea is not None or
            self.CourseTitle is not None or
            super(StudentExpectation, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StudentExpectation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StudentExpectation, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StudentExpectation, self).exportLiteralChildren(outfile, level, name_)
        if self.StudentExpectationId is not None:
            showIndent(outfile, level)
            outfile.write('StudentExpectationId=%s,\n' % quote_python(self.StudentExpectationId).encode(ExternalEncoding))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.ContentStandard is not None:
            showIndent(outfile, level)
            outfile.write('ContentStandard=%s,\n' % quote_python(self.ContentStandard).encode(ExternalEncoding))
        if self.GradeLevel is not None:
            showIndent(outfile, level)
            outfile.write('GradeLevel=%s,\n' % quote_python(self.GradeLevel).encode(ExternalEncoding))
        if self.SubjectArea is not None:
            showIndent(outfile, level)
            outfile.write('SubjectArea=%s,\n' % quote_python(self.SubjectArea).encode(ExternalEncoding))
        if self.CourseTitle is not None:
            showIndent(outfile, level)
            outfile.write('CourseTitle=%s,\n' % quote_python(self.CourseTitle).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(StudentExpectation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StudentExpectationId':
            StudentExpectationId_ = child_.text
            StudentExpectationId_ = self.gds_validate_string(StudentExpectationId_, node, 'StudentExpectationId')
            self.StudentExpectationId = StudentExpectationId_
            self.validate_StudentExpectationId(self.StudentExpectationId)    # validate type StudentExpectationId
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
            self.validate_Description(self.Description)    # validate type Description
        elif nodeName_ == 'ContentStandard':
            ContentStandard_ = child_.text
            ContentStandard_ = re_.sub(String_cleanup_pat_, " ", ContentStandard_).strip()
            ContentStandard_ = self.gds_validate_string(ContentStandard_, node, 'ContentStandard')
            self.ContentStandard = ContentStandard_
            self.validate_ContentStandardType(self.ContentStandard)    # validate type ContentStandardType
        elif nodeName_ == 'GradeLevel':
            GradeLevel_ = child_.text
            GradeLevel_ = re_.sub(String_cleanup_pat_, " ", GradeLevel_).strip()
            GradeLevel_ = self.gds_validate_string(GradeLevel_, node, 'GradeLevel')
            self.GradeLevel = GradeLevel_
            self.validate_GradeLevelType(self.GradeLevel)    # validate type GradeLevelType
        elif nodeName_ == 'SubjectArea':
            SubjectArea_ = child_.text
            SubjectArea_ = re_.sub(String_cleanup_pat_, " ", SubjectArea_).strip()
            SubjectArea_ = self.gds_validate_string(SubjectArea_, node, 'SubjectArea')
            self.SubjectArea = SubjectArea_
            self.validate_SubjectAreaType(self.SubjectArea)    # validate type SubjectAreaType
        elif nodeName_ == 'CourseTitle':
            CourseTitle_ = child_.text
            CourseTitle_ = self.gds_validate_string(CourseTitle_, node, 'CourseTitle')
            self.CourseTitle = CourseTitle_
            self.validate_CourseTitle(self.CourseTitle)    # validate type CourseTitle
        super(StudentExpectation, self).buildChildren(child_, node, nodeName_, True)
# end class StudentExpectation


class StudentAssessmentItem(ComplexObjectType):
    """This represents the student's response to an assessment item and the
    item-level scores such as correct, incorrect, or met standard."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, AssessmentResponse=None, ResponseIndicator=None, AssessmentItemResult=None, RawScoreResult=None, StudentTestAssessmentReference=None, StudentObjectiveAssessmentReference=None, AssessmentItemReference=None):
        super(StudentAssessmentItem, self).__init__(id, )
        self.AssessmentResponse = AssessmentResponse
        self.ResponseIndicator = ResponseIndicator
        self.AssessmentItemResult = AssessmentItemResult
        self.RawScoreResult = RawScoreResult
        self.StudentTestAssessmentReference = StudentTestAssessmentReference
        self.StudentObjectiveAssessmentReference = StudentObjectiveAssessmentReference
        self.AssessmentItemReference = AssessmentItemReference
    def factory(*args_, **kwargs_):
        if StudentAssessmentItem.subclass:
            return StudentAssessmentItem.subclass(*args_, **kwargs_)
        else:
            return StudentAssessmentItem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AssessmentResponse(self): return self.AssessmentResponse
    def set_AssessmentResponse(self, AssessmentResponse): self.AssessmentResponse = AssessmentResponse
    def validate_AssessmentResponse(self, value):
        # Validate type AssessmentResponse, a restriction on xs:string.
        pass
    def get_ResponseIndicator(self): return self.ResponseIndicator
    def set_ResponseIndicator(self, ResponseIndicator): self.ResponseIndicator = ResponseIndicator
    def validate_ResponseIndicatorType(self, value):
        # Validate type ResponseIndicatorType, a restriction on xs:token.
        pass
    def get_AssessmentItemResult(self): return self.AssessmentItemResult
    def set_AssessmentItemResult(self, AssessmentItemResult): self.AssessmentItemResult = AssessmentItemResult
    def validate_AssessmentItemResultType(self, value):
        # Validate type AssessmentItemResultType, a restriction on xs:token.
        pass
    def get_RawScoreResult(self): return self.RawScoreResult
    def set_RawScoreResult(self, RawScoreResult): self.RawScoreResult = RawScoreResult
    def get_StudentTestAssessmentReference(self): return self.StudentTestAssessmentReference
    def set_StudentTestAssessmentReference(self, StudentTestAssessmentReference): self.StudentTestAssessmentReference = StudentTestAssessmentReference
    def get_StudentObjectiveAssessmentReference(self): return self.StudentObjectiveAssessmentReference
    def set_StudentObjectiveAssessmentReference(self, StudentObjectiveAssessmentReference): self.StudentObjectiveAssessmentReference = StudentObjectiveAssessmentReference
    def get_AssessmentItemReference(self): return self.AssessmentItemReference
    def set_AssessmentItemReference(self, AssessmentItemReference): self.AssessmentItemReference = AssessmentItemReference
    def export(self, outfile, level, namespace_='', name_='StudentAssessmentItem', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StudentAssessmentItem')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StudentAssessmentItem'):
        super(StudentAssessmentItem, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StudentAssessmentItem')
    def exportChildren(self, outfile, level, namespace_='', name_='StudentAssessmentItem', fromsubclass_=False):
        super(StudentAssessmentItem, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.AssessmentResponse is not None:
            showIndent(outfile, level)
            outfile.write('<%sAssessmentResponse>%s</%sAssessmentResponse>\n' % (namespace_, self.gds_format_string(quote_xml(self.AssessmentResponse).encode(ExternalEncoding), input_name='AssessmentResponse'), namespace_))
        if self.ResponseIndicator is not None:
            showIndent(outfile, level)
            outfile.write('<%sResponseIndicator>%s</%sResponseIndicator>\n' % (namespace_, self.gds_format_string(quote_xml(self.ResponseIndicator).encode(ExternalEncoding), input_name='ResponseIndicator'), namespace_))
        if self.AssessmentItemResult is not None:
            showIndent(outfile, level)
            outfile.write('<%sAssessmentItemResult>%s</%sAssessmentItemResult>\n' % (namespace_, self.gds_format_string(quote_xml(self.AssessmentItemResult).encode(ExternalEncoding), input_name='AssessmentItemResult'), namespace_))
        if self.RawScoreResult is not None:
            showIndent(outfile, level)
            outfile.write('<%sRawScoreResult>%s</%sRawScoreResult>\n' % (namespace_, self.gds_format_integer(self.RawScoreResult, input_name='RawScoreResult'), namespace_))
        if self.StudentTestAssessmentReference:
            self.StudentTestAssessmentReference.export(outfile, level, namespace_, name_='StudentTestAssessmentReference')
        if self.StudentObjectiveAssessmentReference:
            self.StudentObjectiveAssessmentReference.export(outfile, level, namespace_, name_='StudentObjectiveAssessmentReference')
        if self.AssessmentItemReference:
            self.AssessmentItemReference.export(outfile, level, namespace_, name_='AssessmentItemReference', )
    def hasContent_(self):
        if (
            self.AssessmentResponse is not None or
            self.ResponseIndicator is not None or
            self.AssessmentItemResult is not None or
            self.RawScoreResult is not None or
            self.StudentTestAssessmentReference is not None or
            self.StudentObjectiveAssessmentReference is not None or
            self.AssessmentItemReference is not None or
            super(StudentAssessmentItem, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StudentAssessmentItem'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StudentAssessmentItem, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StudentAssessmentItem, self).exportLiteralChildren(outfile, level, name_)
        if self.AssessmentResponse is not None:
            showIndent(outfile, level)
            outfile.write('AssessmentResponse=%s,\n' % quote_python(self.AssessmentResponse).encode(ExternalEncoding))
        if self.ResponseIndicator is not None:
            showIndent(outfile, level)
            outfile.write('ResponseIndicator=%s,\n' % quote_python(self.ResponseIndicator).encode(ExternalEncoding))
        if self.AssessmentItemResult is not None:
            showIndent(outfile, level)
            outfile.write('AssessmentItemResult=%s,\n' % quote_python(self.AssessmentItemResult).encode(ExternalEncoding))
        if self.RawScoreResult is not None:
            showIndent(outfile, level)
            outfile.write('RawScoreResult=%d,\n' % self.RawScoreResult)
        if self.StudentTestAssessmentReference is not None:
            showIndent(outfile, level)
            outfile.write('StudentTestAssessmentReference=model_.ReferenceType(\n')
            self.StudentTestAssessmentReference.exportLiteral(outfile, level, name_='StudentTestAssessmentReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.StudentObjectiveAssessmentReference is not None:
            showIndent(outfile, level)
            outfile.write('StudentObjectiveAssessmentReference=model_.ReferenceType(\n')
            self.StudentObjectiveAssessmentReference.exportLiteral(outfile, level, name_='StudentObjectiveAssessmentReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AssessmentItemReference is not None:
            showIndent(outfile, level)
            outfile.write('AssessmentItemReference=model_.AssessmentItemReferenceType(\n')
            self.AssessmentItemReference.exportLiteral(outfile, level, name_='AssessmentItemReference')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(StudentAssessmentItem, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AssessmentResponse':
            AssessmentResponse_ = child_.text
            AssessmentResponse_ = self.gds_validate_string(AssessmentResponse_, node, 'AssessmentResponse')
            self.AssessmentResponse = AssessmentResponse_
            self.validate_AssessmentResponse(self.AssessmentResponse)    # validate type AssessmentResponse
        elif nodeName_ == 'ResponseIndicator':
            ResponseIndicator_ = child_.text
            ResponseIndicator_ = re_.sub(String_cleanup_pat_, " ", ResponseIndicator_).strip()
            ResponseIndicator_ = self.gds_validate_string(ResponseIndicator_, node, 'ResponseIndicator')
            self.ResponseIndicator = ResponseIndicator_
            self.validate_ResponseIndicatorType(self.ResponseIndicator)    # validate type ResponseIndicatorType
        elif nodeName_ == 'AssessmentItemResult':
            AssessmentItemResult_ = child_.text
            AssessmentItemResult_ = re_.sub(String_cleanup_pat_, " ", AssessmentItemResult_).strip()
            AssessmentItemResult_ = self.gds_validate_string(AssessmentItemResult_, node, 'AssessmentItemResult')
            self.AssessmentItemResult = AssessmentItemResult_
            self.validate_AssessmentItemResultType(self.AssessmentItemResult)    # validate type AssessmentItemResultType
        elif nodeName_ == 'RawScoreResult':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RawScoreResult')
            self.RawScoreResult = ival_
        elif nodeName_ == 'StudentTestAssessmentReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_StudentTestAssessmentReference(obj_)
        elif nodeName_ == 'StudentObjectiveAssessmentReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_StudentObjectiveAssessmentReference(obj_)
        elif nodeName_ == 'AssessmentItemReference':
            obj_ = AssessmentItemReferenceType.factory()
            obj_.build(child_)
            self.set_AssessmentItemReference(obj_)
        super(StudentAssessmentItem, self).buildChildren(child_, node, nodeName_, True)
# end class StudentAssessmentItem


class StudentAssessment(ComplexObjectType):
    """This represents the analysis or scoring of a student's response on
    an assessment. The analysis results in a value that represents a
    students performance on a set of items on a test."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, AdministrationDate=None, AdministrationEndDate=None, AssessmentForm=None, AdministrationLanguage=None, AdministrationEnvironment=None, SpecialAccommodations=None, LinguisticAccommodations=None, RetestIndicator=None, ReasonNotTested=None, ScoreResults=None, RatingStandardsOutcome=None, GradeLevelWhenAssessed=None, StudentReference=None, AssessmentReference=None):
        super(StudentAssessment, self).__init__(id, )
        self.AdministrationDate = AdministrationDate
        self.AdministrationEndDate = AdministrationEndDate
        self.AssessmentForm = AssessmentForm
        self.AdministrationLanguage = AdministrationLanguage
        self.AdministrationEnvironment = AdministrationEnvironment
        if SpecialAccommodations is None:
            self.SpecialAccommodations = []
        else:
            self.SpecialAccommodations = SpecialAccommodations
        if LinguisticAccommodations is None:
            self.LinguisticAccommodations = []
        else:
            self.LinguisticAccommodations = LinguisticAccommodations
        self.RetestIndicator = RetestIndicator
        self.ReasonNotTested = ReasonNotTested
        if ScoreResults is None:
            self.ScoreResults = []
        else:
            self.ScoreResults = ScoreResults
        if RatingStandardsOutcome is None:
            self.RatingStandardsOutcome = []
        else:
            self.RatingStandardsOutcome = RatingStandardsOutcome
        self.GradeLevelWhenAssessed = GradeLevelWhenAssessed
        self.StudentReference = StudentReference
        self.AssessmentReference = AssessmentReference
    def factory(*args_, **kwargs_):
        if StudentAssessment.subclass:
            return StudentAssessment.subclass(*args_, **kwargs_)
        else:
            return StudentAssessment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AdministrationDate(self): return self.AdministrationDate
    def set_AdministrationDate(self, AdministrationDate): self.AdministrationDate = AdministrationDate
    def get_AdministrationEndDate(self): return self.AdministrationEndDate
    def set_AdministrationEndDate(self, AdministrationEndDate): self.AdministrationEndDate = AdministrationEndDate
    def get_AssessmentForm(self): return self.AssessmentForm
    def set_AssessmentForm(self, AssessmentForm): self.AssessmentForm = AssessmentForm
    def validate_IdentificationCode(self, value):
        # Validate type IdentificationCode, a restriction on xs:string.
        pass
    def get_AdministrationLanguage(self): return self.AdministrationLanguage
    def set_AdministrationLanguage(self, AdministrationLanguage): self.AdministrationLanguage = AdministrationLanguage
    def validate_LanguageItemType(self, value):
        # Validate type LanguageItemType, a restriction on xs:token.
        pass
    def get_AdministrationEnvironment(self): return self.AdministrationEnvironment
    def set_AdministrationEnvironment(self, AdministrationEnvironment): self.AdministrationEnvironment = AdministrationEnvironment
    def validate_AdministrationEnvironmentType(self, value):
        # Validate type AdministrationEnvironmentType, a restriction on xs:token.
        pass
    def get_SpecialAccommodations(self): return self.SpecialAccommodations
    def set_SpecialAccommodations(self, SpecialAccommodations): self.SpecialAccommodations = SpecialAccommodations
    def add_SpecialAccommodations(self, value): self.SpecialAccommodations.append(value)
    def insert_SpecialAccommodations(self, index, value): self.SpecialAccommodations[index] = value
    def get_LinguisticAccommodations(self): return self.LinguisticAccommodations
    def set_LinguisticAccommodations(self, LinguisticAccommodations): self.LinguisticAccommodations = LinguisticAccommodations
    def add_LinguisticAccommodations(self, value): self.LinguisticAccommodations.append(value)
    def insert_LinguisticAccommodations(self, index, value): self.LinguisticAccommodations[index] = value
    def get_RetestIndicator(self): return self.RetestIndicator
    def set_RetestIndicator(self, RetestIndicator): self.RetestIndicator = RetestIndicator
    def validate_RetestIndicatorType(self, value):
        # Validate type RetestIndicatorType, a restriction on xs:token.
        pass
    def get_ReasonNotTested(self): return self.ReasonNotTested
    def set_ReasonNotTested(self, ReasonNotTested): self.ReasonNotTested = ReasonNotTested
    def validate_ReasonNotTestedType(self, value):
        # Validate type ReasonNotTestedType, a restriction on xs:token.
        pass
    def get_ScoreResults(self): return self.ScoreResults
    def set_ScoreResults(self, ScoreResults): self.ScoreResults = ScoreResults
    def add_ScoreResults(self, value): self.ScoreResults.append(value)
    def insert_ScoreResults(self, index, value): self.ScoreResults[index] = value
    def get_RatingStandardsOutcome(self): return self.RatingStandardsOutcome
    def set_RatingStandardsOutcome(self, RatingStandardsOutcome): self.RatingStandardsOutcome = RatingStandardsOutcome
    def add_RatingStandardsOutcome(self, value): self.RatingStandardsOutcome.append(value)
    def insert_RatingStandardsOutcome(self, index, value): self.RatingStandardsOutcome[index] = value
    def get_GradeLevelWhenAssessed(self): return self.GradeLevelWhenAssessed
    def set_GradeLevelWhenAssessed(self, GradeLevelWhenAssessed): self.GradeLevelWhenAssessed = GradeLevelWhenAssessed
    def validate_GradeLevelType(self, value):
        # Validate type GradeLevelType, a restriction on xs:token.
        pass
    def get_StudentReference(self): return self.StudentReference
    def set_StudentReference(self, StudentReference): self.StudentReference = StudentReference
    def get_AssessmentReference(self): return self.AssessmentReference
    def set_AssessmentReference(self, AssessmentReference): self.AssessmentReference = AssessmentReference
    def export(self, outfile, level, namespace_='', name_='StudentAssessment', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StudentAssessment')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StudentAssessment'):
        super(StudentAssessment, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StudentAssessment')
    def exportChildren(self, outfile, level, namespace_='', name_='StudentAssessment', fromsubclass_=False):
        super(StudentAssessment, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.AdministrationDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sAdministrationDate>%s</%sAdministrationDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.AdministrationDate).encode(ExternalEncoding), input_name='AdministrationDate'), namespace_))
        if self.AdministrationEndDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sAdministrationEndDate>%s</%sAdministrationEndDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.AdministrationEndDate).encode(ExternalEncoding), input_name='AdministrationEndDate'), namespace_))
        if self.AssessmentForm is not None:
            showIndent(outfile, level)
            outfile.write('<%sAssessmentForm>%s</%sAssessmentForm>\n' % (namespace_, self.gds_format_string(quote_xml(self.AssessmentForm).encode(ExternalEncoding), input_name='AssessmentForm'), namespace_))
        if self.AdministrationLanguage is not None:
            showIndent(outfile, level)
            outfile.write('<%sAdministrationLanguage>%s</%sAdministrationLanguage>\n' % (namespace_, self.gds_format_string(quote_xml(self.AdministrationLanguage).encode(ExternalEncoding), input_name='AdministrationLanguage'), namespace_))
        if self.AdministrationEnvironment is not None:
            showIndent(outfile, level)
            outfile.write('<%sAdministrationEnvironment>%s</%sAdministrationEnvironment>\n' % (namespace_, self.gds_format_string(quote_xml(self.AdministrationEnvironment).encode(ExternalEncoding), input_name='AdministrationEnvironment'), namespace_))
        for SpecialAccommodations_ in self.SpecialAccommodations:
            SpecialAccommodations_.export(outfile, level, namespace_, name_='SpecialAccommodations')
        for LinguisticAccommodations_ in self.LinguisticAccommodations:
            LinguisticAccommodations_.export(outfile, level, namespace_, name_='LinguisticAccommodations')
        if self.RetestIndicator is not None:
            showIndent(outfile, level)
            outfile.write('<%sRetestIndicator>%s</%sRetestIndicator>\n' % (namespace_, self.gds_format_string(quote_xml(self.RetestIndicator).encode(ExternalEncoding), input_name='RetestIndicator'), namespace_))
        if self.ReasonNotTested is not None:
            showIndent(outfile, level)
            outfile.write('<%sReasonNotTested>%s</%sReasonNotTested>\n' % (namespace_, self.gds_format_string(quote_xml(self.ReasonNotTested).encode(ExternalEncoding), input_name='ReasonNotTested'), namespace_))
        for ScoreResults_ in self.ScoreResults:
            ScoreResults_.export(outfile, level, namespace_, name_='ScoreResults')
        for RatingStandardsOutcome_ in self.RatingStandardsOutcome:
            RatingStandardsOutcome_.export(outfile, level, namespace_, name_='RatingStandardsOutcome')
        if self.GradeLevelWhenAssessed is not None:
            showIndent(outfile, level)
            outfile.write('<%sGradeLevelWhenAssessed>%s</%sGradeLevelWhenAssessed>\n' % (namespace_, self.gds_format_string(quote_xml(self.GradeLevelWhenAssessed).encode(ExternalEncoding), input_name='GradeLevelWhenAssessed'), namespace_))
        if self.StudentReference:
            self.StudentReference.export(outfile, level, namespace_, name_='StudentReference', )
        if self.AssessmentReference:
            self.AssessmentReference.export(outfile, level, namespace_, name_='AssessmentReference', )
    def hasContent_(self):
        if (
            self.AdministrationDate is not None or
            self.AdministrationEndDate is not None or
            self.AssessmentForm is not None or
            self.AdministrationLanguage is not None or
            self.AdministrationEnvironment is not None or
            self.SpecialAccommodations or
            self.LinguisticAccommodations or
            self.RetestIndicator is not None or
            self.ReasonNotTested is not None or
            self.ScoreResults or
            self.RatingStandardsOutcome or
            self.GradeLevelWhenAssessed is not None or
            self.StudentReference is not None or
            self.AssessmentReference is not None or
            super(StudentAssessment, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StudentAssessment'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StudentAssessment, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StudentAssessment, self).exportLiteralChildren(outfile, level, name_)
        if self.AdministrationDate is not None:
            showIndent(outfile, level)
            outfile.write('AdministrationDate=%s,\n' % quote_python(self.AdministrationDate).encode(ExternalEncoding))
        if self.AdministrationEndDate is not None:
            showIndent(outfile, level)
            outfile.write('AdministrationEndDate=%s,\n' % quote_python(self.AdministrationEndDate).encode(ExternalEncoding))
        if self.AssessmentForm is not None:
            showIndent(outfile, level)
            outfile.write('AssessmentForm=%s,\n' % quote_python(self.AssessmentForm).encode(ExternalEncoding))
        if self.AdministrationLanguage is not None:
            showIndent(outfile, level)
            outfile.write('AdministrationLanguage=%s,\n' % quote_python(self.AdministrationLanguage).encode(ExternalEncoding))
        if self.AdministrationEnvironment is not None:
            showIndent(outfile, level)
            outfile.write('AdministrationEnvironment=%s,\n' % quote_python(self.AdministrationEnvironment).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('SpecialAccommodations=[\n')
        level += 1
        for SpecialAccommodations_ in self.SpecialAccommodations:
            showIndent(outfile, level)
            outfile.write('model_.SpecialAccommodationsType(\n')
            SpecialAccommodations_.exportLiteral(outfile, level, name_='SpecialAccommodationsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LinguisticAccommodations=[\n')
        level += 1
        for LinguisticAccommodations_ in self.LinguisticAccommodations:
            showIndent(outfile, level)
            outfile.write('model_.LinguisticAccommodationsType(\n')
            LinguisticAccommodations_.exportLiteral(outfile, level, name_='LinguisticAccommodationsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.RetestIndicator is not None:
            showIndent(outfile, level)
            outfile.write('RetestIndicator=%s,\n' % quote_python(self.RetestIndicator).encode(ExternalEncoding))
        if self.ReasonNotTested is not None:
            showIndent(outfile, level)
            outfile.write('ReasonNotTested=%s,\n' % quote_python(self.ReasonNotTested).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('ScoreResults=[\n')
        level += 1
        for ScoreResults_ in self.ScoreResults:
            showIndent(outfile, level)
            outfile.write('model_.ScoreResult(\n')
            ScoreResults_.exportLiteral(outfile, level, name_='ScoreResult')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RatingStandardsOutcome=[\n')
        level += 1
        for RatingStandardsOutcome_ in self.RatingStandardsOutcome:
            showIndent(outfile, level)
            outfile.write('model_.RatingStandardOutcome(\n')
            RatingStandardsOutcome_.exportLiteral(outfile, level, name_='RatingStandardOutcome')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.GradeLevelWhenAssessed is not None:
            showIndent(outfile, level)
            outfile.write('GradeLevelWhenAssessed=%s,\n' % quote_python(self.GradeLevelWhenAssessed).encode(ExternalEncoding))
        if self.StudentReference is not None:
            showIndent(outfile, level)
            outfile.write('StudentReference=model_.StudentReferenceType(\n')
            self.StudentReference.exportLiteral(outfile, level, name_='StudentReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AssessmentReference is not None:
            showIndent(outfile, level)
            outfile.write('AssessmentReference=model_.AssessmentReferenceType(\n')
            self.AssessmentReference.exportLiteral(outfile, level, name_='AssessmentReference')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(StudentAssessment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AdministrationDate':
            AdministrationDate_ = child_.text
            AdministrationDate_ = self.gds_validate_string(AdministrationDate_, node, 'AdministrationDate')
            self.AdministrationDate = AdministrationDate_
        elif nodeName_ == 'AdministrationEndDate':
            AdministrationEndDate_ = child_.text
            AdministrationEndDate_ = self.gds_validate_string(AdministrationEndDate_, node, 'AdministrationEndDate')
            self.AdministrationEndDate = AdministrationEndDate_
        elif nodeName_ == 'AssessmentForm':
            AssessmentForm_ = child_.text
            AssessmentForm_ = self.gds_validate_string(AssessmentForm_, node, 'AssessmentForm')
            self.AssessmentForm = AssessmentForm_
            self.validate_IdentificationCode(self.AssessmentForm)    # validate type IdentificationCode
        elif nodeName_ == 'AdministrationLanguage':
            AdministrationLanguage_ = child_.text
            AdministrationLanguage_ = re_.sub(String_cleanup_pat_, " ", AdministrationLanguage_).strip()
            AdministrationLanguage_ = self.gds_validate_string(AdministrationLanguage_, node, 'AdministrationLanguage')
            self.AdministrationLanguage = AdministrationLanguage_
            self.validate_LanguageItemType(self.AdministrationLanguage)    # validate type LanguageItemType
        elif nodeName_ == 'AdministrationEnvironment':
            AdministrationEnvironment_ = child_.text
            AdministrationEnvironment_ = re_.sub(String_cleanup_pat_, " ", AdministrationEnvironment_).strip()
            AdministrationEnvironment_ = self.gds_validate_string(AdministrationEnvironment_, node, 'AdministrationEnvironment')
            self.AdministrationEnvironment = AdministrationEnvironment_
            self.validate_AdministrationEnvironmentType(self.AdministrationEnvironment)    # validate type AdministrationEnvironmentType
        elif nodeName_ == 'SpecialAccommodations':
            obj_ = SpecialAccommodationsType.factory()
            obj_.build(child_)
            self.SpecialAccommodations.append(obj_)
        elif nodeName_ == 'LinguisticAccommodations':
            obj_ = LinguisticAccommodationsType.factory()
            obj_.build(child_)
            self.LinguisticAccommodations.append(obj_)
        elif nodeName_ == 'RetestIndicator':
            RetestIndicator_ = child_.text
            RetestIndicator_ = re_.sub(String_cleanup_pat_, " ", RetestIndicator_).strip()
            RetestIndicator_ = self.gds_validate_string(RetestIndicator_, node, 'RetestIndicator')
            self.RetestIndicator = RetestIndicator_
            self.validate_RetestIndicatorType(self.RetestIndicator)    # validate type RetestIndicatorType
        elif nodeName_ == 'ReasonNotTested':
            ReasonNotTested_ = child_.text
            ReasonNotTested_ = re_.sub(String_cleanup_pat_, " ", ReasonNotTested_).strip()
            ReasonNotTested_ = self.gds_validate_string(ReasonNotTested_, node, 'ReasonNotTested')
            self.ReasonNotTested = ReasonNotTested_
            self.validate_ReasonNotTestedType(self.ReasonNotTested)    # validate type ReasonNotTestedType
        elif nodeName_ == 'ScoreResults':
            obj_ = ScoreResult.factory()
            obj_.build(child_)
            self.ScoreResults.append(obj_)
        elif nodeName_ == 'RatingStandardsOutcome':
            obj_ = RatingStandardOutcome.factory()
            obj_.build(child_)
            self.RatingStandardsOutcome.append(obj_)
        elif nodeName_ == 'GradeLevelWhenAssessed':
            GradeLevelWhenAssessed_ = child_.text
            GradeLevelWhenAssessed_ = re_.sub(String_cleanup_pat_, " ", GradeLevelWhenAssessed_).strip()
            GradeLevelWhenAssessed_ = self.gds_validate_string(GradeLevelWhenAssessed_, node, 'GradeLevelWhenAssessed')
            self.GradeLevelWhenAssessed = GradeLevelWhenAssessed_
            self.validate_GradeLevelType(self.GradeLevelWhenAssessed)    # validate type GradeLevelType
        elif nodeName_ == 'StudentReference':
            obj_ = StudentReferenceType.factory()
            obj_.build(child_)
            self.set_StudentReference(obj_)
        elif nodeName_ == 'AssessmentReference':
            obj_ = AssessmentReferenceType.factory()
            obj_.build(child_)
            self.set_AssessmentReference(obj_)
        super(StudentAssessment, self).buildChildren(child_, node, nodeName_, True)
# end class StudentAssessment


class StudentAcademicRecord(ComplexObjectType):
    """This educational entity represents the cumulative record of academic
    achievement for a student."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, CumulativeCreditsEarned=None, CumulativeCreditsAttempted=None, CumulativeGradePointsEarned=None, CumulativeGradePointAverage=None, GradeValueQualifier=None, ClassRanking=None, SchoolYear=None, Term=None, AcademicHonors=None, Recognitions=None, ProjectedGraduationDate=None, StudentReference=None, ReportCardReference=None, DiplomaReference=None):
        super(StudentAcademicRecord, self).__init__(id, )
        self.CumulativeCreditsEarned = CumulativeCreditsEarned
        self.CumulativeCreditsAttempted = CumulativeCreditsAttempted
        self.CumulativeGradePointsEarned = CumulativeGradePointsEarned
        self.CumulativeGradePointAverage = CumulativeGradePointAverage
        self.GradeValueQualifier = GradeValueQualifier
        self.ClassRanking = ClassRanking
        self.SchoolYear = SchoolYear
        self.Term = Term
        if AcademicHonors is None:
            self.AcademicHonors = []
        else:
            self.AcademicHonors = AcademicHonors
        if Recognitions is None:
            self.Recognitions = []
        else:
            self.Recognitions = Recognitions
        self.ProjectedGraduationDate = ProjectedGraduationDate
        self.StudentReference = StudentReference
        if ReportCardReference is None:
            self.ReportCardReference = []
        else:
            self.ReportCardReference = ReportCardReference
        self.DiplomaReference = DiplomaReference
    def factory(*args_, **kwargs_):
        if StudentAcademicRecord.subclass:
            return StudentAcademicRecord.subclass(*args_, **kwargs_)
        else:
            return StudentAcademicRecord(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CumulativeCreditsEarned(self): return self.CumulativeCreditsEarned
    def set_CumulativeCreditsEarned(self, CumulativeCreditsEarned): self.CumulativeCreditsEarned = CumulativeCreditsEarned
    def get_CumulativeCreditsAttempted(self): return self.CumulativeCreditsAttempted
    def set_CumulativeCreditsAttempted(self, CumulativeCreditsAttempted): self.CumulativeCreditsAttempted = CumulativeCreditsAttempted
    def get_CumulativeGradePointsEarned(self): return self.CumulativeGradePointsEarned
    def set_CumulativeGradePointsEarned(self, CumulativeGradePointsEarned): self.CumulativeGradePointsEarned = CumulativeGradePointsEarned
    def get_CumulativeGradePointAverage(self): return self.CumulativeGradePointAverage
    def set_CumulativeGradePointAverage(self, CumulativeGradePointAverage): self.CumulativeGradePointAverage = CumulativeGradePointAverage
    def get_GradeValueQualifier(self): return self.GradeValueQualifier
    def set_GradeValueQualifier(self, GradeValueQualifier): self.GradeValueQualifier = GradeValueQualifier
    def validate_GradeValueQualifier(self, value):
        # Validate type GradeValueQualifier, a restriction on xs:string.
        pass
    def get_ClassRanking(self): return self.ClassRanking
    def set_ClassRanking(self, ClassRanking): self.ClassRanking = ClassRanking
    def get_SchoolYear(self): return self.SchoolYear
    def set_SchoolYear(self, SchoolYear): self.SchoolYear = SchoolYear
    def validate_SchoolYearType(self, value):
        # Validate type SchoolYearType, a restriction on xs:token.
        pass
    def get_Term(self): return self.Term
    def set_Term(self, Term): self.Term = Term
    def validate_TermType(self, value):
        # Validate type TermType, a restriction on xs:token.
        pass
    def get_AcademicHonors(self): return self.AcademicHonors
    def set_AcademicHonors(self, AcademicHonors): self.AcademicHonors = AcademicHonors
    def add_AcademicHonors(self, value): self.AcademicHonors.append(value)
    def insert_AcademicHonors(self, index, value): self.AcademicHonors[index] = value
    def get_Recognitions(self): return self.Recognitions
    def set_Recognitions(self, Recognitions): self.Recognitions = Recognitions
    def add_Recognitions(self, value): self.Recognitions.append(value)
    def insert_Recognitions(self, index, value): self.Recognitions[index] = value
    def get_ProjectedGraduationDate(self): return self.ProjectedGraduationDate
    def set_ProjectedGraduationDate(self, ProjectedGraduationDate): self.ProjectedGraduationDate = ProjectedGraduationDate
    def get_StudentReference(self): return self.StudentReference
    def set_StudentReference(self, StudentReference): self.StudentReference = StudentReference
    def get_ReportCardReference(self): return self.ReportCardReference
    def set_ReportCardReference(self, ReportCardReference): self.ReportCardReference = ReportCardReference
    def add_ReportCardReference(self, value): self.ReportCardReference.append(value)
    def insert_ReportCardReference(self, index, value): self.ReportCardReference[index] = value
    def get_DiplomaReference(self): return self.DiplomaReference
    def set_DiplomaReference(self, DiplomaReference): self.DiplomaReference = DiplomaReference
    def export(self, outfile, level, namespace_='', name_='StudentAcademicRecord', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StudentAcademicRecord')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StudentAcademicRecord'):
        super(StudentAcademicRecord, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StudentAcademicRecord')
    def exportChildren(self, outfile, level, namespace_='', name_='StudentAcademicRecord', fromsubclass_=False):
        super(StudentAcademicRecord, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.CumulativeCreditsEarned:
            self.CumulativeCreditsEarned.export(outfile, level, namespace_, name_='CumulativeCreditsEarned')
        if self.CumulativeCreditsAttempted:
            self.CumulativeCreditsAttempted.export(outfile, level, namespace_, name_='CumulativeCreditsAttempted')
        if self.CumulativeGradePointsEarned is not None:
            showIndent(outfile, level)
            outfile.write('<%sCumulativeGradePointsEarned>%s</%sCumulativeGradePointsEarned>\n' % (namespace_, self.gds_format_float(self.CumulativeGradePointsEarned, input_name='CumulativeGradePointsEarned'), namespace_))
        if self.CumulativeGradePointAverage is not None:
            showIndent(outfile, level)
            outfile.write('<%sCumulativeGradePointAverage>%s</%sCumulativeGradePointAverage>\n' % (namespace_, self.gds_format_float(self.CumulativeGradePointAverage, input_name='CumulativeGradePointAverage'), namespace_))
        if self.GradeValueQualifier is not None:
            showIndent(outfile, level)
            outfile.write('<%sGradeValueQualifier>%s</%sGradeValueQualifier>\n' % (namespace_, self.gds_format_string(quote_xml(self.GradeValueQualifier).encode(ExternalEncoding), input_name='GradeValueQualifier'), namespace_))
        if self.ClassRanking:
            self.ClassRanking.export(outfile, level, namespace_, name_='ClassRanking')
        if self.SchoolYear is not None:
            showIndent(outfile, level)
            outfile.write('<%sSchoolYear>%s</%sSchoolYear>\n' % (namespace_, self.gds_format_string(quote_xml(self.SchoolYear).encode(ExternalEncoding), input_name='SchoolYear'), namespace_))
        if self.Term is not None:
            showIndent(outfile, level)
            outfile.write('<%sTerm>%s</%sTerm>\n' % (namespace_, self.gds_format_string(quote_xml(self.Term).encode(ExternalEncoding), input_name='Term'), namespace_))
        for AcademicHonors_ in self.AcademicHonors:
            AcademicHonors_.export(outfile, level, namespace_, name_='AcademicHonors')
        for Recognitions_ in self.Recognitions:
            Recognitions_.export(outfile, level, namespace_, name_='Recognitions')
        if self.ProjectedGraduationDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sProjectedGraduationDate>%s</%sProjectedGraduationDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.ProjectedGraduationDate).encode(ExternalEncoding), input_name='ProjectedGraduationDate'), namespace_))
        if self.StudentReference:
            self.StudentReference.export(outfile, level, namespace_, name_='StudentReference', )
        for ReportCardReference_ in self.ReportCardReference:
            ReportCardReference_.export(outfile, level, namespace_, name_='ReportCardReference')
        if self.DiplomaReference:
            self.DiplomaReference.export(outfile, level, namespace_, name_='DiplomaReference')
    def hasContent_(self):
        if (
            self.CumulativeCreditsEarned is not None or
            self.CumulativeCreditsAttempted is not None or
            self.CumulativeGradePointsEarned is not None or
            self.CumulativeGradePointAverage is not None or
            self.GradeValueQualifier is not None or
            self.ClassRanking is not None or
            self.SchoolYear is not None or
            self.Term is not None or
            self.AcademicHonors or
            self.Recognitions or
            self.ProjectedGraduationDate is not None or
            self.StudentReference is not None or
            self.ReportCardReference or
            self.DiplomaReference is not None or
            super(StudentAcademicRecord, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StudentAcademicRecord'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StudentAcademicRecord, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StudentAcademicRecord, self).exportLiteralChildren(outfile, level, name_)
        if self.CumulativeCreditsEarned is not None:
            showIndent(outfile, level)
            outfile.write('CumulativeCreditsEarned=model_.Credits(\n')
            self.CumulativeCreditsEarned.exportLiteral(outfile, level, name_='CumulativeCreditsEarned')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CumulativeCreditsAttempted is not None:
            showIndent(outfile, level)
            outfile.write('CumulativeCreditsAttempted=model_.Credits(\n')
            self.CumulativeCreditsAttempted.exportLiteral(outfile, level, name_='CumulativeCreditsAttempted')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CumulativeGradePointsEarned is not None:
            showIndent(outfile, level)
            outfile.write('CumulativeGradePointsEarned=%f,\n' % self.CumulativeGradePointsEarned)
        if self.CumulativeGradePointAverage is not None:
            showIndent(outfile, level)
            outfile.write('CumulativeGradePointAverage=%f,\n' % self.CumulativeGradePointAverage)
        if self.GradeValueQualifier is not None:
            showIndent(outfile, level)
            outfile.write('GradeValueQualifier=%s,\n' % quote_python(self.GradeValueQualifier).encode(ExternalEncoding))
        if self.ClassRanking is not None:
            showIndent(outfile, level)
            outfile.write('ClassRanking=model_.ClassRanking(\n')
            self.ClassRanking.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SchoolYear is not None:
            showIndent(outfile, level)
            outfile.write('SchoolYear=%s,\n' % quote_python(self.SchoolYear).encode(ExternalEncoding))
        if self.Term is not None:
            showIndent(outfile, level)
            outfile.write('Term=%s,\n' % quote_python(self.Term).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('AcademicHonors=[\n')
        level += 1
        for AcademicHonors_ in self.AcademicHonors:
            showIndent(outfile, level)
            outfile.write('model_.AcademicHonor(\n')
            AcademicHonors_.exportLiteral(outfile, level, name_='AcademicHonor')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Recognitions=[\n')
        level += 1
        for Recognitions_ in self.Recognitions:
            showIndent(outfile, level)
            outfile.write('model_.Recognition(\n')
            Recognitions_.exportLiteral(outfile, level, name_='Recognition')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ProjectedGraduationDate is not None:
            showIndent(outfile, level)
            outfile.write('ProjectedGraduationDate=%s,\n' % quote_python(self.ProjectedGraduationDate).encode(ExternalEncoding))
        if self.StudentReference is not None:
            showIndent(outfile, level)
            outfile.write('StudentReference=model_.StudentReferenceType(\n')
            self.StudentReference.exportLiteral(outfile, level, name_='StudentReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('ReportCardReference=[\n')
        level += 1
        for ReportCardReference_ in self.ReportCardReference:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            ReportCardReference_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.DiplomaReference is not None:
            showIndent(outfile, level)
            outfile.write('DiplomaReference=model_.ReferenceType(\n')
            self.DiplomaReference.exportLiteral(outfile, level, name_='DiplomaReference')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(StudentAcademicRecord, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CumulativeCreditsEarned':
            obj_ = Credits.factory()
            obj_.build(child_)
            self.set_CumulativeCreditsEarned(obj_)
        elif nodeName_ == 'CumulativeCreditsAttempted':
            obj_ = Credits.factory()
            obj_.build(child_)
            self.set_CumulativeCreditsAttempted(obj_)
        elif nodeName_ == 'CumulativeGradePointsEarned':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CumulativeGradePointsEarned')
            self.CumulativeGradePointsEarned = fval_
        elif nodeName_ == 'CumulativeGradePointAverage':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CumulativeGradePointAverage')
            self.CumulativeGradePointAverage = fval_
        elif nodeName_ == 'GradeValueQualifier':
            GradeValueQualifier_ = child_.text
            GradeValueQualifier_ = self.gds_validate_string(GradeValueQualifier_, node, 'GradeValueQualifier')
            self.GradeValueQualifier = GradeValueQualifier_
            self.validate_GradeValueQualifier(self.GradeValueQualifier)    # validate type GradeValueQualifier
        elif nodeName_ == 'ClassRanking':
            obj_ = ClassRanking.factory()
            obj_.build(child_)
            self.set_ClassRanking(obj_)
        elif nodeName_ == 'SchoolYear':
            SchoolYear_ = child_.text
            SchoolYear_ = re_.sub(String_cleanup_pat_, " ", SchoolYear_).strip()
            SchoolYear_ = self.gds_validate_string(SchoolYear_, node, 'SchoolYear')
            self.SchoolYear = SchoolYear_
            self.validate_SchoolYearType(self.SchoolYear)    # validate type SchoolYearType
        elif nodeName_ == 'Term':
            Term_ = child_.text
            Term_ = re_.sub(String_cleanup_pat_, " ", Term_).strip()
            Term_ = self.gds_validate_string(Term_, node, 'Term')
            self.Term = Term_
            self.validate_TermType(self.Term)    # validate type TermType
        elif nodeName_ == 'AcademicHonors':
            obj_ = AcademicHonor.factory()
            obj_.build(child_)
            self.AcademicHonors.append(obj_)
        elif nodeName_ == 'Recognitions':
            obj_ = Recognition.factory()
            obj_.build(child_)
            self.Recognitions.append(obj_)
        elif nodeName_ == 'ProjectedGraduationDate':
            ProjectedGraduationDate_ = child_.text
            ProjectedGraduationDate_ = self.gds_validate_string(ProjectedGraduationDate_, node, 'ProjectedGraduationDate')
            self.ProjectedGraduationDate = ProjectedGraduationDate_
        elif nodeName_ == 'StudentReference':
            obj_ = StudentReferenceType.factory()
            obj_.build(child_)
            self.set_StudentReference(obj_)
        elif nodeName_ == 'ReportCardReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ReportCardReference.append(obj_)
        elif nodeName_ == 'DiplomaReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_DiplomaReference(obj_)
        super(StudentAcademicRecord, self).buildChildren(child_, node, nodeName_, True)
# end class StudentAcademicRecord


class Student(ComplexObjectType):
    """This entity represents an individual for whom instruction, services
    and/or care are provided in an early childhood, elementary or
    secondary educational program under the jurisdiction of a
    school, education agency, or other institution or program. A
    student is a person who has been enrolled in a school or other
    educational institution."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, StudentUniqueStateId=None, StudentIdentificationCode=None, Name=None, OtherName=None, Sex=None, BirthData=None, Address=None, Telephone=None, ElectronicMail=None, ProfileThumbnail=None, HispanicLatinoEthnicity=None, OldEthnicity=None, Race=None, EconomicDisadvantaged=None, SchoolFoodServicesEligibility=None, StudentCharacteristics=None, LimitedEnglishProficiency=None, Languages=None, HomeLanguages=None, Disabilities=None, Section504Disabilities=None, DisplacementStatus=None, ProgramParticipations=None, LearningStyles=None, CohortYears=None, StudentIndicators=None):
        super(Student, self).__init__(id, )
        self.StudentUniqueStateId = StudentUniqueStateId
        if StudentIdentificationCode is None:
            self.StudentIdentificationCode = []
        else:
            self.StudentIdentificationCode = StudentIdentificationCode
        self.Name = Name
        if OtherName is None:
            self.OtherName = []
        else:
            self.OtherName = OtherName
        self.Sex = Sex
        self.BirthData = BirthData
        if Address is None:
            self.Address = []
        else:
            self.Address = Address
        if Telephone is None:
            self.Telephone = []
        else:
            self.Telephone = Telephone
        if ElectronicMail is None:
            self.ElectronicMail = []
        else:
            self.ElectronicMail = ElectronicMail
        self.ProfileThumbnail = ProfileThumbnail
        self.HispanicLatinoEthnicity = HispanicLatinoEthnicity
        self.OldEthnicity = OldEthnicity
        self.Race = Race
        self.EconomicDisadvantaged = EconomicDisadvantaged
        self.SchoolFoodServicesEligibility = SchoolFoodServicesEligibility
        if StudentCharacteristics is None:
            self.StudentCharacteristics = []
        else:
            self.StudentCharacteristics = StudentCharacteristics
        self.LimitedEnglishProficiency = LimitedEnglishProficiency
        self.Languages = Languages
        self.HomeLanguages = HomeLanguages
        if Disabilities is None:
            self.Disabilities = []
        else:
            self.Disabilities = Disabilities
        self.Section504Disabilities = Section504Disabilities
        self.DisplacementStatus = DisplacementStatus
        if ProgramParticipations is None:
            self.ProgramParticipations = []
        else:
            self.ProgramParticipations = ProgramParticipations
        self.LearningStyles = LearningStyles
        if CohortYears is None:
            self.CohortYears = []
        else:
            self.CohortYears = CohortYears
        if StudentIndicators is None:
            self.StudentIndicators = []
        else:
            self.StudentIndicators = StudentIndicators
    def factory(*args_, **kwargs_):
        if Student.subclass:
            return Student.subclass(*args_, **kwargs_)
        else:
            return Student(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StudentUniqueStateId(self): return self.StudentUniqueStateId
    def set_StudentUniqueStateId(self, StudentUniqueStateId): self.StudentUniqueStateId = StudentUniqueStateId
    def validate_UniqueStateIdentifier(self, value):
        # Validate type UniqueStateIdentifier, a restriction on xs:int.
        pass
    def get_StudentIdentificationCode(self): return self.StudentIdentificationCode
    def set_StudentIdentificationCode(self, StudentIdentificationCode): self.StudentIdentificationCode = StudentIdentificationCode
    def add_StudentIdentificationCode(self, value): self.StudentIdentificationCode.append(value)
    def insert_StudentIdentificationCode(self, index, value): self.StudentIdentificationCode[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_OtherName(self): return self.OtherName
    def set_OtherName(self, OtherName): self.OtherName = OtherName
    def add_OtherName(self, value): self.OtherName.append(value)
    def insert_OtherName(self, index, value): self.OtherName[index] = value
    def get_Sex(self): return self.Sex
    def set_Sex(self, Sex): self.Sex = Sex
    def validate_SexType(self, value):
        # Validate type SexType, a restriction on xs:token.
        pass
    def get_BirthData(self): return self.BirthData
    def set_BirthData(self, BirthData): self.BirthData = BirthData
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def add_Address(self, value): self.Address.append(value)
    def insert_Address(self, index, value): self.Address[index] = value
    def get_Telephone(self): return self.Telephone
    def set_Telephone(self, Telephone): self.Telephone = Telephone
    def add_Telephone(self, value): self.Telephone.append(value)
    def insert_Telephone(self, index, value): self.Telephone[index] = value
    def get_ElectronicMail(self): return self.ElectronicMail
    def set_ElectronicMail(self, ElectronicMail): self.ElectronicMail = ElectronicMail
    def add_ElectronicMail(self, value): self.ElectronicMail.append(value)
    def insert_ElectronicMail(self, index, value): self.ElectronicMail[index] = value
    def get_ProfileThumbnail(self): return self.ProfileThumbnail
    def set_ProfileThumbnail(self, ProfileThumbnail): self.ProfileThumbnail = ProfileThumbnail
    def validate_ProfileThumbnail(self, value):
        # Validate type ProfileThumbnail, a restriction on xs:string.
        pass
    def get_HispanicLatinoEthnicity(self): return self.HispanicLatinoEthnicity
    def set_HispanicLatinoEthnicity(self, HispanicLatinoEthnicity): self.HispanicLatinoEthnicity = HispanicLatinoEthnicity
    def get_OldEthnicity(self): return self.OldEthnicity
    def set_OldEthnicity(self, OldEthnicity): self.OldEthnicity = OldEthnicity
    def validate_OldEthnicityType(self, value):
        # Validate type OldEthnicityType, a restriction on xs:token.
        pass
    def get_Race(self): return self.Race
    def set_Race(self, Race): self.Race = Race
    def get_EconomicDisadvantaged(self): return self.EconomicDisadvantaged
    def set_EconomicDisadvantaged(self, EconomicDisadvantaged): self.EconomicDisadvantaged = EconomicDisadvantaged
    def get_SchoolFoodServicesEligibility(self): return self.SchoolFoodServicesEligibility
    def set_SchoolFoodServicesEligibility(self, SchoolFoodServicesEligibility): self.SchoolFoodServicesEligibility = SchoolFoodServicesEligibility
    def validate_SchoolFoodServicesEligibilityType(self, value):
        # Validate type SchoolFoodServicesEligibilityType, a restriction on xs:token.
        pass
    def get_StudentCharacteristics(self): return self.StudentCharacteristics
    def set_StudentCharacteristics(self, StudentCharacteristics): self.StudentCharacteristics = StudentCharacteristics
    def add_StudentCharacteristics(self, value): self.StudentCharacteristics.append(value)
    def insert_StudentCharacteristics(self, index, value): self.StudentCharacteristics[index] = value
    def get_LimitedEnglishProficiency(self): return self.LimitedEnglishProficiency
    def set_LimitedEnglishProficiency(self, LimitedEnglishProficiency): self.LimitedEnglishProficiency = LimitedEnglishProficiency
    def validate_LimitedEnglishProficiencyType(self, value):
        # Validate type LimitedEnglishProficiencyType, a restriction on xs:token.
        pass
    def get_Languages(self): return self.Languages
    def set_Languages(self, Languages): self.Languages = Languages
    def get_HomeLanguages(self): return self.HomeLanguages
    def set_HomeLanguages(self, HomeLanguages): self.HomeLanguages = HomeLanguages
    def get_Disabilities(self): return self.Disabilities
    def set_Disabilities(self, Disabilities): self.Disabilities = Disabilities
    def add_Disabilities(self, value): self.Disabilities.append(value)
    def insert_Disabilities(self, index, value): self.Disabilities[index] = value
    def get_Section504Disabilities(self): return self.Section504Disabilities
    def set_Section504Disabilities(self, Section504Disabilities): self.Section504Disabilities = Section504Disabilities
    def get_DisplacementStatus(self): return self.DisplacementStatus
    def set_DisplacementStatus(self, DisplacementStatus): self.DisplacementStatus = DisplacementStatus
    def validate_DisplacementStatusType(self, value):
        # Validate type DisplacementStatusType, a restriction on xs:string.
        pass
    def get_ProgramParticipations(self): return self.ProgramParticipations
    def set_ProgramParticipations(self, ProgramParticipations): self.ProgramParticipations = ProgramParticipations
    def add_ProgramParticipations(self, value): self.ProgramParticipations.append(value)
    def insert_ProgramParticipations(self, index, value): self.ProgramParticipations[index] = value
    def get_LearningStyles(self): return self.LearningStyles
    def set_LearningStyles(self, LearningStyles): self.LearningStyles = LearningStyles
    def get_CohortYears(self): return self.CohortYears
    def set_CohortYears(self, CohortYears): self.CohortYears = CohortYears
    def add_CohortYears(self, value): self.CohortYears.append(value)
    def insert_CohortYears(self, index, value): self.CohortYears[index] = value
    def get_StudentIndicators(self): return self.StudentIndicators
    def set_StudentIndicators(self, StudentIndicators): self.StudentIndicators = StudentIndicators
    def add_StudentIndicators(self, value): self.StudentIndicators.append(value)
    def insert_StudentIndicators(self, index, value): self.StudentIndicators[index] = value
    def export(self, outfile, level, namespace_='', name_='Student', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Student')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Student'):
        super(Student, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Student')
    def exportChildren(self, outfile, level, namespace_='', name_='Student', fromsubclass_=False):
        super(Student, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.StudentUniqueStateId is not None:
            showIndent(outfile, level)
            outfile.write('<%sStudentUniqueStateId>%s</%sStudentUniqueStateId>\n' % (namespace_, self.gds_format_integer(self.StudentUniqueStateId, input_name='StudentUniqueStateId'), namespace_))
        for StudentIdentificationCode_ in self.StudentIdentificationCode:
            StudentIdentificationCode_.export(outfile, level, namespace_, name_='StudentIdentificationCode')
        if self.Name:
            self.Name.export(outfile, level, namespace_, name_='Name', )
        for OtherName_ in self.OtherName:
            OtherName_.export(outfile, level, namespace_, name_='OtherName')
        if self.Sex is not None:
            showIndent(outfile, level)
            outfile.write('<%sSex>%s</%sSex>\n' % (namespace_, self.gds_format_string(quote_xml(self.Sex).encode(ExternalEncoding), input_name='Sex'), namespace_))
        if self.BirthData:
            self.BirthData.export(outfile, level, namespace_, name_='BirthData', )
        for Address_ in self.Address:
            Address_.export(outfile, level, namespace_, name_='Address')
        for Telephone_ in self.Telephone:
            Telephone_.export(outfile, level, namespace_, name_='Telephone')
        for ElectronicMail_ in self.ElectronicMail:
            ElectronicMail_.export(outfile, level, namespace_, name_='ElectronicMail')
        if self.ProfileThumbnail is not None:
            showIndent(outfile, level)
            outfile.write('<%sProfileThumbnail>%s</%sProfileThumbnail>\n' % (namespace_, self.gds_format_string(quote_xml(self.ProfileThumbnail).encode(ExternalEncoding), input_name='ProfileThumbnail'), namespace_))
        if self.HispanicLatinoEthnicity is not None:
            showIndent(outfile, level)
            outfile.write('<%sHispanicLatinoEthnicity>%s</%sHispanicLatinoEthnicity>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.HispanicLatinoEthnicity)), input_name='HispanicLatinoEthnicity'), namespace_))
        if self.OldEthnicity is not None:
            showIndent(outfile, level)
            outfile.write('<%sOldEthnicity>%s</%sOldEthnicity>\n' % (namespace_, self.gds_format_string(quote_xml(self.OldEthnicity).encode(ExternalEncoding), input_name='OldEthnicity'), namespace_))
        if self.Race:
            self.Race.export(outfile, level, namespace_, name_='Race', )
        if self.EconomicDisadvantaged is not None:
            showIndent(outfile, level)
            outfile.write('<%sEconomicDisadvantaged>%s</%sEconomicDisadvantaged>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.EconomicDisadvantaged)), input_name='EconomicDisadvantaged'), namespace_))
        if self.SchoolFoodServicesEligibility is not None:
            showIndent(outfile, level)
            outfile.write('<%sSchoolFoodServicesEligibility>%s</%sSchoolFoodServicesEligibility>\n' % (namespace_, self.gds_format_string(quote_xml(self.SchoolFoodServicesEligibility).encode(ExternalEncoding), input_name='SchoolFoodServicesEligibility'), namespace_))
        for StudentCharacteristics_ in self.StudentCharacteristics:
            StudentCharacteristics_.export(outfile, level, namespace_, name_='StudentCharacteristics')
        if self.LimitedEnglishProficiency is not None:
            showIndent(outfile, level)
            outfile.write('<%sLimitedEnglishProficiency>%s</%sLimitedEnglishProficiency>\n' % (namespace_, self.gds_format_string(quote_xml(self.LimitedEnglishProficiency).encode(ExternalEncoding), input_name='LimitedEnglishProficiency'), namespace_))
        if self.Languages:
            self.Languages.export(outfile, level, namespace_, name_='Languages')
        if self.HomeLanguages:
            self.HomeLanguages.export(outfile, level, namespace_, name_='HomeLanguages')
        for Disabilities_ in self.Disabilities:
            Disabilities_.export(outfile, level, namespace_, name_='Disabilities')
        if self.Section504Disabilities:
            self.Section504Disabilities.export(outfile, level, namespace_, name_='Section504Disabilities')
        if self.DisplacementStatus is not None:
            showIndent(outfile, level)
            outfile.write('<%sDisplacementStatus>%s</%sDisplacementStatus>\n' % (namespace_, self.gds_format_string(quote_xml(self.DisplacementStatus).encode(ExternalEncoding), input_name='DisplacementStatus'), namespace_))
        for ProgramParticipations_ in self.ProgramParticipations:
            ProgramParticipations_.export(outfile, level, namespace_, name_='ProgramParticipations')
        if self.LearningStyles:
            self.LearningStyles.export(outfile, level, namespace_, name_='LearningStyles')
        for CohortYears_ in self.CohortYears:
            CohortYears_.export(outfile, level, namespace_, name_='CohortYears')
        for StudentIndicators_ in self.StudentIndicators:
            StudentIndicators_.export(outfile, level, namespace_, name_='StudentIndicators')
    def hasContent_(self):
        if (
            self.StudentUniqueStateId is not None or
            self.StudentIdentificationCode or
            self.Name is not None or
            self.OtherName or
            self.Sex is not None or
            self.BirthData is not None or
            self.Address or
            self.Telephone or
            self.ElectronicMail or
            self.ProfileThumbnail is not None or
            self.HispanicLatinoEthnicity is not None or
            self.OldEthnicity is not None or
            self.Race is not None or
            self.EconomicDisadvantaged is not None or
            self.SchoolFoodServicesEligibility is not None or
            self.StudentCharacteristics or
            self.LimitedEnglishProficiency is not None or
            self.Languages is not None or
            self.HomeLanguages is not None or
            self.Disabilities or
            self.Section504Disabilities is not None or
            self.DisplacementStatus is not None or
            self.ProgramParticipations or
            self.LearningStyles is not None or
            self.CohortYears or
            self.StudentIndicators or
            super(Student, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Student'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Student, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Student, self).exportLiteralChildren(outfile, level, name_)
        if self.StudentUniqueStateId is not None:
            showIndent(outfile, level)
            outfile.write('StudentUniqueStateId=%d,\n' % self.StudentUniqueStateId)
        showIndent(outfile, level)
        outfile.write('StudentIdentificationCode=[\n')
        level += 1
        for StudentIdentificationCode_ in self.StudentIdentificationCode:
            showIndent(outfile, level)
            outfile.write('model_.StudentIdentificationCode(\n')
            StudentIdentificationCode_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=model_.Name(\n')
            self.Name.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('OtherName=[\n')
        level += 1
        for OtherName_ in self.OtherName:
            showIndent(outfile, level)
            outfile.write('model_.OtherName(\n')
            OtherName_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Sex is not None:
            showIndent(outfile, level)
            outfile.write('Sex=%s,\n' % quote_python(self.Sex).encode(ExternalEncoding))
        if self.BirthData is not None:
            showIndent(outfile, level)
            outfile.write('BirthData=model_.BirthData(\n')
            self.BirthData.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Address=[\n')
        level += 1
        for Address_ in self.Address:
            showIndent(outfile, level)
            outfile.write('model_.Address(\n')
            Address_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Telephone=[\n')
        level += 1
        for Telephone_ in self.Telephone:
            showIndent(outfile, level)
            outfile.write('model_.Telephone(\n')
            Telephone_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ElectronicMail=[\n')
        level += 1
        for ElectronicMail_ in self.ElectronicMail:
            showIndent(outfile, level)
            outfile.write('model_.ElectronicMail(\n')
            ElectronicMail_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ProfileThumbnail is not None:
            showIndent(outfile, level)
            outfile.write('ProfileThumbnail=%s,\n' % quote_python(self.ProfileThumbnail).encode(ExternalEncoding))
        if self.HispanicLatinoEthnicity is not None:
            showIndent(outfile, level)
            outfile.write('HispanicLatinoEthnicity=%s,\n' % self.HispanicLatinoEthnicity)
        if self.OldEthnicity is not None:
            showIndent(outfile, level)
            outfile.write('OldEthnicity=%s,\n' % quote_python(self.OldEthnicity).encode(ExternalEncoding))
        if self.Race is not None:
            showIndent(outfile, level)
            outfile.write('Race=model_.RaceType(\n')
            self.Race.exportLiteral(outfile, level, name_='Race')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.EconomicDisadvantaged is not None:
            showIndent(outfile, level)
            outfile.write('EconomicDisadvantaged=%s,\n' % self.EconomicDisadvantaged)
        if self.SchoolFoodServicesEligibility is not None:
            showIndent(outfile, level)
            outfile.write('SchoolFoodServicesEligibility=%s,\n' % quote_python(self.SchoolFoodServicesEligibility).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('StudentCharacteristics=[\n')
        level += 1
        for StudentCharacteristics_ in self.StudentCharacteristics:
            showIndent(outfile, level)
            outfile.write('model_.StudentCharacteristic(\n')
            StudentCharacteristics_.exportLiteral(outfile, level, name_='StudentCharacteristic')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.LimitedEnglishProficiency is not None:
            showIndent(outfile, level)
            outfile.write('LimitedEnglishProficiency=%s,\n' % quote_python(self.LimitedEnglishProficiency).encode(ExternalEncoding))
        if self.Languages is not None:
            showIndent(outfile, level)
            outfile.write('Languages=model_.LanguagesType(\n')
            self.Languages.exportLiteral(outfile, level, name_='Languages')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HomeLanguages is not None:
            showIndent(outfile, level)
            outfile.write('HomeLanguages=model_.LanguagesType(\n')
            self.HomeLanguages.exportLiteral(outfile, level, name_='HomeLanguages')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Disabilities=[\n')
        level += 1
        for Disabilities_ in self.Disabilities:
            showIndent(outfile, level)
            outfile.write('model_.Disability(\n')
            Disabilities_.exportLiteral(outfile, level, name_='Disability')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Section504Disabilities is not None:
            showIndent(outfile, level)
            outfile.write('Section504Disabilities=model_.Section504DisabilitiesType(\n')
            self.Section504Disabilities.exportLiteral(outfile, level, name_='Section504Disabilities')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DisplacementStatus is not None:
            showIndent(outfile, level)
            outfile.write('DisplacementStatus=%s,\n' % quote_python(self.DisplacementStatus).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('ProgramParticipations=[\n')
        level += 1
        for ProgramParticipations_ in self.ProgramParticipations:
            showIndent(outfile, level)
            outfile.write('model_.ProgramParticipation(\n')
            ProgramParticipations_.exportLiteral(outfile, level, name_='ProgramParticipation')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.LearningStyles is not None:
            showIndent(outfile, level)
            outfile.write('LearningStyles=model_.LearningStyles(\n')
            self.LearningStyles.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('CohortYears=[\n')
        level += 1
        for CohortYears_ in self.CohortYears:
            showIndent(outfile, level)
            outfile.write('model_.CohortYear(\n')
            CohortYears_.exportLiteral(outfile, level, name_='CohortYear')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('StudentIndicators=[\n')
        level += 1
        for StudentIndicators_ in self.StudentIndicators:
            showIndent(outfile, level)
            outfile.write('model_.StudentIndicator(\n')
            StudentIndicators_.exportLiteral(outfile, level, name_='StudentIndicator')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Student, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StudentUniqueStateId':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'StudentUniqueStateId')
            self.StudentUniqueStateId = ival_
            self.validate_UniqueStateIdentifier(self.StudentUniqueStateId)    # validate type UniqueStateIdentifier
        elif nodeName_ == 'StudentIdentificationCode':
            obj_ = StudentIdentificationCode.factory()
            obj_.build(child_)
            self.StudentIdentificationCode.append(obj_)
        elif nodeName_ == 'Name':
            obj_ = Name.factory()
            obj_.build(child_)
            self.set_Name(obj_)
        elif nodeName_ == 'OtherName':
            obj_ = OtherName.factory()
            obj_.build(child_)
            self.OtherName.append(obj_)
        elif nodeName_ == 'Sex':
            Sex_ = child_.text
            Sex_ = re_.sub(String_cleanup_pat_, " ", Sex_).strip()
            Sex_ = self.gds_validate_string(Sex_, node, 'Sex')
            self.Sex = Sex_
            self.validate_SexType(self.Sex)    # validate type SexType
        elif nodeName_ == 'BirthData':
            obj_ = BirthData.factory()
            obj_.build(child_)
            self.set_BirthData(obj_)
        elif nodeName_ == 'Address':
            obj_ = Address.factory()
            obj_.build(child_)
            self.Address.append(obj_)
        elif nodeName_ == 'Telephone':
            obj_ = Telephone.factory()
            obj_.build(child_)
            self.Telephone.append(obj_)
        elif nodeName_ == 'ElectronicMail':
            obj_ = ElectronicMail.factory()
            obj_.build(child_)
            self.ElectronicMail.append(obj_)
        elif nodeName_ == 'ProfileThumbnail':
            ProfileThumbnail_ = child_.text
            ProfileThumbnail_ = self.gds_validate_string(ProfileThumbnail_, node, 'ProfileThumbnail')
            self.ProfileThumbnail = ProfileThumbnail_
            self.validate_ProfileThumbnail(self.ProfileThumbnail)    # validate type ProfileThumbnail
        elif nodeName_ == 'HispanicLatinoEthnicity':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'HispanicLatinoEthnicity')
            self.HispanicLatinoEthnicity = ival_
        elif nodeName_ == 'OldEthnicity':
            OldEthnicity_ = child_.text
            OldEthnicity_ = re_.sub(String_cleanup_pat_, " ", OldEthnicity_).strip()
            OldEthnicity_ = self.gds_validate_string(OldEthnicity_, node, 'OldEthnicity')
            self.OldEthnicity = OldEthnicity_
            self.validate_OldEthnicityType(self.OldEthnicity)    # validate type OldEthnicityType
        elif nodeName_ == 'Race':
            obj_ = RaceType.factory()
            obj_.build(child_)
            self.set_Race(obj_)
        elif nodeName_ == 'EconomicDisadvantaged':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'EconomicDisadvantaged')
            self.EconomicDisadvantaged = ival_
        elif nodeName_ == 'SchoolFoodServicesEligibility':
            SchoolFoodServicesEligibility_ = child_.text
            SchoolFoodServicesEligibility_ = re_.sub(String_cleanup_pat_, " ", SchoolFoodServicesEligibility_).strip()
            SchoolFoodServicesEligibility_ = self.gds_validate_string(SchoolFoodServicesEligibility_, node, 'SchoolFoodServicesEligibility')
            self.SchoolFoodServicesEligibility = SchoolFoodServicesEligibility_
            self.validate_SchoolFoodServicesEligibilityType(self.SchoolFoodServicesEligibility)    # validate type SchoolFoodServicesEligibilityType
        elif nodeName_ == 'StudentCharacteristics':
            obj_ = StudentCharacteristic.factory()
            obj_.build(child_)
            self.StudentCharacteristics.append(obj_)
        elif nodeName_ == 'LimitedEnglishProficiency':
            LimitedEnglishProficiency_ = child_.text
            LimitedEnglishProficiency_ = re_.sub(String_cleanup_pat_, " ", LimitedEnglishProficiency_).strip()
            LimitedEnglishProficiency_ = self.gds_validate_string(LimitedEnglishProficiency_, node, 'LimitedEnglishProficiency')
            self.LimitedEnglishProficiency = LimitedEnglishProficiency_
            self.validate_LimitedEnglishProficiencyType(self.LimitedEnglishProficiency)    # validate type LimitedEnglishProficiencyType
        elif nodeName_ == 'Languages':
            obj_ = LanguagesType.factory()
            obj_.build(child_)
            self.set_Languages(obj_)
        elif nodeName_ == 'HomeLanguages':
            obj_ = LanguagesType.factory()
            obj_.build(child_)
            self.set_HomeLanguages(obj_)
        elif nodeName_ == 'Disabilities':
            obj_ = Disability.factory()
            obj_.build(child_)
            self.Disabilities.append(obj_)
        elif nodeName_ == 'Section504Disabilities':
            obj_ = Section504DisabilitiesType.factory()
            obj_.build(child_)
            self.set_Section504Disabilities(obj_)
        elif nodeName_ == 'DisplacementStatus':
            DisplacementStatus_ = child_.text
            DisplacementStatus_ = self.gds_validate_string(DisplacementStatus_, node, 'DisplacementStatus')
            self.DisplacementStatus = DisplacementStatus_
            self.validate_DisplacementStatusType(self.DisplacementStatus)    # validate type DisplacementStatusType
        elif nodeName_ == 'ProgramParticipations':
            obj_ = ProgramParticipation.factory()
            obj_.build(child_)
            self.ProgramParticipations.append(obj_)
        elif nodeName_ == 'LearningStyles':
            obj_ = LearningStyles.factory()
            obj_.build(child_)
            self.set_LearningStyles(obj_)
        elif nodeName_ == 'CohortYears':
            obj_ = CohortYear.factory()
            obj_.build(child_)
            self.CohortYears.append(obj_)
        elif nodeName_ == 'StudentIndicators':
            obj_ = StudentIndicator.factory()
            obj_.build(child_)
            self.StudentIndicators.append(obj_)
        super(Student, self).buildChildren(child_, node, nodeName_, True)
# end class Student


class Staff(ComplexObjectType):
    """This entity represents an individual who performs specified
    activities for any public or private education institution or
    agency that provides instructional and/or support services to
    students or staff at the early childhood level through high
    school completion. For example, this includes: 1) an "employee"
    who performs services under the direction of the employing
    institution or agency, is compensated for such services by the
    employer, and is eligible for employee benefits and wage or
    salary tax withholdings; 2) a "contractor" or "consultant" who
    performs services for an agreed upon fee, or an employee of a
    management service contracted to work on site; 3) a "volunteer"
    who performs services on a voluntary and uncompensated basis; 4)
    an in kind service provider; or 5) an independent contractor or
    businessperson working at a school site."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, StaffUniqueStateId=None, StaffIdentificationCode=None, Name=None, OtherName=None, Sex=None, BirthDate=None, Address=None, Telephone=None, ElectronicMail=None, HispanicLatinoEthnicity=None, OldEthnicity=None, Race=None, HighestLevelOfEducationCompleted=None, YearsOfPriorProfessionalExperience=None, YearsOfPriorTeachingExperience=None, Credentials=None, extensiontype_=None):
        super(Staff, self).__init__(id, extensiontype_, )
        self.StaffUniqueStateId = StaffUniqueStateId
        if StaffIdentificationCode is None:
            self.StaffIdentificationCode = []
        else:
            self.StaffIdentificationCode = StaffIdentificationCode
        self.Name = Name
        if OtherName is None:
            self.OtherName = []
        else:
            self.OtherName = OtherName
        self.Sex = Sex
        self.BirthDate = BirthDate
        if Address is None:
            self.Address = []
        else:
            self.Address = Address
        if Telephone is None:
            self.Telephone = []
        else:
            self.Telephone = Telephone
        if ElectronicMail is None:
            self.ElectronicMail = []
        else:
            self.ElectronicMail = ElectronicMail
        self.HispanicLatinoEthnicity = HispanicLatinoEthnicity
        self.OldEthnicity = OldEthnicity
        self.Race = Race
        self.HighestLevelOfEducationCompleted = HighestLevelOfEducationCompleted
        self.YearsOfPriorProfessionalExperience = YearsOfPriorProfessionalExperience
        self.YearsOfPriorTeachingExperience = YearsOfPriorTeachingExperience
        if Credentials is None:
            self.Credentials = []
        else:
            self.Credentials = Credentials
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if Staff.subclass:
            return Staff.subclass(*args_, **kwargs_)
        else:
            return Staff(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StaffUniqueStateId(self): return self.StaffUniqueStateId
    def set_StaffUniqueStateId(self, StaffUniqueStateId): self.StaffUniqueStateId = StaffUniqueStateId
    def validate_UniqueStateIdentifier(self, value):
        # Validate type UniqueStateIdentifier, a restriction on xs:int.
        pass
    def get_StaffIdentificationCode(self): return self.StaffIdentificationCode
    def set_StaffIdentificationCode(self, StaffIdentificationCode): self.StaffIdentificationCode = StaffIdentificationCode
    def add_StaffIdentificationCode(self, value): self.StaffIdentificationCode.append(value)
    def insert_StaffIdentificationCode(self, index, value): self.StaffIdentificationCode[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_OtherName(self): return self.OtherName
    def set_OtherName(self, OtherName): self.OtherName = OtherName
    def add_OtherName(self, value): self.OtherName.append(value)
    def insert_OtherName(self, index, value): self.OtherName[index] = value
    def get_Sex(self): return self.Sex
    def set_Sex(self, Sex): self.Sex = Sex
    def validate_SexType(self, value):
        # Validate type SexType, a restriction on xs:token.
        pass
    def get_BirthDate(self): return self.BirthDate
    def set_BirthDate(self, BirthDate): self.BirthDate = BirthDate
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def add_Address(self, value): self.Address.append(value)
    def insert_Address(self, index, value): self.Address[index] = value
    def get_Telephone(self): return self.Telephone
    def set_Telephone(self, Telephone): self.Telephone = Telephone
    def add_Telephone(self, value): self.Telephone.append(value)
    def insert_Telephone(self, index, value): self.Telephone[index] = value
    def get_ElectronicMail(self): return self.ElectronicMail
    def set_ElectronicMail(self, ElectronicMail): self.ElectronicMail = ElectronicMail
    def add_ElectronicMail(self, value): self.ElectronicMail.append(value)
    def insert_ElectronicMail(self, index, value): self.ElectronicMail[index] = value
    def get_HispanicLatinoEthnicity(self): return self.HispanicLatinoEthnicity
    def set_HispanicLatinoEthnicity(self, HispanicLatinoEthnicity): self.HispanicLatinoEthnicity = HispanicLatinoEthnicity
    def get_OldEthnicity(self): return self.OldEthnicity
    def set_OldEthnicity(self, OldEthnicity): self.OldEthnicity = OldEthnicity
    def validate_OldEthnicityType(self, value):
        # Validate type OldEthnicityType, a restriction on xs:token.
        pass
    def get_Race(self): return self.Race
    def set_Race(self, Race): self.Race = Race
    def get_HighestLevelOfEducationCompleted(self): return self.HighestLevelOfEducationCompleted
    def set_HighestLevelOfEducationCompleted(self, HighestLevelOfEducationCompleted): self.HighestLevelOfEducationCompleted = HighestLevelOfEducationCompleted
    def validate_LevelOfEducationType(self, value):
        # Validate type LevelOfEducationType, a restriction on xs:token.
        pass
    def get_YearsOfPriorProfessionalExperience(self): return self.YearsOfPriorProfessionalExperience
    def set_YearsOfPriorProfessionalExperience(self, YearsOfPriorProfessionalExperience): self.YearsOfPriorProfessionalExperience = YearsOfPriorProfessionalExperience
    def get_YearsOfPriorTeachingExperience(self): return self.YearsOfPriorTeachingExperience
    def set_YearsOfPriorTeachingExperience(self, YearsOfPriorTeachingExperience): self.YearsOfPriorTeachingExperience = YearsOfPriorTeachingExperience
    def get_Credentials(self): return self.Credentials
    def set_Credentials(self, Credentials): self.Credentials = Credentials
    def add_Credentials(self, value): self.Credentials.append(value)
    def insert_Credentials(self, index, value): self.Credentials[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='Staff', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Staff')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Staff'):
        super(Staff, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Staff')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Staff', fromsubclass_=False):
        super(Staff, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.StaffUniqueStateId is not None:
            showIndent(outfile, level)
            outfile.write('<%sStaffUniqueStateId>%s</%sStaffUniqueStateId>\n' % (namespace_, self.gds_format_integer(self.StaffUniqueStateId, input_name='StaffUniqueStateId'), namespace_))
        for StaffIdentificationCode_ in self.StaffIdentificationCode:
            StaffIdentificationCode_.export(outfile, level, namespace_, name_='StaffIdentificationCode')
        if self.Name:
            self.Name.export(outfile, level, namespace_, name_='Name', )
        for OtherName_ in self.OtherName:
            OtherName_.export(outfile, level, namespace_, name_='OtherName')
        if self.Sex is not None:
            showIndent(outfile, level)
            outfile.write('<%sSex>%s</%sSex>\n' % (namespace_, self.gds_format_string(quote_xml(self.Sex).encode(ExternalEncoding), input_name='Sex'), namespace_))
        if self.BirthDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sBirthDate>%s</%sBirthDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.BirthDate).encode(ExternalEncoding), input_name='BirthDate'), namespace_))
        for Address_ in self.Address:
            Address_.export(outfile, level, namespace_, name_='Address')
        for Telephone_ in self.Telephone:
            Telephone_.export(outfile, level, namespace_, name_='Telephone')
        for ElectronicMail_ in self.ElectronicMail:
            ElectronicMail_.export(outfile, level, namespace_, name_='ElectronicMail')
        if self.HispanicLatinoEthnicity is not None:
            showIndent(outfile, level)
            outfile.write('<%sHispanicLatinoEthnicity>%s</%sHispanicLatinoEthnicity>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.HispanicLatinoEthnicity)), input_name='HispanicLatinoEthnicity'), namespace_))
        if self.OldEthnicity is not None:
            showIndent(outfile, level)
            outfile.write('<%sOldEthnicity>%s</%sOldEthnicity>\n' % (namespace_, self.gds_format_string(quote_xml(self.OldEthnicity).encode(ExternalEncoding), input_name='OldEthnicity'), namespace_))
        if self.Race:
            self.Race.export(outfile, level, namespace_, name_='Race', )
        if self.HighestLevelOfEducationCompleted is not None:
            showIndent(outfile, level)
            outfile.write('<%sHighestLevelOfEducationCompleted>%s</%sHighestLevelOfEducationCompleted>\n' % (namespace_, self.gds_format_string(quote_xml(self.HighestLevelOfEducationCompleted).encode(ExternalEncoding), input_name='HighestLevelOfEducationCompleted'), namespace_))
        if self.YearsOfPriorProfessionalExperience is not None:
            showIndent(outfile, level)
            outfile.write('<%sYearsOfPriorProfessionalExperience>%s</%sYearsOfPriorProfessionalExperience>\n' % (namespace_, self.gds_format_integer(self.YearsOfPriorProfessionalExperience, input_name='YearsOfPriorProfessionalExperience'), namespace_))
        if self.YearsOfPriorTeachingExperience is not None:
            showIndent(outfile, level)
            outfile.write('<%sYearsOfPriorTeachingExperience>%s</%sYearsOfPriorTeachingExperience>\n' % (namespace_, self.gds_format_integer(self.YearsOfPriorTeachingExperience, input_name='YearsOfPriorTeachingExperience'), namespace_))
        for Credentials_ in self.Credentials:
            Credentials_.export(outfile, level, namespace_, name_='Credentials')
    def hasContent_(self):
        if (
            self.StaffUniqueStateId is not None or
            self.StaffIdentificationCode or
            self.Name is not None or
            self.OtherName or
            self.Sex is not None or
            self.BirthDate is not None or
            self.Address or
            self.Telephone or
            self.ElectronicMail or
            self.HispanicLatinoEthnicity is not None or
            self.OldEthnicity is not None or
            self.Race is not None or
            self.HighestLevelOfEducationCompleted is not None or
            self.YearsOfPriorProfessionalExperience is not None or
            self.YearsOfPriorTeachingExperience is not None or
            self.Credentials or
            super(Staff, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Staff'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Staff, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Staff, self).exportLiteralChildren(outfile, level, name_)
        if self.StaffUniqueStateId is not None:
            showIndent(outfile, level)
            outfile.write('StaffUniqueStateId=%d,\n' % self.StaffUniqueStateId)
        showIndent(outfile, level)
        outfile.write('StaffIdentificationCode=[\n')
        level += 1
        for StaffIdentificationCode_ in self.StaffIdentificationCode:
            showIndent(outfile, level)
            outfile.write('model_.StaffIdentificationCode(\n')
            StaffIdentificationCode_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=model_.Name(\n')
            self.Name.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('OtherName=[\n')
        level += 1
        for OtherName_ in self.OtherName:
            showIndent(outfile, level)
            outfile.write('model_.OtherName(\n')
            OtherName_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Sex is not None:
            showIndent(outfile, level)
            outfile.write('Sex=%s,\n' % quote_python(self.Sex).encode(ExternalEncoding))
        if self.BirthDate is not None:
            showIndent(outfile, level)
            outfile.write('BirthDate=%s,\n' % quote_python(self.BirthDate).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Address=[\n')
        level += 1
        for Address_ in self.Address:
            showIndent(outfile, level)
            outfile.write('model_.Address(\n')
            Address_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Telephone=[\n')
        level += 1
        for Telephone_ in self.Telephone:
            showIndent(outfile, level)
            outfile.write('model_.Telephone(\n')
            Telephone_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ElectronicMail=[\n')
        level += 1
        for ElectronicMail_ in self.ElectronicMail:
            showIndent(outfile, level)
            outfile.write('model_.ElectronicMail(\n')
            ElectronicMail_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.HispanicLatinoEthnicity is not None:
            showIndent(outfile, level)
            outfile.write('HispanicLatinoEthnicity=%s,\n' % self.HispanicLatinoEthnicity)
        if self.OldEthnicity is not None:
            showIndent(outfile, level)
            outfile.write('OldEthnicity=%s,\n' % quote_python(self.OldEthnicity).encode(ExternalEncoding))
        if self.Race is not None:
            showIndent(outfile, level)
            outfile.write('Race=model_.RaceType(\n')
            self.Race.exportLiteral(outfile, level, name_='Race')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HighestLevelOfEducationCompleted is not None:
            showIndent(outfile, level)
            outfile.write('HighestLevelOfEducationCompleted=%s,\n' % quote_python(self.HighestLevelOfEducationCompleted).encode(ExternalEncoding))
        if self.YearsOfPriorProfessionalExperience is not None:
            showIndent(outfile, level)
            outfile.write('YearsOfPriorProfessionalExperience=%d,\n' % self.YearsOfPriorProfessionalExperience)
        if self.YearsOfPriorTeachingExperience is not None:
            showIndent(outfile, level)
            outfile.write('YearsOfPriorTeachingExperience=%d,\n' % self.YearsOfPriorTeachingExperience)
        showIndent(outfile, level)
        outfile.write('Credentials=[\n')
        level += 1
        for Credentials_ in self.Credentials:
            showIndent(outfile, level)
            outfile.write('model_.Credential(\n')
            Credentials_.exportLiteral(outfile, level, name_='Credential')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(Staff, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StaffUniqueStateId':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'StaffUniqueStateId')
            self.StaffUniqueStateId = ival_
            self.validate_UniqueStateIdentifier(self.StaffUniqueStateId)    # validate type UniqueStateIdentifier
        elif nodeName_ == 'StaffIdentificationCode':
            obj_ = StaffIdentificationCode.factory()
            obj_.build(child_)
            self.StaffIdentificationCode.append(obj_)
        elif nodeName_ == 'Name':
            obj_ = Name.factory()
            obj_.build(child_)
            self.set_Name(obj_)
        elif nodeName_ == 'OtherName':
            obj_ = OtherName.factory()
            obj_.build(child_)
            self.OtherName.append(obj_)
        elif nodeName_ == 'Sex':
            Sex_ = child_.text
            Sex_ = re_.sub(String_cleanup_pat_, " ", Sex_).strip()
            Sex_ = self.gds_validate_string(Sex_, node, 'Sex')
            self.Sex = Sex_
            self.validate_SexType(self.Sex)    # validate type SexType
        elif nodeName_ == 'BirthDate':
            BirthDate_ = child_.text
            BirthDate_ = self.gds_validate_string(BirthDate_, node, 'BirthDate')
            self.BirthDate = BirthDate_
        elif nodeName_ == 'Address':
            obj_ = Address.factory()
            obj_.build(child_)
            self.Address.append(obj_)
        elif nodeName_ == 'Telephone':
            obj_ = Telephone.factory()
            obj_.build(child_)
            self.Telephone.append(obj_)
        elif nodeName_ == 'ElectronicMail':
            obj_ = ElectronicMail.factory()
            obj_.build(child_)
            self.ElectronicMail.append(obj_)
        elif nodeName_ == 'HispanicLatinoEthnicity':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'HispanicLatinoEthnicity')
            self.HispanicLatinoEthnicity = ival_
        elif nodeName_ == 'OldEthnicity':
            OldEthnicity_ = child_.text
            OldEthnicity_ = re_.sub(String_cleanup_pat_, " ", OldEthnicity_).strip()
            OldEthnicity_ = self.gds_validate_string(OldEthnicity_, node, 'OldEthnicity')
            self.OldEthnicity = OldEthnicity_
            self.validate_OldEthnicityType(self.OldEthnicity)    # validate type OldEthnicityType
        elif nodeName_ == 'Race':
            obj_ = RaceType.factory()
            obj_.build(child_)
            self.set_Race(obj_)
        elif nodeName_ == 'HighestLevelOfEducationCompleted':
            HighestLevelOfEducationCompleted_ = child_.text
            HighestLevelOfEducationCompleted_ = re_.sub(String_cleanup_pat_, " ", HighestLevelOfEducationCompleted_).strip()
            HighestLevelOfEducationCompleted_ = self.gds_validate_string(HighestLevelOfEducationCompleted_, node, 'HighestLevelOfEducationCompleted')
            self.HighestLevelOfEducationCompleted = HighestLevelOfEducationCompleted_
            self.validate_LevelOfEducationType(self.HighestLevelOfEducationCompleted)    # validate type LevelOfEducationType
        elif nodeName_ == 'YearsOfPriorProfessionalExperience':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'YearsOfPriorProfessionalExperience')
            self.YearsOfPriorProfessionalExperience = ival_
        elif nodeName_ == 'YearsOfPriorTeachingExperience':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'YearsOfPriorTeachingExperience')
            self.YearsOfPriorTeachingExperience = ival_
        elif nodeName_ == 'Credentials':
            obj_ = Credential.factory()
            obj_.build(child_)
            self.Credentials.append(obj_)
        super(Staff, self).buildChildren(child_, node, nodeName_, True)
# end class Staff


class Session(ComplexObjectType):
    """A calendar of days made available to instruct students. The school
    calendar could be organized by semester, or by school year plus
    summer school."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, SessionName=None, SessionType=None, SchoolYear=None, BeginDate=None, EndDate=None, TotalInstructionalDays=None, EducationOrganizationReference=None, GradingPeriodReference=None, CalendarDateReference=None, AcademicWeekReference=None):
        super(Session, self).__init__(id, )
        self.SessionName = SessionName
        self.SessionType = SessionType
        self.SchoolYear = SchoolYear
        self.BeginDate = BeginDate
        self.EndDate = EndDate
        self.TotalInstructionalDays = TotalInstructionalDays
        self.EducationOrganizationReference = EducationOrganizationReference
        if GradingPeriodReference is None:
            self.GradingPeriodReference = []
        else:
            self.GradingPeriodReference = GradingPeriodReference
        if CalendarDateReference is None:
            self.CalendarDateReference = []
        else:
            self.CalendarDateReference = CalendarDateReference
        if AcademicWeekReference is None:
            self.AcademicWeekReference = []
        else:
            self.AcademicWeekReference = AcademicWeekReference
    def factory(*args_, **kwargs_):
        if Session.subclass:
            return Session.subclass(*args_, **kwargs_)
        else:
            return Session(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SessionName(self): return self.SessionName
    def set_SessionName(self, SessionName): self.SessionName = SessionName
    def validate_IdentificationCode(self, value):
        # Validate type IdentificationCode, a restriction on xs:string.
        pass
    def get_SessionType(self): return self.SessionType
    def set_SessionType(self, SessionType): self.SessionType = SessionType
    def validate_SessionType(self, value):
        # Validate type SessionType, a restriction on xs:token.
        pass
    def get_SchoolYear(self): return self.SchoolYear
    def set_SchoolYear(self, SchoolYear): self.SchoolYear = SchoolYear
    def validate_SchoolYearType(self, value):
        # Validate type SchoolYearType, a restriction on xs:token.
        pass
    def get_BeginDate(self): return self.BeginDate
    def set_BeginDate(self, BeginDate): self.BeginDate = BeginDate
    def get_EndDate(self): return self.EndDate
    def set_EndDate(self, EndDate): self.EndDate = EndDate
    def get_TotalInstructionalDays(self): return self.TotalInstructionalDays
    def set_TotalInstructionalDays(self, TotalInstructionalDays): self.TotalInstructionalDays = TotalInstructionalDays
    def get_EducationOrganizationReference(self): return self.EducationOrganizationReference
    def set_EducationOrganizationReference(self, EducationOrganizationReference): self.EducationOrganizationReference = EducationOrganizationReference
    def get_GradingPeriodReference(self): return self.GradingPeriodReference
    def set_GradingPeriodReference(self, GradingPeriodReference): self.GradingPeriodReference = GradingPeriodReference
    def add_GradingPeriodReference(self, value): self.GradingPeriodReference.append(value)
    def insert_GradingPeriodReference(self, index, value): self.GradingPeriodReference[index] = value
    def get_CalendarDateReference(self): return self.CalendarDateReference
    def set_CalendarDateReference(self, CalendarDateReference): self.CalendarDateReference = CalendarDateReference
    def add_CalendarDateReference(self, value): self.CalendarDateReference.append(value)
    def insert_CalendarDateReference(self, index, value): self.CalendarDateReference[index] = value
    def get_AcademicWeekReference(self): return self.AcademicWeekReference
    def set_AcademicWeekReference(self, AcademicWeekReference): self.AcademicWeekReference = AcademicWeekReference
    def add_AcademicWeekReference(self, value): self.AcademicWeekReference.append(value)
    def insert_AcademicWeekReference(self, index, value): self.AcademicWeekReference[index] = value
    def export(self, outfile, level, namespace_='', name_='Session', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Session')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Session'):
        super(Session, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Session')
    def exportChildren(self, outfile, level, namespace_='', name_='Session', fromsubclass_=False):
        super(Session, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.SessionName is not None:
            showIndent(outfile, level)
            outfile.write('<%sSessionName>%s</%sSessionName>\n' % (namespace_, self.gds_format_string(quote_xml(self.SessionName).encode(ExternalEncoding), input_name='SessionName'), namespace_))
        if self.SessionType is not None:
            showIndent(outfile, level)
            outfile.write('<%sSessionType>%s</%sSessionType>\n' % (namespace_, self.gds_format_string(quote_xml(self.SessionType).encode(ExternalEncoding), input_name='SessionType'), namespace_))
        if self.SchoolYear is not None:
            showIndent(outfile, level)
            outfile.write('<%sSchoolYear>%s</%sSchoolYear>\n' % (namespace_, self.gds_format_string(quote_xml(self.SchoolYear).encode(ExternalEncoding), input_name='SchoolYear'), namespace_))
        if self.BeginDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sBeginDate>%s</%sBeginDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.BeginDate).encode(ExternalEncoding), input_name='BeginDate'), namespace_))
        if self.EndDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sEndDate>%s</%sEndDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.EndDate).encode(ExternalEncoding), input_name='EndDate'), namespace_))
        if self.TotalInstructionalDays is not None:
            showIndent(outfile, level)
            outfile.write('<%sTotalInstructionalDays>%s</%sTotalInstructionalDays>\n' % (namespace_, self.gds_format_integer(self.TotalInstructionalDays, input_name='TotalInstructionalDays'), namespace_))
        if self.EducationOrganizationReference:
            self.EducationOrganizationReference.export(outfile, level, namespace_, name_='EducationOrganizationReference', )
        for GradingPeriodReference_ in self.GradingPeriodReference:
            GradingPeriodReference_.export(outfile, level, namespace_, name_='GradingPeriodReference')
        for CalendarDateReference_ in self.CalendarDateReference:
            CalendarDateReference_.export(outfile, level, namespace_, name_='CalendarDateReference')
        for AcademicWeekReference_ in self.AcademicWeekReference:
            AcademicWeekReference_.export(outfile, level, namespace_, name_='AcademicWeekReference')
    def hasContent_(self):
        if (
            self.SessionName is not None or
            self.SessionType is not None or
            self.SchoolYear is not None or
            self.BeginDate is not None or
            self.EndDate is not None or
            self.TotalInstructionalDays is not None or
            self.EducationOrganizationReference is not None or
            self.GradingPeriodReference or
            self.CalendarDateReference or
            self.AcademicWeekReference or
            super(Session, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Session'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Session, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Session, self).exportLiteralChildren(outfile, level, name_)
        if self.SessionName is not None:
            showIndent(outfile, level)
            outfile.write('SessionName=%s,\n' % quote_python(self.SessionName).encode(ExternalEncoding))
        if self.SessionType is not None:
            showIndent(outfile, level)
            outfile.write('SessionType=%s,\n' % quote_python(self.SessionType).encode(ExternalEncoding))
        if self.SchoolYear is not None:
            showIndent(outfile, level)
            outfile.write('SchoolYear=%s,\n' % quote_python(self.SchoolYear).encode(ExternalEncoding))
        if self.BeginDate is not None:
            showIndent(outfile, level)
            outfile.write('BeginDate=%s,\n' % quote_python(self.BeginDate).encode(ExternalEncoding))
        if self.EndDate is not None:
            showIndent(outfile, level)
            outfile.write('EndDate=%s,\n' % quote_python(self.EndDate).encode(ExternalEncoding))
        if self.TotalInstructionalDays is not None:
            showIndent(outfile, level)
            outfile.write('TotalInstructionalDays=%d,\n' % self.TotalInstructionalDays)
        if self.EducationOrganizationReference is not None:
            showIndent(outfile, level)
            outfile.write('EducationOrganizationReference=model_.EducationalOrgReferenceType(\n')
            self.EducationOrganizationReference.exportLiteral(outfile, level, name_='EducationOrganizationReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('GradingPeriodReference=[\n')
        level += 1
        for GradingPeriodReference_ in self.GradingPeriodReference:
            showIndent(outfile, level)
            outfile.write('model_.GradingPeriodReferenceType(\n')
            GradingPeriodReference_.exportLiteral(outfile, level, name_='GradingPeriodReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CalendarDateReference=[\n')
        level += 1
        for CalendarDateReference_ in self.CalendarDateReference:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            CalendarDateReference_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AcademicWeekReference=[\n')
        level += 1
        for AcademicWeekReference_ in self.AcademicWeekReference:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            AcademicWeekReference_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Session, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SessionName':
            SessionName_ = child_.text
            SessionName_ = self.gds_validate_string(SessionName_, node, 'SessionName')
            self.SessionName = SessionName_
            self.validate_IdentificationCode(self.SessionName)    # validate type IdentificationCode
        elif nodeName_ == 'SessionType':
            SessionType_ = child_.text
            SessionType_ = re_.sub(String_cleanup_pat_, " ", SessionType_).strip()
            SessionType_ = self.gds_validate_string(SessionType_, node, 'SessionType')
            self.SessionType = SessionType_
            self.validate_SessionType(self.SessionType)    # validate type SessionType
        elif nodeName_ == 'SchoolYear':
            SchoolYear_ = child_.text
            SchoolYear_ = re_.sub(String_cleanup_pat_, " ", SchoolYear_).strip()
            SchoolYear_ = self.gds_validate_string(SchoolYear_, node, 'SchoolYear')
            self.SchoolYear = SchoolYear_
            self.validate_SchoolYearType(self.SchoolYear)    # validate type SchoolYearType
        elif nodeName_ == 'BeginDate':
            BeginDate_ = child_.text
            BeginDate_ = self.gds_validate_string(BeginDate_, node, 'BeginDate')
            self.BeginDate = BeginDate_
        elif nodeName_ == 'EndDate':
            EndDate_ = child_.text
            EndDate_ = self.gds_validate_string(EndDate_, node, 'EndDate')
            self.EndDate = EndDate_
        elif nodeName_ == 'TotalInstructionalDays':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TotalInstructionalDays')
            self.TotalInstructionalDays = ival_
        elif nodeName_ == 'EducationOrganizationReference':
            obj_ = EducationalOrgReferenceType.factory()
            obj_.build(child_)
            self.set_EducationOrganizationReference(obj_)
        elif nodeName_ == 'GradingPeriodReference':
            obj_ = GradingPeriodReferenceType.factory()
            obj_.build(child_)
            self.GradingPeriodReference.append(obj_)
        elif nodeName_ == 'CalendarDateReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.CalendarDateReference.append(obj_)
        elif nodeName_ == 'AcademicWeekReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.AcademicWeekReference.append(obj_)
        super(Session, self).buildChildren(child_, node, nodeName_, True)
# end class Session


class Section(ComplexObjectType):
    """This educational entity represents a setting in which organized
    instruction of course content is provided to one or more
    students for a given period of time. A course may be offered to
    more than one class/section. Instruction, provided by one or
    more teachers or other staff members, may be delivered in person
    or via a different medium."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, UniqueSectionCode=None, Term=None, SequenceOfCourse=None, EducationalEnvironment=None, MediumOfInstruction=None, PopulationServed=None, AvailableCredit=None, CourseReference=None, SchoolReference=None, LocationReference=None, ClassPeriodReference=None, ProgramReference=None):
        super(Section, self).__init__(id, )
        self.UniqueSectionCode = UniqueSectionCode
        self.Term = Term
        self.SequenceOfCourse = SequenceOfCourse
        self.EducationalEnvironment = EducationalEnvironment
        self.MediumOfInstruction = MediumOfInstruction
        self.PopulationServed = PopulationServed
        self.AvailableCredit = AvailableCredit
        self.CourseReference = CourseReference
        self.SchoolReference = SchoolReference
        self.LocationReference = LocationReference
        self.ClassPeriodReference = ClassPeriodReference
        if ProgramReference is None:
            self.ProgramReference = []
        else:
            self.ProgramReference = ProgramReference
    def factory(*args_, **kwargs_):
        if Section.subclass:
            return Section.subclass(*args_, **kwargs_)
        else:
            return Section(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UniqueSectionCode(self): return self.UniqueSectionCode
    def set_UniqueSectionCode(self, UniqueSectionCode): self.UniqueSectionCode = UniqueSectionCode
    def validate_UniqueSectionCode(self, value):
        # Validate type UniqueSectionCode, a restriction on xs:string.
        pass
    def get_Term(self): return self.Term
    def set_Term(self, Term): self.Term = Term
    def validate_TermType(self, value):
        # Validate type TermType, a restriction on xs:token.
        pass
    def get_SequenceOfCourse(self): return self.SequenceOfCourse
    def set_SequenceOfCourse(self, SequenceOfCourse): self.SequenceOfCourse = SequenceOfCourse
    def get_EducationalEnvironment(self): return self.EducationalEnvironment
    def set_EducationalEnvironment(self, EducationalEnvironment): self.EducationalEnvironment = EducationalEnvironment
    def validate_EducationalEnvironmentType(self, value):
        # Validate type EducationalEnvironmentType, a restriction on xs:token.
        pass
    def get_MediumOfInstruction(self): return self.MediumOfInstruction
    def set_MediumOfInstruction(self, MediumOfInstruction): self.MediumOfInstruction = MediumOfInstruction
    def validate_MediumOfInstructionType(self, value):
        # Validate type MediumOfInstructionType, a restriction on xs:token.
        pass
    def get_PopulationServed(self): return self.PopulationServed
    def set_PopulationServed(self, PopulationServed): self.PopulationServed = PopulationServed
    def validate_PopulationServedType(self, value):
        # Validate type PopulationServedType, a restriction on xs:token.
        pass
    def get_AvailableCredit(self): return self.AvailableCredit
    def set_AvailableCredit(self, AvailableCredit): self.AvailableCredit = AvailableCredit
    def get_CourseReference(self): return self.CourseReference
    def set_CourseReference(self, CourseReference): self.CourseReference = CourseReference
    def get_SchoolReference(self): return self.SchoolReference
    def set_SchoolReference(self, SchoolReference): self.SchoolReference = SchoolReference
    def get_LocationReference(self): return self.LocationReference
    def set_LocationReference(self, LocationReference): self.LocationReference = LocationReference
    def get_ClassPeriodReference(self): return self.ClassPeriodReference
    def set_ClassPeriodReference(self, ClassPeriodReference): self.ClassPeriodReference = ClassPeriodReference
    def get_ProgramReference(self): return self.ProgramReference
    def set_ProgramReference(self, ProgramReference): self.ProgramReference = ProgramReference
    def add_ProgramReference(self, value): self.ProgramReference.append(value)
    def insert_ProgramReference(self, index, value): self.ProgramReference[index] = value
    def export(self, outfile, level, namespace_='', name_='Section', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Section')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Section'):
        super(Section, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Section')
    def exportChildren(self, outfile, level, namespace_='', name_='Section', fromsubclass_=False):
        super(Section, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.UniqueSectionCode is not None:
            showIndent(outfile, level)
            outfile.write('<%sUniqueSectionCode>%s</%sUniqueSectionCode>\n' % (namespace_, self.gds_format_string(quote_xml(self.UniqueSectionCode).encode(ExternalEncoding), input_name='UniqueSectionCode'), namespace_))
        if self.Term is not None:
            showIndent(outfile, level)
            outfile.write('<%sTerm>%s</%sTerm>\n' % (namespace_, self.gds_format_string(quote_xml(self.Term).encode(ExternalEncoding), input_name='Term'), namespace_))
        if self.SequenceOfCourse is not None:
            showIndent(outfile, level)
            outfile.write('<%sSequenceOfCourse>%s</%sSequenceOfCourse>\n' % (namespace_, self.gds_format_integer(self.SequenceOfCourse, input_name='SequenceOfCourse'), namespace_))
        if self.EducationalEnvironment is not None:
            showIndent(outfile, level)
            outfile.write('<%sEducationalEnvironment>%s</%sEducationalEnvironment>\n' % (namespace_, self.gds_format_string(quote_xml(self.EducationalEnvironment).encode(ExternalEncoding), input_name='EducationalEnvironment'), namespace_))
        if self.MediumOfInstruction is not None:
            showIndent(outfile, level)
            outfile.write('<%sMediumOfInstruction>%s</%sMediumOfInstruction>\n' % (namespace_, self.gds_format_string(quote_xml(self.MediumOfInstruction).encode(ExternalEncoding), input_name='MediumOfInstruction'), namespace_))
        if self.PopulationServed is not None:
            showIndent(outfile, level)
            outfile.write('<%sPopulationServed>%s</%sPopulationServed>\n' % (namespace_, self.gds_format_string(quote_xml(self.PopulationServed).encode(ExternalEncoding), input_name='PopulationServed'), namespace_))
        if self.AvailableCredit:
            self.AvailableCredit.export(outfile, level, namespace_, name_='AvailableCredit')
        if self.CourseReference:
            self.CourseReference.export(outfile, level, namespace_, name_='CourseReference', )
        if self.SchoolReference:
            self.SchoolReference.export(outfile, level, namespace_, name_='SchoolReference', )
        if self.LocationReference:
            self.LocationReference.export(outfile, level, namespace_, name_='LocationReference')
        if self.ClassPeriodReference:
            self.ClassPeriodReference.export(outfile, level, namespace_, name_='ClassPeriodReference')
        for ProgramReference_ in self.ProgramReference:
            ProgramReference_.export(outfile, level, namespace_, name_='ProgramReference')
    def hasContent_(self):
        if (
            self.UniqueSectionCode is not None or
            self.Term is not None or
            self.SequenceOfCourse is not None or
            self.EducationalEnvironment is not None or
            self.MediumOfInstruction is not None or
            self.PopulationServed is not None or
            self.AvailableCredit is not None or
            self.CourseReference is not None or
            self.SchoolReference is not None or
            self.LocationReference is not None or
            self.ClassPeriodReference is not None or
            self.ProgramReference or
            super(Section, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Section'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Section, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Section, self).exportLiteralChildren(outfile, level, name_)
        if self.UniqueSectionCode is not None:
            showIndent(outfile, level)
            outfile.write('UniqueSectionCode=%s,\n' % quote_python(self.UniqueSectionCode).encode(ExternalEncoding))
        if self.Term is not None:
            showIndent(outfile, level)
            outfile.write('Term=%s,\n' % quote_python(self.Term).encode(ExternalEncoding))
        if self.SequenceOfCourse is not None:
            showIndent(outfile, level)
            outfile.write('SequenceOfCourse=%d,\n' % self.SequenceOfCourse)
        if self.EducationalEnvironment is not None:
            showIndent(outfile, level)
            outfile.write('EducationalEnvironment=%s,\n' % quote_python(self.EducationalEnvironment).encode(ExternalEncoding))
        if self.MediumOfInstruction is not None:
            showIndent(outfile, level)
            outfile.write('MediumOfInstruction=%s,\n' % quote_python(self.MediumOfInstruction).encode(ExternalEncoding))
        if self.PopulationServed is not None:
            showIndent(outfile, level)
            outfile.write('PopulationServed=%s,\n' % quote_python(self.PopulationServed).encode(ExternalEncoding))
        if self.AvailableCredit is not None:
            showIndent(outfile, level)
            outfile.write('AvailableCredit=model_.Credits(\n')
            self.AvailableCredit.exportLiteral(outfile, level, name_='AvailableCredit')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CourseReference is not None:
            showIndent(outfile, level)
            outfile.write('CourseReference=model_.CourseReferenceType(\n')
            self.CourseReference.exportLiteral(outfile, level, name_='CourseReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SchoolReference is not None:
            showIndent(outfile, level)
            outfile.write('SchoolReference=model_.EducationalOrgReferenceType(\n')
            self.SchoolReference.exportLiteral(outfile, level, name_='SchoolReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocationReference is not None:
            showIndent(outfile, level)
            outfile.write('LocationReference=model_.ReferenceType(\n')
            self.LocationReference.exportLiteral(outfile, level, name_='LocationReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ClassPeriodReference is not None:
            showIndent(outfile, level)
            outfile.write('ClassPeriodReference=model_.ReferenceType(\n')
            self.ClassPeriodReference.exportLiteral(outfile, level, name_='ClassPeriodReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('ProgramReference=[\n')
        level += 1
        for ProgramReference_ in self.ProgramReference:
            showIndent(outfile, level)
            outfile.write('model_.ProgramReferenceType(\n')
            ProgramReference_.exportLiteral(outfile, level, name_='ProgramReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Section, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UniqueSectionCode':
            UniqueSectionCode_ = child_.text
            UniqueSectionCode_ = self.gds_validate_string(UniqueSectionCode_, node, 'UniqueSectionCode')
            self.UniqueSectionCode = UniqueSectionCode_
            self.validate_UniqueSectionCode(self.UniqueSectionCode)    # validate type UniqueSectionCode
        elif nodeName_ == 'Term':
            Term_ = child_.text
            Term_ = re_.sub(String_cleanup_pat_, " ", Term_).strip()
            Term_ = self.gds_validate_string(Term_, node, 'Term')
            self.Term = Term_
            self.validate_TermType(self.Term)    # validate type TermType
        elif nodeName_ == 'SequenceOfCourse':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'SequenceOfCourse')
            self.SequenceOfCourse = ival_
        elif nodeName_ == 'EducationalEnvironment':
            EducationalEnvironment_ = child_.text
            EducationalEnvironment_ = re_.sub(String_cleanup_pat_, " ", EducationalEnvironment_).strip()
            EducationalEnvironment_ = self.gds_validate_string(EducationalEnvironment_, node, 'EducationalEnvironment')
            self.EducationalEnvironment = EducationalEnvironment_
            self.validate_EducationalEnvironmentType(self.EducationalEnvironment)    # validate type EducationalEnvironmentType
        elif nodeName_ == 'MediumOfInstruction':
            MediumOfInstruction_ = child_.text
            MediumOfInstruction_ = re_.sub(String_cleanup_pat_, " ", MediumOfInstruction_).strip()
            MediumOfInstruction_ = self.gds_validate_string(MediumOfInstruction_, node, 'MediumOfInstruction')
            self.MediumOfInstruction = MediumOfInstruction_
            self.validate_MediumOfInstructionType(self.MediumOfInstruction)    # validate type MediumOfInstructionType
        elif nodeName_ == 'PopulationServed':
            PopulationServed_ = child_.text
            PopulationServed_ = re_.sub(String_cleanup_pat_, " ", PopulationServed_).strip()
            PopulationServed_ = self.gds_validate_string(PopulationServed_, node, 'PopulationServed')
            self.PopulationServed = PopulationServed_
            self.validate_PopulationServedType(self.PopulationServed)    # validate type PopulationServedType
        elif nodeName_ == 'AvailableCredit':
            obj_ = Credits.factory()
            obj_.build(child_)
            self.set_AvailableCredit(obj_)
        elif nodeName_ == 'CourseReference':
            obj_ = CourseReferenceType.factory()
            obj_.build(child_)
            self.set_CourseReference(obj_)
        elif nodeName_ == 'SchoolReference':
            obj_ = EducationalOrgReferenceType.factory()
            obj_.build(child_)
            self.set_SchoolReference(obj_)
        elif nodeName_ == 'LocationReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_LocationReference(obj_)
        elif nodeName_ == 'ClassPeriodReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_ClassPeriodReference(obj_)
        elif nodeName_ == 'ProgramReference':
            obj_ = ProgramReferenceType.factory()
            obj_.build(child_)
            self.ProgramReference.append(obj_)
        super(Section, self).buildChildren(child_, node, nodeName_, True)
# end class Section


class RestraintEvent(ComplexObjectType):
    """This event entity represents the instances where a special education
    student was physically or mechanically restrained due to
    imminent serious physical harm to themselves or others, imminent
    serious property destruction, or a combination of both imminent
    serious physical harm to themselves or others and imminent
    serious property destruction."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, RestraintEventIdentifier=None, EventDate=None, EducationalEnvironment=None, RestraintEventReasons=None, StudentReference=None, ProgramReference=None, SchoolReference=None):
        super(RestraintEvent, self).__init__(id, )
        self.RestraintEventIdentifier = RestraintEventIdentifier
        self.EventDate = EventDate
        self.EducationalEnvironment = EducationalEnvironment
        self.RestraintEventReasons = RestraintEventReasons
        self.StudentReference = StudentReference
        if ProgramReference is None:
            self.ProgramReference = []
        else:
            self.ProgramReference = ProgramReference
        self.SchoolReference = SchoolReference
    def factory(*args_, **kwargs_):
        if RestraintEvent.subclass:
            return RestraintEvent.subclass(*args_, **kwargs_)
        else:
            return RestraintEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RestraintEventIdentifier(self): return self.RestraintEventIdentifier
    def set_RestraintEventIdentifier(self, RestraintEventIdentifier): self.RestraintEventIdentifier = RestraintEventIdentifier
    def validate_RestraintEventIdentifier(self, value):
        # Validate type RestraintEventIdentifier, a restriction on xs:string.
        pass
    def get_EventDate(self): return self.EventDate
    def set_EventDate(self, EventDate): self.EventDate = EventDate
    def get_EducationalEnvironment(self): return self.EducationalEnvironment
    def set_EducationalEnvironment(self, EducationalEnvironment): self.EducationalEnvironment = EducationalEnvironment
    def validate_EducationalEnvironmentType(self, value):
        # Validate type EducationalEnvironmentType, a restriction on xs:token.
        pass
    def get_RestraintEventReasons(self): return self.RestraintEventReasons
    def set_RestraintEventReasons(self, RestraintEventReasons): self.RestraintEventReasons = RestraintEventReasons
    def get_StudentReference(self): return self.StudentReference
    def set_StudentReference(self, StudentReference): self.StudentReference = StudentReference
    def get_ProgramReference(self): return self.ProgramReference
    def set_ProgramReference(self, ProgramReference): self.ProgramReference = ProgramReference
    def add_ProgramReference(self, value): self.ProgramReference.append(value)
    def insert_ProgramReference(self, index, value): self.ProgramReference[index] = value
    def get_SchoolReference(self): return self.SchoolReference
    def set_SchoolReference(self, SchoolReference): self.SchoolReference = SchoolReference
    def export(self, outfile, level, namespace_='', name_='RestraintEvent', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RestraintEvent')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RestraintEvent'):
        super(RestraintEvent, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RestraintEvent')
    def exportChildren(self, outfile, level, namespace_='', name_='RestraintEvent', fromsubclass_=False):
        super(RestraintEvent, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.RestraintEventIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('<%sRestraintEventIdentifier>%s</%sRestraintEventIdentifier>\n' % (namespace_, self.gds_format_string(quote_xml(self.RestraintEventIdentifier).encode(ExternalEncoding), input_name='RestraintEventIdentifier'), namespace_))
        if self.EventDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sEventDate>%s</%sEventDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.EventDate).encode(ExternalEncoding), input_name='EventDate'), namespace_))
        if self.EducationalEnvironment is not None:
            showIndent(outfile, level)
            outfile.write('<%sEducationalEnvironment>%s</%sEducationalEnvironment>\n' % (namespace_, self.gds_format_string(quote_xml(self.EducationalEnvironment).encode(ExternalEncoding), input_name='EducationalEnvironment'), namespace_))
        if self.RestraintEventReasons:
            self.RestraintEventReasons.export(outfile, level, namespace_, name_='RestraintEventReasons', )
        if self.StudentReference:
            self.StudentReference.export(outfile, level, namespace_, name_='StudentReference', )
        for ProgramReference_ in self.ProgramReference:
            ProgramReference_.export(outfile, level, namespace_, name_='ProgramReference')
        if self.SchoolReference:
            self.SchoolReference.export(outfile, level, namespace_, name_='SchoolReference', )
    def hasContent_(self):
        if (
            self.RestraintEventIdentifier is not None or
            self.EventDate is not None or
            self.EducationalEnvironment is not None or
            self.RestraintEventReasons is not None or
            self.StudentReference is not None or
            self.ProgramReference or
            self.SchoolReference is not None or
            super(RestraintEvent, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RestraintEvent'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(RestraintEvent, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RestraintEvent, self).exportLiteralChildren(outfile, level, name_)
        if self.RestraintEventIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('RestraintEventIdentifier=%s,\n' % quote_python(self.RestraintEventIdentifier).encode(ExternalEncoding))
        if self.EventDate is not None:
            showIndent(outfile, level)
            outfile.write('EventDate=%s,\n' % quote_python(self.EventDate).encode(ExternalEncoding))
        if self.EducationalEnvironment is not None:
            showIndent(outfile, level)
            outfile.write('EducationalEnvironment=%s,\n' % quote_python(self.EducationalEnvironment).encode(ExternalEncoding))
        if self.RestraintEventReasons is not None:
            showIndent(outfile, level)
            outfile.write('RestraintEventReasons=model_.RestraintEventReasonsType(\n')
            self.RestraintEventReasons.exportLiteral(outfile, level, name_='RestraintEventReasons')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.StudentReference is not None:
            showIndent(outfile, level)
            outfile.write('StudentReference=model_.StudentReferenceType(\n')
            self.StudentReference.exportLiteral(outfile, level, name_='StudentReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('ProgramReference=[\n')
        level += 1
        for ProgramReference_ in self.ProgramReference:
            showIndent(outfile, level)
            outfile.write('model_.ProgramReferenceType(\n')
            ProgramReference_.exportLiteral(outfile, level, name_='ProgramReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.SchoolReference is not None:
            showIndent(outfile, level)
            outfile.write('SchoolReference=model_.EducationalOrgReferenceType(\n')
            self.SchoolReference.exportLiteral(outfile, level, name_='SchoolReference')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(RestraintEvent, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RestraintEventIdentifier':
            RestraintEventIdentifier_ = child_.text
            RestraintEventIdentifier_ = self.gds_validate_string(RestraintEventIdentifier_, node, 'RestraintEventIdentifier')
            self.RestraintEventIdentifier = RestraintEventIdentifier_
            self.validate_RestraintEventIdentifier(self.RestraintEventIdentifier)    # validate type RestraintEventIdentifier
        elif nodeName_ == 'EventDate':
            EventDate_ = child_.text
            EventDate_ = self.gds_validate_string(EventDate_, node, 'EventDate')
            self.EventDate = EventDate_
        elif nodeName_ == 'EducationalEnvironment':
            EducationalEnvironment_ = child_.text
            EducationalEnvironment_ = re_.sub(String_cleanup_pat_, " ", EducationalEnvironment_).strip()
            EducationalEnvironment_ = self.gds_validate_string(EducationalEnvironment_, node, 'EducationalEnvironment')
            self.EducationalEnvironment = EducationalEnvironment_
            self.validate_EducationalEnvironmentType(self.EducationalEnvironment)    # validate type EducationalEnvironmentType
        elif nodeName_ == 'RestraintEventReasons':
            obj_ = RestraintEventReasonsType.factory()
            obj_.build(child_)
            self.set_RestraintEventReasons(obj_)
        elif nodeName_ == 'StudentReference':
            obj_ = StudentReferenceType.factory()
            obj_.build(child_)
            self.set_StudentReference(obj_)
        elif nodeName_ == 'ProgramReference':
            obj_ = ProgramReferenceType.factory()
            obj_.build(child_)
            self.ProgramReference.append(obj_)
        elif nodeName_ == 'SchoolReference':
            obj_ = EducationalOrgReferenceType.factory()
            obj_.build(child_)
            self.set_SchoolReference(obj_)
        super(RestraintEvent, self).buildChildren(child_, node, nodeName_, True)
# end class RestraintEvent


class ReportCard(ComplexObjectType):
    """This educational entity represents the collecton of student grades
    for courses taken during a grading period."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, GPAGivenGradingPeriod=None, GPACumulative=None, NumberOfDaysAbsent=None, NumberOfDaysInAttendance=None, NumberOfDaysTardy=None, StudentReference=None, GradingPeriodReference=None, GradeReference=None):
        super(ReportCard, self).__init__(id, )
        self.GPAGivenGradingPeriod = GPAGivenGradingPeriod
        self.GPACumulative = GPACumulative
        self.NumberOfDaysAbsent = NumberOfDaysAbsent
        self.NumberOfDaysInAttendance = NumberOfDaysInAttendance
        self.NumberOfDaysTardy = NumberOfDaysTardy
        self.StudentReference = StudentReference
        self.GradingPeriodReference = GradingPeriodReference
        if GradeReference is None:
            self.GradeReference = []
        else:
            self.GradeReference = GradeReference
    def factory(*args_, **kwargs_):
        if ReportCard.subclass:
            return ReportCard.subclass(*args_, **kwargs_)
        else:
            return ReportCard(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GPAGivenGradingPeriod(self): return self.GPAGivenGradingPeriod
    def set_GPAGivenGradingPeriod(self, GPAGivenGradingPeriod): self.GPAGivenGradingPeriod = GPAGivenGradingPeriod
    def get_GPACumulative(self): return self.GPACumulative
    def set_GPACumulative(self, GPACumulative): self.GPACumulative = GPACumulative
    def get_NumberOfDaysAbsent(self): return self.NumberOfDaysAbsent
    def set_NumberOfDaysAbsent(self, NumberOfDaysAbsent): self.NumberOfDaysAbsent = NumberOfDaysAbsent
    def get_NumberOfDaysInAttendance(self): return self.NumberOfDaysInAttendance
    def set_NumberOfDaysInAttendance(self, NumberOfDaysInAttendance): self.NumberOfDaysInAttendance = NumberOfDaysInAttendance
    def get_NumberOfDaysTardy(self): return self.NumberOfDaysTardy
    def set_NumberOfDaysTardy(self, NumberOfDaysTardy): self.NumberOfDaysTardy = NumberOfDaysTardy
    def get_StudentReference(self): return self.StudentReference
    def set_StudentReference(self, StudentReference): self.StudentReference = StudentReference
    def get_GradingPeriodReference(self): return self.GradingPeriodReference
    def set_GradingPeriodReference(self, GradingPeriodReference): self.GradingPeriodReference = GradingPeriodReference
    def get_GradeReference(self): return self.GradeReference
    def set_GradeReference(self, GradeReference): self.GradeReference = GradeReference
    def add_GradeReference(self, value): self.GradeReference.append(value)
    def insert_GradeReference(self, index, value): self.GradeReference[index] = value
    def export(self, outfile, level, namespace_='', name_='ReportCard', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReportCard')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReportCard'):
        super(ReportCard, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ReportCard')
    def exportChildren(self, outfile, level, namespace_='', name_='ReportCard', fromsubclass_=False):
        super(ReportCard, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.GPAGivenGradingPeriod is not None:
            showIndent(outfile, level)
            outfile.write('<%sGPAGivenGradingPeriod>%s</%sGPAGivenGradingPeriod>\n' % (namespace_, self.gds_format_float(self.GPAGivenGradingPeriod, input_name='GPAGivenGradingPeriod'), namespace_))
        if self.GPACumulative is not None:
            showIndent(outfile, level)
            outfile.write('<%sGPACumulative>%s</%sGPACumulative>\n' % (namespace_, self.gds_format_float(self.GPACumulative, input_name='GPACumulative'), namespace_))
        if self.NumberOfDaysAbsent is not None:
            showIndent(outfile, level)
            outfile.write('<%sNumberOfDaysAbsent>%s</%sNumberOfDaysAbsent>\n' % (namespace_, self.gds_format_float(self.NumberOfDaysAbsent, input_name='NumberOfDaysAbsent'), namespace_))
        if self.NumberOfDaysInAttendance is not None:
            showIndent(outfile, level)
            outfile.write('<%sNumberOfDaysInAttendance>%s</%sNumberOfDaysInAttendance>\n' % (namespace_, self.gds_format_float(self.NumberOfDaysInAttendance, input_name='NumberOfDaysInAttendance'), namespace_))
        if self.NumberOfDaysTardy is not None:
            showIndent(outfile, level)
            outfile.write('<%sNumberOfDaysTardy>%s</%sNumberOfDaysTardy>\n' % (namespace_, self.gds_format_integer(self.NumberOfDaysTardy, input_name='NumberOfDaysTardy'), namespace_))
        if self.StudentReference:
            self.StudentReference.export(outfile, level, namespace_, name_='StudentReference', )
        if self.GradingPeriodReference:
            self.GradingPeriodReference.export(outfile, level, namespace_, name_='GradingPeriodReference', )
        for GradeReference_ in self.GradeReference:
            GradeReference_.export(outfile, level, namespace_, name_='GradeReference')
    def hasContent_(self):
        if (
            self.GPAGivenGradingPeriod is not None or
            self.GPACumulative is not None or
            self.NumberOfDaysAbsent is not None or
            self.NumberOfDaysInAttendance is not None or
            self.NumberOfDaysTardy is not None or
            self.StudentReference is not None or
            self.GradingPeriodReference is not None or
            self.GradeReference or
            super(ReportCard, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ReportCard'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ReportCard, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ReportCard, self).exportLiteralChildren(outfile, level, name_)
        if self.GPAGivenGradingPeriod is not None:
            showIndent(outfile, level)
            outfile.write('GPAGivenGradingPeriod=%f,\n' % self.GPAGivenGradingPeriod)
        if self.GPACumulative is not None:
            showIndent(outfile, level)
            outfile.write('GPACumulative=%f,\n' % self.GPACumulative)
        if self.NumberOfDaysAbsent is not None:
            showIndent(outfile, level)
            outfile.write('NumberOfDaysAbsent=%f,\n' % self.NumberOfDaysAbsent)
        if self.NumberOfDaysInAttendance is not None:
            showIndent(outfile, level)
            outfile.write('NumberOfDaysInAttendance=%f,\n' % self.NumberOfDaysInAttendance)
        if self.NumberOfDaysTardy is not None:
            showIndent(outfile, level)
            outfile.write('NumberOfDaysTardy=%d,\n' % self.NumberOfDaysTardy)
        if self.StudentReference is not None:
            showIndent(outfile, level)
            outfile.write('StudentReference=model_.StudentReferenceType(\n')
            self.StudentReference.exportLiteral(outfile, level, name_='StudentReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GradingPeriodReference is not None:
            showIndent(outfile, level)
            outfile.write('GradingPeriodReference=model_.GradingPeriodReferenceType(\n')
            self.GradingPeriodReference.exportLiteral(outfile, level, name_='GradingPeriodReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('GradeReference=[\n')
        level += 1
        for GradeReference_ in self.GradeReference:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            GradeReference_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(ReportCard, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GPAGivenGradingPeriod':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'GPAGivenGradingPeriod')
            self.GPAGivenGradingPeriod = fval_
        elif nodeName_ == 'GPACumulative':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'GPACumulative')
            self.GPACumulative = fval_
        elif nodeName_ == 'NumberOfDaysAbsent':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'NumberOfDaysAbsent')
            self.NumberOfDaysAbsent = fval_
        elif nodeName_ == 'NumberOfDaysInAttendance':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'NumberOfDaysInAttendance')
            self.NumberOfDaysInAttendance = fval_
        elif nodeName_ == 'NumberOfDaysTardy':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumberOfDaysTardy')
            self.NumberOfDaysTardy = ival_
        elif nodeName_ == 'StudentReference':
            obj_ = StudentReferenceType.factory()
            obj_.build(child_)
            self.set_StudentReference(obj_)
        elif nodeName_ == 'GradingPeriodReference':
            obj_ = GradingPeriodReferenceType.factory()
            obj_.build(child_)
            self.set_GradingPeriodReference(obj_)
        elif nodeName_ == 'GradeReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.GradeReference.append(obj_)
        super(ReportCard, self).buildChildren(child_, node, nodeName_, True)
# end class ReportCard


class Program(ComplexObjectType):
    """This entity represents any program designed to work in conjunction
    with or to supplement the main academic program. Programs may
    provide instruction, training, services or benefits through
    federal, state, or local agencies. Programs may also include
    organized extracurricular activities for students."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, ProgramId=None, ProgramType=None, ProgramSponsor=None):
        super(Program, self).__init__(id, )
        self.ProgramId = ProgramId
        self.ProgramType = ProgramType
        self.ProgramSponsor = ProgramSponsor
    def factory(*args_, **kwargs_):
        if Program.subclass:
            return Program.subclass(*args_, **kwargs_)
        else:
            return Program(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ProgramId(self): return self.ProgramId
    def set_ProgramId(self, ProgramId): self.ProgramId = ProgramId
    def validate_ProgramId(self, value):
        # Validate type ProgramId, a restriction on xs:string.
        pass
    def get_ProgramType(self): return self.ProgramType
    def set_ProgramType(self, ProgramType): self.ProgramType = ProgramType
    def validate_ProgramType(self, value):
        # Validate type ProgramType, a restriction on xs:token.
        pass
    def get_ProgramSponsor(self): return self.ProgramSponsor
    def set_ProgramSponsor(self, ProgramSponsor): self.ProgramSponsor = ProgramSponsor
    def validate_ProgramSponsorType(self, value):
        # Validate type ProgramSponsorType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='Program', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Program')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Program'):
        super(Program, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Program')
    def exportChildren(self, outfile, level, namespace_='', name_='Program', fromsubclass_=False):
        super(Program, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.ProgramId is not None:
            showIndent(outfile, level)
            outfile.write('<%sProgramId>%s</%sProgramId>\n' % (namespace_, self.gds_format_string(quote_xml(self.ProgramId).encode(ExternalEncoding), input_name='ProgramId'), namespace_))
        if self.ProgramType is not None:
            showIndent(outfile, level)
            outfile.write('<%sProgramType>%s</%sProgramType>\n' % (namespace_, self.gds_format_string(quote_xml(self.ProgramType).encode(ExternalEncoding), input_name='ProgramType'), namespace_))
        if self.ProgramSponsor is not None:
            showIndent(outfile, level)
            outfile.write('<%sProgramSponsor>%s</%sProgramSponsor>\n' % (namespace_, self.gds_format_string(quote_xml(self.ProgramSponsor).encode(ExternalEncoding), input_name='ProgramSponsor'), namespace_))
    def hasContent_(self):
        if (
            self.ProgramId is not None or
            self.ProgramType is not None or
            self.ProgramSponsor is not None or
            super(Program, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Program'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Program, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Program, self).exportLiteralChildren(outfile, level, name_)
        if self.ProgramId is not None:
            showIndent(outfile, level)
            outfile.write('ProgramId=%s,\n' % quote_python(self.ProgramId).encode(ExternalEncoding))
        if self.ProgramType is not None:
            showIndent(outfile, level)
            outfile.write('ProgramType=%s,\n' % quote_python(self.ProgramType).encode(ExternalEncoding))
        if self.ProgramSponsor is not None:
            showIndent(outfile, level)
            outfile.write('ProgramSponsor=%s,\n' % quote_python(self.ProgramSponsor).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Program, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ProgramId':
            ProgramId_ = child_.text
            ProgramId_ = self.gds_validate_string(ProgramId_, node, 'ProgramId')
            self.ProgramId = ProgramId_
            self.validate_ProgramId(self.ProgramId)    # validate type ProgramId
        elif nodeName_ == 'ProgramType':
            ProgramType_ = child_.text
            ProgramType_ = re_.sub(String_cleanup_pat_, " ", ProgramType_).strip()
            ProgramType_ = self.gds_validate_string(ProgramType_, node, 'ProgramType')
            self.ProgramType = ProgramType_
            self.validate_ProgramType(self.ProgramType)    # validate type ProgramType
        elif nodeName_ == 'ProgramSponsor':
            ProgramSponsor_ = child_.text
            ProgramSponsor_ = re_.sub(String_cleanup_pat_, " ", ProgramSponsor_).strip()
            ProgramSponsor_ = self.gds_validate_string(ProgramSponsor_, node, 'ProgramSponsor')
            self.ProgramSponsor = ProgramSponsor_
            self.validate_ProgramSponsorType(self.ProgramSponsor)    # validate type ProgramSponsorType
        super(Program, self).buildChildren(child_, node, nodeName_, True)
# end class Program


class Payroll(ComplexObjectType):
    """This financial entity represents the sum of the financal
    transactions to date for employee compensation. An "employee"
    who performs services under the direction of the employing
    institution or agency, is compensated for such services by the
    employer, and is eligible for employee benefits and wage or
    salary tax withholdings."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, FiscalYear=None, AmountToDate=None, AccountReference=None, StaffReference=None):
        super(Payroll, self).__init__(id, )
        self.FiscalYear = FiscalYear
        self.AmountToDate = AmountToDate
        self.AccountReference = AccountReference
        self.StaffReference = StaffReference
    def factory(*args_, **kwargs_):
        if Payroll.subclass:
            return Payroll.subclass(*args_, **kwargs_)
        else:
            return Payroll(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FiscalYear(self): return self.FiscalYear
    def set_FiscalYear(self, FiscalYear): self.FiscalYear = FiscalYear
    def get_AmountToDate(self): return self.AmountToDate
    def set_AmountToDate(self, AmountToDate): self.AmountToDate = AmountToDate
    def validate_Currency(self, value):
        # Validate type Currency, a restriction on xs:decimal.
        pass
    def get_AccountReference(self): return self.AccountReference
    def set_AccountReference(self, AccountReference): self.AccountReference = AccountReference
    def get_StaffReference(self): return self.StaffReference
    def set_StaffReference(self, StaffReference): self.StaffReference = StaffReference
    def export(self, outfile, level, namespace_='', name_='Payroll', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Payroll')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Payroll'):
        super(Payroll, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Payroll')
    def exportChildren(self, outfile, level, namespace_='', name_='Payroll', fromsubclass_=False):
        super(Payroll, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.FiscalYear is not None:
            showIndent(outfile, level)
            outfile.write('<%sFiscalYear>%s</%sFiscalYear>\n' % (namespace_, self.gds_format_integer(self.FiscalYear, input_name='FiscalYear'), namespace_))
        if self.AmountToDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sAmountToDate>%s</%sAmountToDate>\n' % (namespace_, self.gds_format_float(self.AmountToDate, input_name='AmountToDate'), namespace_))
        if self.AccountReference:
            self.AccountReference.export(outfile, level, namespace_, name_='AccountReference', )
        if self.StaffReference:
            self.StaffReference.export(outfile, level, namespace_, name_='StaffReference', )
    def hasContent_(self):
        if (
            self.FiscalYear is not None or
            self.AmountToDate is not None or
            self.AccountReference is not None or
            self.StaffReference is not None or
            super(Payroll, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Payroll'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Payroll, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Payroll, self).exportLiteralChildren(outfile, level, name_)
        if self.FiscalYear is not None:
            showIndent(outfile, level)
            outfile.write('FiscalYear=%d,\n' % self.FiscalYear)
        if self.AmountToDate is not None:
            showIndent(outfile, level)
            outfile.write('AmountToDate=%f,\n' % self.AmountToDate)
        if self.AccountReference is not None:
            showIndent(outfile, level)
            outfile.write('AccountReference=model_.AccountReferenceType(\n')
            self.AccountReference.exportLiteral(outfile, level, name_='AccountReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.StaffReference is not None:
            showIndent(outfile, level)
            outfile.write('StaffReference=model_.StaffReferenceType(\n')
            self.StaffReference.exportLiteral(outfile, level, name_='StaffReference')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Payroll, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FiscalYear':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'FiscalYear')
            self.FiscalYear = ival_
        elif nodeName_ == 'AmountToDate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AmountToDate')
            self.AmountToDate = fval_
            self.validate_Currency(self.AmountToDate)    # validate type Currency
        elif nodeName_ == 'AccountReference':
            obj_ = AccountReferenceType.factory()
            obj_.build(child_)
            self.set_AccountReference(obj_)
        elif nodeName_ == 'StaffReference':
            obj_ = StaffReferenceType.factory()
            obj_.build(child_)
            self.set_StaffReference(obj_)
        super(Payroll, self).buildChildren(child_, node, nodeName_, True)
# end class Payroll


class Parent(ComplexObjectType):
    """This entity represents a parent or guardian of a student, such as
    mother, father, or caretaker."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, ParentUniqueStateId=None, Name=None, OtherName=None, Sex=None, Address=None, Telephone=None, ElectronicMail=None):
        super(Parent, self).__init__(id, )
        self.ParentUniqueStateId = ParentUniqueStateId
        self.Name = Name
        if OtherName is None:
            self.OtherName = []
        else:
            self.OtherName = OtherName
        self.Sex = Sex
        if Address is None:
            self.Address = []
        else:
            self.Address = Address
        if Telephone is None:
            self.Telephone = []
        else:
            self.Telephone = Telephone
        if ElectronicMail is None:
            self.ElectronicMail = []
        else:
            self.ElectronicMail = ElectronicMail
    def factory(*args_, **kwargs_):
        if Parent.subclass:
            return Parent.subclass(*args_, **kwargs_)
        else:
            return Parent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ParentUniqueStateId(self): return self.ParentUniqueStateId
    def set_ParentUniqueStateId(self, ParentUniqueStateId): self.ParentUniqueStateId = ParentUniqueStateId
    def validate_UniqueStateIdentifier(self, value):
        # Validate type UniqueStateIdentifier, a restriction on xs:int.
        pass
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_OtherName(self): return self.OtherName
    def set_OtherName(self, OtherName): self.OtherName = OtherName
    def add_OtherName(self, value): self.OtherName.append(value)
    def insert_OtherName(self, index, value): self.OtherName[index] = value
    def get_Sex(self): return self.Sex
    def set_Sex(self, Sex): self.Sex = Sex
    def validate_SexType(self, value):
        # Validate type SexType, a restriction on xs:token.
        pass
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def add_Address(self, value): self.Address.append(value)
    def insert_Address(self, index, value): self.Address[index] = value
    def get_Telephone(self): return self.Telephone
    def set_Telephone(self, Telephone): self.Telephone = Telephone
    def add_Telephone(self, value): self.Telephone.append(value)
    def insert_Telephone(self, index, value): self.Telephone[index] = value
    def get_ElectronicMail(self): return self.ElectronicMail
    def set_ElectronicMail(self, ElectronicMail): self.ElectronicMail = ElectronicMail
    def add_ElectronicMail(self, value): self.ElectronicMail.append(value)
    def insert_ElectronicMail(self, index, value): self.ElectronicMail[index] = value
    def export(self, outfile, level, namespace_='', name_='Parent', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Parent')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Parent'):
        super(Parent, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Parent')
    def exportChildren(self, outfile, level, namespace_='', name_='Parent', fromsubclass_=False):
        super(Parent, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.ParentUniqueStateId is not None:
            showIndent(outfile, level)
            outfile.write('<%sParentUniqueStateId>%s</%sParentUniqueStateId>\n' % (namespace_, self.gds_format_integer(self.ParentUniqueStateId, input_name='ParentUniqueStateId'), namespace_))
        if self.Name:
            self.Name.export(outfile, level, namespace_, name_='Name', )
        for OtherName_ in self.OtherName:
            OtherName_.export(outfile, level, namespace_, name_='OtherName')
        if self.Sex is not None:
            showIndent(outfile, level)
            outfile.write('<%sSex>%s</%sSex>\n' % (namespace_, self.gds_format_string(quote_xml(self.Sex).encode(ExternalEncoding), input_name='Sex'), namespace_))
        for Address_ in self.Address:
            Address_.export(outfile, level, namespace_, name_='Address')
        for Telephone_ in self.Telephone:
            Telephone_.export(outfile, level, namespace_, name_='Telephone')
        for ElectronicMail_ in self.ElectronicMail:
            ElectronicMail_.export(outfile, level, namespace_, name_='ElectronicMail')
    def hasContent_(self):
        if (
            self.ParentUniqueStateId is not None or
            self.Name is not None or
            self.OtherName or
            self.Sex is not None or
            self.Address or
            self.Telephone or
            self.ElectronicMail or
            super(Parent, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Parent'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Parent, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Parent, self).exportLiteralChildren(outfile, level, name_)
        if self.ParentUniqueStateId is not None:
            showIndent(outfile, level)
            outfile.write('ParentUniqueStateId=%d,\n' % self.ParentUniqueStateId)
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=model_.Name(\n')
            self.Name.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('OtherName=[\n')
        level += 1
        for OtherName_ in self.OtherName:
            showIndent(outfile, level)
            outfile.write('model_.OtherName(\n')
            OtherName_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Sex is not None:
            showIndent(outfile, level)
            outfile.write('Sex=%s,\n' % quote_python(self.Sex).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Address=[\n')
        level += 1
        for Address_ in self.Address:
            showIndent(outfile, level)
            outfile.write('model_.Address(\n')
            Address_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Telephone=[\n')
        level += 1
        for Telephone_ in self.Telephone:
            showIndent(outfile, level)
            outfile.write('model_.Telephone(\n')
            Telephone_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ElectronicMail=[\n')
        level += 1
        for ElectronicMail_ in self.ElectronicMail:
            showIndent(outfile, level)
            outfile.write('model_.ElectronicMail(\n')
            ElectronicMail_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Parent, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ParentUniqueStateId':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ParentUniqueStateId')
            self.ParentUniqueStateId = ival_
            self.validate_UniqueStateIdentifier(self.ParentUniqueStateId)    # validate type UniqueStateIdentifier
        elif nodeName_ == 'Name':
            obj_ = Name.factory()
            obj_.build(child_)
            self.set_Name(obj_)
        elif nodeName_ == 'OtherName':
            obj_ = OtherName.factory()
            obj_.build(child_)
            self.OtherName.append(obj_)
        elif nodeName_ == 'Sex':
            Sex_ = child_.text
            Sex_ = re_.sub(String_cleanup_pat_, " ", Sex_).strip()
            Sex_ = self.gds_validate_string(Sex_, node, 'Sex')
            self.Sex = Sex_
            self.validate_SexType(self.Sex)    # validate type SexType
        elif nodeName_ == 'Address':
            obj_ = Address.factory()
            obj_.build(child_)
            self.Address.append(obj_)
        elif nodeName_ == 'Telephone':
            obj_ = Telephone.factory()
            obj_.build(child_)
            self.Telephone.append(obj_)
        elif nodeName_ == 'ElectronicMail':
            obj_ = ElectronicMail.factory()
            obj_.build(child_)
            self.ElectronicMail.append(obj_)
        super(Parent, self).buildChildren(child_, node, nodeName_, True)
# end class Parent


class OpenStaffPosition(ComplexObjectType):
    """This entity represents an open staff position that is seeking to be
    filled by an education organization."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, EmploymentStatus=None, StaffClassification=None, PositionTitle=None, RequisitionNumber=None, ProgramAssignment=None, InstructionalGradeLevels=None, AcademicSubjects=None, DatePosted=None, DatePostingRemoved=None, PostingResult=None, EducationOrganizationReference=None):
        super(OpenStaffPosition, self).__init__(id, )
        self.EmploymentStatus = EmploymentStatus
        self.StaffClassification = StaffClassification
        self.PositionTitle = PositionTitle
        self.RequisitionNumber = RequisitionNumber
        self.ProgramAssignment = ProgramAssignment
        self.InstructionalGradeLevels = InstructionalGradeLevels
        self.AcademicSubjects = AcademicSubjects
        self.DatePosted = DatePosted
        self.DatePostingRemoved = DatePostingRemoved
        self.PostingResult = PostingResult
        self.EducationOrganizationReference = EducationOrganizationReference
    def factory(*args_, **kwargs_):
        if OpenStaffPosition.subclass:
            return OpenStaffPosition.subclass(*args_, **kwargs_)
        else:
            return OpenStaffPosition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EmploymentStatus(self): return self.EmploymentStatus
    def set_EmploymentStatus(self, EmploymentStatus): self.EmploymentStatus = EmploymentStatus
    def validate_EmploymentStatusType(self, value):
        # Validate type EmploymentStatusType, a restriction on xs:token.
        pass
    def get_StaffClassification(self): return self.StaffClassification
    def set_StaffClassification(self, StaffClassification): self.StaffClassification = StaffClassification
    def validate_StaffClassificationType(self, value):
        # Validate type StaffClassificationType, a restriction on xs:token.
        pass
    def get_PositionTitle(self): return self.PositionTitle
    def set_PositionTitle(self, PositionTitle): self.PositionTitle = PositionTitle
    def validate_PositionTitle(self, value):
        # Validate type PositionTitle, a restriction on xs:string.
        pass
    def get_RequisitionNumber(self): return self.RequisitionNumber
    def set_RequisitionNumber(self, RequisitionNumber): self.RequisitionNumber = RequisitionNumber
    def validate_RequisitionNumber(self, value):
        # Validate type RequisitionNumber, a restriction on xs:string.
        pass
    def get_ProgramAssignment(self): return self.ProgramAssignment
    def set_ProgramAssignment(self, ProgramAssignment): self.ProgramAssignment = ProgramAssignment
    def validate_ProgramAssignmentType(self, value):
        # Validate type ProgramAssignmentType, a restriction on xs:token.
        pass
    def get_InstructionalGradeLevels(self): return self.InstructionalGradeLevels
    def set_InstructionalGradeLevels(self, InstructionalGradeLevels): self.InstructionalGradeLevels = InstructionalGradeLevels
    def get_AcademicSubjects(self): return self.AcademicSubjects
    def set_AcademicSubjects(self, AcademicSubjects): self.AcademicSubjects = AcademicSubjects
    def get_DatePosted(self): return self.DatePosted
    def set_DatePosted(self, DatePosted): self.DatePosted = DatePosted
    def get_DatePostingRemoved(self): return self.DatePostingRemoved
    def set_DatePostingRemoved(self, DatePostingRemoved): self.DatePostingRemoved = DatePostingRemoved
    def get_PostingResult(self): return self.PostingResult
    def set_PostingResult(self, PostingResult): self.PostingResult = PostingResult
    def validate_PostingResultType(self, value):
        # Validate type PostingResultType, a restriction on xs:token.
        pass
    def get_EducationOrganizationReference(self): return self.EducationOrganizationReference
    def set_EducationOrganizationReference(self, EducationOrganizationReference): self.EducationOrganizationReference = EducationOrganizationReference
    def export(self, outfile, level, namespace_='', name_='OpenStaffPosition', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OpenStaffPosition')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OpenStaffPosition'):
        super(OpenStaffPosition, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OpenStaffPosition')
    def exportChildren(self, outfile, level, namespace_='', name_='OpenStaffPosition', fromsubclass_=False):
        super(OpenStaffPosition, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.EmploymentStatus is not None:
            showIndent(outfile, level)
            outfile.write('<%sEmploymentStatus>%s</%sEmploymentStatus>\n' % (namespace_, self.gds_format_string(quote_xml(self.EmploymentStatus).encode(ExternalEncoding), input_name='EmploymentStatus'), namespace_))
        if self.StaffClassification is not None:
            showIndent(outfile, level)
            outfile.write('<%sStaffClassification>%s</%sStaffClassification>\n' % (namespace_, self.gds_format_string(quote_xml(self.StaffClassification).encode(ExternalEncoding), input_name='StaffClassification'), namespace_))
        if self.PositionTitle is not None:
            showIndent(outfile, level)
            outfile.write('<%sPositionTitle>%s</%sPositionTitle>\n' % (namespace_, self.gds_format_string(quote_xml(self.PositionTitle).encode(ExternalEncoding), input_name='PositionTitle'), namespace_))
        if self.RequisitionNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sRequisitionNumber>%s</%sRequisitionNumber>\n' % (namespace_, self.gds_format_string(quote_xml(self.RequisitionNumber).encode(ExternalEncoding), input_name='RequisitionNumber'), namespace_))
        if self.ProgramAssignment is not None:
            showIndent(outfile, level)
            outfile.write('<%sProgramAssignment>%s</%sProgramAssignment>\n' % (namespace_, self.gds_format_string(quote_xml(self.ProgramAssignment).encode(ExternalEncoding), input_name='ProgramAssignment'), namespace_))
        if self.InstructionalGradeLevels:
            self.InstructionalGradeLevels.export(outfile, level, namespace_, name_='InstructionalGradeLevels')
        if self.AcademicSubjects:
            self.AcademicSubjects.export(outfile, level, namespace_, name_='AcademicSubjects')
        if self.DatePosted is not None:
            showIndent(outfile, level)
            outfile.write('<%sDatePosted>%s</%sDatePosted>\n' % (namespace_, self.gds_format_string(quote_xml(self.DatePosted).encode(ExternalEncoding), input_name='DatePosted'), namespace_))
        if self.DatePostingRemoved is not None:
            showIndent(outfile, level)
            outfile.write('<%sDatePostingRemoved>%s</%sDatePostingRemoved>\n' % (namespace_, self.gds_format_string(quote_xml(self.DatePostingRemoved).encode(ExternalEncoding), input_name='DatePostingRemoved'), namespace_))
        if self.PostingResult is not None:
            showIndent(outfile, level)
            outfile.write('<%sPostingResult>%s</%sPostingResult>\n' % (namespace_, self.gds_format_string(quote_xml(self.PostingResult).encode(ExternalEncoding), input_name='PostingResult'), namespace_))
        if self.EducationOrganizationReference:
            self.EducationOrganizationReference.export(outfile, level, namespace_, name_='EducationOrganizationReference', )
    def hasContent_(self):
        if (
            self.EmploymentStatus is not None or
            self.StaffClassification is not None or
            self.PositionTitle is not None or
            self.RequisitionNumber is not None or
            self.ProgramAssignment is not None or
            self.InstructionalGradeLevels is not None or
            self.AcademicSubjects is not None or
            self.DatePosted is not None or
            self.DatePostingRemoved is not None or
            self.PostingResult is not None or
            self.EducationOrganizationReference is not None or
            super(OpenStaffPosition, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OpenStaffPosition'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(OpenStaffPosition, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(OpenStaffPosition, self).exportLiteralChildren(outfile, level, name_)
        if self.EmploymentStatus is not None:
            showIndent(outfile, level)
            outfile.write('EmploymentStatus=%s,\n' % quote_python(self.EmploymentStatus).encode(ExternalEncoding))
        if self.StaffClassification is not None:
            showIndent(outfile, level)
            outfile.write('StaffClassification=%s,\n' % quote_python(self.StaffClassification).encode(ExternalEncoding))
        if self.PositionTitle is not None:
            showIndent(outfile, level)
            outfile.write('PositionTitle=%s,\n' % quote_python(self.PositionTitle).encode(ExternalEncoding))
        if self.RequisitionNumber is not None:
            showIndent(outfile, level)
            outfile.write('RequisitionNumber=%s,\n' % quote_python(self.RequisitionNumber).encode(ExternalEncoding))
        if self.ProgramAssignment is not None:
            showIndent(outfile, level)
            outfile.write('ProgramAssignment=%s,\n' % quote_python(self.ProgramAssignment).encode(ExternalEncoding))
        if self.InstructionalGradeLevels is not None:
            showIndent(outfile, level)
            outfile.write('InstructionalGradeLevels=model_.GradeLevelsType(\n')
            self.InstructionalGradeLevels.exportLiteral(outfile, level, name_='InstructionalGradeLevels')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AcademicSubjects is not None:
            showIndent(outfile, level)
            outfile.write('AcademicSubjects=model_.AcademicSubjectsType(\n')
            self.AcademicSubjects.exportLiteral(outfile, level, name_='AcademicSubjects')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DatePosted is not None:
            showIndent(outfile, level)
            outfile.write('DatePosted=%s,\n' % quote_python(self.DatePosted).encode(ExternalEncoding))
        if self.DatePostingRemoved is not None:
            showIndent(outfile, level)
            outfile.write('DatePostingRemoved=%s,\n' % quote_python(self.DatePostingRemoved).encode(ExternalEncoding))
        if self.PostingResult is not None:
            showIndent(outfile, level)
            outfile.write('PostingResult=%s,\n' % quote_python(self.PostingResult).encode(ExternalEncoding))
        if self.EducationOrganizationReference is not None:
            showIndent(outfile, level)
            outfile.write('EducationOrganizationReference=model_.EducationalOrgReferenceType(\n')
            self.EducationOrganizationReference.exportLiteral(outfile, level, name_='EducationOrganizationReference')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(OpenStaffPosition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EmploymentStatus':
            EmploymentStatus_ = child_.text
            EmploymentStatus_ = re_.sub(String_cleanup_pat_, " ", EmploymentStatus_).strip()
            EmploymentStatus_ = self.gds_validate_string(EmploymentStatus_, node, 'EmploymentStatus')
            self.EmploymentStatus = EmploymentStatus_
            self.validate_EmploymentStatusType(self.EmploymentStatus)    # validate type EmploymentStatusType
        elif nodeName_ == 'StaffClassification':
            StaffClassification_ = child_.text
            StaffClassification_ = re_.sub(String_cleanup_pat_, " ", StaffClassification_).strip()
            StaffClassification_ = self.gds_validate_string(StaffClassification_, node, 'StaffClassification')
            self.StaffClassification = StaffClassification_
            self.validate_StaffClassificationType(self.StaffClassification)    # validate type StaffClassificationType
        elif nodeName_ == 'PositionTitle':
            PositionTitle_ = child_.text
            PositionTitle_ = self.gds_validate_string(PositionTitle_, node, 'PositionTitle')
            self.PositionTitle = PositionTitle_
            self.validate_PositionTitle(self.PositionTitle)    # validate type PositionTitle
        elif nodeName_ == 'RequisitionNumber':
            RequisitionNumber_ = child_.text
            RequisitionNumber_ = self.gds_validate_string(RequisitionNumber_, node, 'RequisitionNumber')
            self.RequisitionNumber = RequisitionNumber_
            self.validate_RequisitionNumber(self.RequisitionNumber)    # validate type RequisitionNumber
        elif nodeName_ == 'ProgramAssignment':
            ProgramAssignment_ = child_.text
            ProgramAssignment_ = re_.sub(String_cleanup_pat_, " ", ProgramAssignment_).strip()
            ProgramAssignment_ = self.gds_validate_string(ProgramAssignment_, node, 'ProgramAssignment')
            self.ProgramAssignment = ProgramAssignment_
            self.validate_ProgramAssignmentType(self.ProgramAssignment)    # validate type ProgramAssignmentType
        elif nodeName_ == 'InstructionalGradeLevels':
            obj_ = GradeLevelsType.factory()
            obj_.build(child_)
            self.set_InstructionalGradeLevels(obj_)
        elif nodeName_ == 'AcademicSubjects':
            obj_ = AcademicSubjectsType.factory()
            obj_.build(child_)
            self.set_AcademicSubjects(obj_)
        elif nodeName_ == 'DatePosted':
            DatePosted_ = child_.text
            DatePosted_ = self.gds_validate_string(DatePosted_, node, 'DatePosted')
            self.DatePosted = DatePosted_
        elif nodeName_ == 'DatePostingRemoved':
            DatePostingRemoved_ = child_.text
            DatePostingRemoved_ = self.gds_validate_string(DatePostingRemoved_, node, 'DatePostingRemoved')
            self.DatePostingRemoved = DatePostingRemoved_
        elif nodeName_ == 'PostingResult':
            PostingResult_ = child_.text
            PostingResult_ = re_.sub(String_cleanup_pat_, " ", PostingResult_).strip()
            PostingResult_ = self.gds_validate_string(PostingResult_, node, 'PostingResult')
            self.PostingResult = PostingResult_
            self.validate_PostingResultType(self.PostingResult)    # validate type PostingResultType
        elif nodeName_ == 'EducationOrganizationReference':
            obj_ = EducationalOrgReferenceType.factory()
            obj_.build(child_)
            self.set_EducationOrganizationReference(obj_)
        super(OpenStaffPosition, self).buildChildren(child_, node, nodeName_, True)
# end class OpenStaffPosition


class ObjectiveAssessment(ComplexObjectType):
    """This entity represents subtests that assess specific learning
    objectves."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, IdentificationCode=None, MaxRawScore=None, AssessmentItemReference=None, LearningObjectiveReference=None, ObjectAssessmentReference=None, AssessmentRatingStandardReference=None, Nomenclature=None):
        super(ObjectiveAssessment, self).__init__(id, )
        self.IdentificationCode = IdentificationCode
        self.MaxRawScore = MaxRawScore
        if AssessmentItemReference is None:
            self.AssessmentItemReference = []
        else:
            self.AssessmentItemReference = AssessmentItemReference
        if LearningObjectiveReference is None:
            self.LearningObjectiveReference = []
        else:
            self.LearningObjectiveReference = LearningObjectiveReference
        if ObjectAssessmentReference is None:
            self.ObjectAssessmentReference = []
        else:
            self.ObjectAssessmentReference = ObjectAssessmentReference
        if AssessmentRatingStandardReference is None:
            self.AssessmentRatingStandardReference = []
        else:
            self.AssessmentRatingStandardReference = AssessmentRatingStandardReference
        self.Nomenclature = Nomenclature
    def factory(*args_, **kwargs_):
        if ObjectiveAssessment.subclass:
            return ObjectiveAssessment.subclass(*args_, **kwargs_)
        else:
            return ObjectiveAssessment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IdentificationCode(self): return self.IdentificationCode
    def set_IdentificationCode(self, IdentificationCode): self.IdentificationCode = IdentificationCode
    def validate_IdentificationCode(self, value):
        # Validate type IdentificationCode, a restriction on xs:string.
        pass
    def get_MaxRawScore(self): return self.MaxRawScore
    def set_MaxRawScore(self, MaxRawScore): self.MaxRawScore = MaxRawScore
    def get_AssessmentItemReference(self): return self.AssessmentItemReference
    def set_AssessmentItemReference(self, AssessmentItemReference): self.AssessmentItemReference = AssessmentItemReference
    def add_AssessmentItemReference(self, value): self.AssessmentItemReference.append(value)
    def insert_AssessmentItemReference(self, index, value): self.AssessmentItemReference[index] = value
    def get_LearningObjectiveReference(self): return self.LearningObjectiveReference
    def set_LearningObjectiveReference(self, LearningObjectiveReference): self.LearningObjectiveReference = LearningObjectiveReference
    def add_LearningObjectiveReference(self, value): self.LearningObjectiveReference.append(value)
    def insert_LearningObjectiveReference(self, index, value): self.LearningObjectiveReference[index] = value
    def get_ObjectAssessmentReference(self): return self.ObjectAssessmentReference
    def set_ObjectAssessmentReference(self, ObjectAssessmentReference): self.ObjectAssessmentReference = ObjectAssessmentReference
    def add_ObjectAssessmentReference(self, value): self.ObjectAssessmentReference.append(value)
    def insert_ObjectAssessmentReference(self, index, value): self.ObjectAssessmentReference[index] = value
    def get_AssessmentRatingStandardReference(self): return self.AssessmentRatingStandardReference
    def set_AssessmentRatingStandardReference(self, AssessmentRatingStandardReference): self.AssessmentRatingStandardReference = AssessmentRatingStandardReference
    def add_AssessmentRatingStandardReference(self, value): self.AssessmentRatingStandardReference.append(value)
    def insert_AssessmentRatingStandardReference(self, index, value): self.AssessmentRatingStandardReference[index] = value
    def get_Nomenclature(self): return self.Nomenclature
    def set_Nomenclature(self, Nomenclature): self.Nomenclature = Nomenclature
    def validate_Nomenclature(self, value):
        # Validate type Nomenclature, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='ObjectiveAssessment', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectiveAssessment')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ObjectiveAssessment'):
        super(ObjectiveAssessment, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectiveAssessment')
    def exportChildren(self, outfile, level, namespace_='', name_='ObjectiveAssessment', fromsubclass_=False):
        super(ObjectiveAssessment, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.IdentificationCode is not None:
            showIndent(outfile, level)
            outfile.write('<%sIdentificationCode>%s</%sIdentificationCode>\n' % (namespace_, self.gds_format_string(quote_xml(self.IdentificationCode).encode(ExternalEncoding), input_name='IdentificationCode'), namespace_))
        if self.MaxRawScore is not None:
            showIndent(outfile, level)
            outfile.write('<%sMaxRawScore>%s</%sMaxRawScore>\n' % (namespace_, self.gds_format_integer(self.MaxRawScore, input_name='MaxRawScore'), namespace_))
        for AssessmentItemReference_ in self.AssessmentItemReference:
            AssessmentItemReference_.export(outfile, level, namespace_, name_='AssessmentItemReference')
        for LearningObjectiveReference_ in self.LearningObjectiveReference:
            LearningObjectiveReference_.export(outfile, level, namespace_, name_='LearningObjectiveReference')
        for ObjectAssessmentReference_ in self.ObjectAssessmentReference:
            ObjectAssessmentReference_.export(outfile, level, namespace_, name_='ObjectAssessmentReference')
        for AssessmentRatingStandardReference_ in self.AssessmentRatingStandardReference:
            AssessmentRatingStandardReference_.export(outfile, level, namespace_, name_='AssessmentRatingStandardReference')
        if self.Nomenclature is not None:
            showIndent(outfile, level)
            outfile.write('<%sNomenclature>%s</%sNomenclature>\n' % (namespace_, self.gds_format_string(quote_xml(self.Nomenclature).encode(ExternalEncoding), input_name='Nomenclature'), namespace_))
    def hasContent_(self):
        if (
            self.IdentificationCode is not None or
            self.MaxRawScore is not None or
            self.AssessmentItemReference or
            self.LearningObjectiveReference or
            self.ObjectAssessmentReference or
            self.AssessmentRatingStandardReference or
            self.Nomenclature is not None or
            super(ObjectiveAssessment, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ObjectiveAssessment'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ObjectiveAssessment, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ObjectiveAssessment, self).exportLiteralChildren(outfile, level, name_)
        if self.IdentificationCode is not None:
            showIndent(outfile, level)
            outfile.write('IdentificationCode=%s,\n' % quote_python(self.IdentificationCode).encode(ExternalEncoding))
        if self.MaxRawScore is not None:
            showIndent(outfile, level)
            outfile.write('MaxRawScore=%d,\n' % self.MaxRawScore)
        showIndent(outfile, level)
        outfile.write('AssessmentItemReference=[\n')
        level += 1
        for AssessmentItemReference_ in self.AssessmentItemReference:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            AssessmentItemReference_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LearningObjectiveReference=[\n')
        level += 1
        for LearningObjectiveReference_ in self.LearningObjectiveReference:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            LearningObjectiveReference_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ObjectAssessmentReference=[\n')
        level += 1
        for ObjectAssessmentReference_ in self.ObjectAssessmentReference:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            ObjectAssessmentReference_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AssessmentRatingStandardReference=[\n')
        level += 1
        for AssessmentRatingStandardReference_ in self.AssessmentRatingStandardReference:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            AssessmentRatingStandardReference_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Nomenclature is not None:
            showIndent(outfile, level)
            outfile.write('Nomenclature=%s,\n' % quote_python(self.Nomenclature).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(ObjectiveAssessment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IdentificationCode':
            IdentificationCode_ = child_.text
            IdentificationCode_ = self.gds_validate_string(IdentificationCode_, node, 'IdentificationCode')
            self.IdentificationCode = IdentificationCode_
            self.validate_IdentificationCode(self.IdentificationCode)    # validate type IdentificationCode
        elif nodeName_ == 'MaxRawScore':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MaxRawScore')
            self.MaxRawScore = ival_
        elif nodeName_ == 'AssessmentItemReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.AssessmentItemReference.append(obj_)
        elif nodeName_ == 'LearningObjectiveReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.LearningObjectiveReference.append(obj_)
        elif nodeName_ == 'ObjectAssessmentReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ObjectAssessmentReference.append(obj_)
        elif nodeName_ == 'AssessmentRatingStandardReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.AssessmentRatingStandardReference.append(obj_)
        elif nodeName_ == 'Nomenclature':
            Nomenclature_ = child_.text
            Nomenclature_ = self.gds_validate_string(Nomenclature_, node, 'Nomenclature')
            self.Nomenclature = Nomenclature_
            self.validate_Nomenclature(self.Nomenclature)    # validate type Nomenclature
        super(ObjectiveAssessment, self).buildChildren(child_, node, nodeName_, True)
# end class ObjectiveAssessment


class Location(ComplexObjectType):
    """This entity represents the physical space where students gather for
    a particular class/section. The location may be an indoor or
    outdoor area designated for the purpose of meeting the
    educational needs of students."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, ClassroomIdentificationCode=None, MaximumNumberOfSeats=None, OptimalNumberOfSeats=None):
        super(Location, self).__init__(id, )
        self.ClassroomIdentificationCode = ClassroomIdentificationCode
        self.MaximumNumberOfSeats = MaximumNumberOfSeats
        self.OptimalNumberOfSeats = OptimalNumberOfSeats
    def factory(*args_, **kwargs_):
        if Location.subclass:
            return Location.subclass(*args_, **kwargs_)
        else:
            return Location(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ClassroomIdentificationCode(self): return self.ClassroomIdentificationCode
    def set_ClassroomIdentificationCode(self, ClassroomIdentificationCode): self.ClassroomIdentificationCode = ClassroomIdentificationCode
    def validate_ClassroomIdentificationCode(self, value):
        # Validate type ClassroomIdentificationCode, a restriction on xs:string.
        pass
    def get_MaximumNumberOfSeats(self): return self.MaximumNumberOfSeats
    def set_MaximumNumberOfSeats(self, MaximumNumberOfSeats): self.MaximumNumberOfSeats = MaximumNumberOfSeats
    def get_OptimalNumberOfSeats(self): return self.OptimalNumberOfSeats
    def set_OptimalNumberOfSeats(self, OptimalNumberOfSeats): self.OptimalNumberOfSeats = OptimalNumberOfSeats
    def export(self, outfile, level, namespace_='', name_='Location', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Location')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Location'):
        super(Location, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Location')
    def exportChildren(self, outfile, level, namespace_='', name_='Location', fromsubclass_=False):
        super(Location, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.ClassroomIdentificationCode is not None:
            showIndent(outfile, level)
            outfile.write('<%sClassroomIdentificationCode>%s</%sClassroomIdentificationCode>\n' % (namespace_, self.gds_format_string(quote_xml(self.ClassroomIdentificationCode).encode(ExternalEncoding), input_name='ClassroomIdentificationCode'), namespace_))
        if self.MaximumNumberOfSeats is not None:
            showIndent(outfile, level)
            outfile.write('<%sMaximumNumberOfSeats>%s</%sMaximumNumberOfSeats>\n' % (namespace_, self.gds_format_integer(self.MaximumNumberOfSeats, input_name='MaximumNumberOfSeats'), namespace_))
        if self.OptimalNumberOfSeats is not None:
            showIndent(outfile, level)
            outfile.write('<%sOptimalNumberOfSeats>%s</%sOptimalNumberOfSeats>\n' % (namespace_, self.gds_format_integer(self.OptimalNumberOfSeats, input_name='OptimalNumberOfSeats'), namespace_))
    def hasContent_(self):
        if (
            self.ClassroomIdentificationCode is not None or
            self.MaximumNumberOfSeats is not None or
            self.OptimalNumberOfSeats is not None or
            super(Location, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Location'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Location, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Location, self).exportLiteralChildren(outfile, level, name_)
        if self.ClassroomIdentificationCode is not None:
            showIndent(outfile, level)
            outfile.write('ClassroomIdentificationCode=%s,\n' % quote_python(self.ClassroomIdentificationCode).encode(ExternalEncoding))
        if self.MaximumNumberOfSeats is not None:
            showIndent(outfile, level)
            outfile.write('MaximumNumberOfSeats=%d,\n' % self.MaximumNumberOfSeats)
        if self.OptimalNumberOfSeats is not None:
            showIndent(outfile, level)
            outfile.write('OptimalNumberOfSeats=%d,\n' % self.OptimalNumberOfSeats)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Location, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ClassroomIdentificationCode':
            ClassroomIdentificationCode_ = child_.text
            ClassroomIdentificationCode_ = self.gds_validate_string(ClassroomIdentificationCode_, node, 'ClassroomIdentificationCode')
            self.ClassroomIdentificationCode = ClassroomIdentificationCode_
            self.validate_ClassroomIdentificationCode(self.ClassroomIdentificationCode)    # validate type ClassroomIdentificationCode
        elif nodeName_ == 'MaximumNumberOfSeats':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MaximumNumberOfSeats')
            self.MaximumNumberOfSeats = ival_
        elif nodeName_ == 'OptimalNumberOfSeats':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OptimalNumberOfSeats')
            self.OptimalNumberOfSeats = ival_
        super(Location, self).buildChildren(child_, node, nodeName_, True)
# end class Location


class LeaveEvent(ComplexObjectType):
    """This event entity represents the recording of the dates of staff
    leave (e.g., sick leave, personal time, vacation, etc.)."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, EventDate=None, LeaveEventDescriptor=None, LeaveEventReason=None, HoursOnLeave=None, SubstituteAssigned=None, StaffReference=None):
        super(LeaveEvent, self).__init__(id, )
        self.EventDate = EventDate
        self.LeaveEventDescriptor = LeaveEventDescriptor
        self.LeaveEventReason = LeaveEventReason
        self.HoursOnLeave = HoursOnLeave
        self.SubstituteAssigned = SubstituteAssigned
        self.StaffReference = StaffReference
    def factory(*args_, **kwargs_):
        if LeaveEvent.subclass:
            return LeaveEvent.subclass(*args_, **kwargs_)
        else:
            return LeaveEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EventDate(self): return self.EventDate
    def set_EventDate(self, EventDate): self.EventDate = EventDate
    def get_LeaveEventDescriptor(self): return self.LeaveEventDescriptor
    def set_LeaveEventDescriptor(self, LeaveEventDescriptor): self.LeaveEventDescriptor = LeaveEventDescriptor
    def validate_AttendanceEventDescriptorType(self, value):
        # Validate type AttendanceEventDescriptorType, a restriction on xs:token.
        pass
    def get_LeaveEventReason(self): return self.LeaveEventReason
    def set_LeaveEventReason(self, LeaveEventReason): self.LeaveEventReason = LeaveEventReason
    def validate_LeaveEventReason(self, value):
        # Validate type LeaveEventReason, a restriction on xs:string.
        pass
    def get_HoursOnLeave(self): return self.HoursOnLeave
    def set_HoursOnLeave(self, HoursOnLeave): self.HoursOnLeave = HoursOnLeave
    def get_SubstituteAssigned(self): return self.SubstituteAssigned
    def set_SubstituteAssigned(self, SubstituteAssigned): self.SubstituteAssigned = SubstituteAssigned
    def get_StaffReference(self): return self.StaffReference
    def set_StaffReference(self, StaffReference): self.StaffReference = StaffReference
    def export(self, outfile, level, namespace_='', name_='LeaveEvent', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LeaveEvent')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LeaveEvent'):
        super(LeaveEvent, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LeaveEvent')
    def exportChildren(self, outfile, level, namespace_='', name_='LeaveEvent', fromsubclass_=False):
        super(LeaveEvent, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.EventDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sEventDate>%s</%sEventDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.EventDate).encode(ExternalEncoding), input_name='EventDate'), namespace_))
        if self.LeaveEventDescriptor is not None:
            showIndent(outfile, level)
            outfile.write('<%sLeaveEventDescriptor>%s</%sLeaveEventDescriptor>\n' % (namespace_, self.gds_format_string(quote_xml(self.LeaveEventDescriptor).encode(ExternalEncoding), input_name='LeaveEventDescriptor'), namespace_))
        if self.LeaveEventReason is not None:
            showIndent(outfile, level)
            outfile.write('<%sLeaveEventReason>%s</%sLeaveEventReason>\n' % (namespace_, self.gds_format_string(quote_xml(self.LeaveEventReason).encode(ExternalEncoding), input_name='LeaveEventReason'), namespace_))
        if self.HoursOnLeave is not None:
            showIndent(outfile, level)
            outfile.write('<%sHoursOnLeave>%s</%sHoursOnLeave>\n' % (namespace_, self.gds_format_float(self.HoursOnLeave, input_name='HoursOnLeave'), namespace_))
        if self.SubstituteAssigned is not None:
            showIndent(outfile, level)
            outfile.write('<%sSubstituteAssigned>%s</%sSubstituteAssigned>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.SubstituteAssigned)), input_name='SubstituteAssigned'), namespace_))
        if self.StaffReference:
            self.StaffReference.export(outfile, level, namespace_, name_='StaffReference', )
    def hasContent_(self):
        if (
            self.EventDate is not None or
            self.LeaveEventDescriptor is not None or
            self.LeaveEventReason is not None or
            self.HoursOnLeave is not None or
            self.SubstituteAssigned is not None or
            self.StaffReference is not None or
            super(LeaveEvent, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LeaveEvent'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LeaveEvent, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LeaveEvent, self).exportLiteralChildren(outfile, level, name_)
        if self.EventDate is not None:
            showIndent(outfile, level)
            outfile.write('EventDate=%s,\n' % quote_python(self.EventDate).encode(ExternalEncoding))
        if self.LeaveEventDescriptor is not None:
            showIndent(outfile, level)
            outfile.write('LeaveEventDescriptor=%s,\n' % quote_python(self.LeaveEventDescriptor).encode(ExternalEncoding))
        if self.LeaveEventReason is not None:
            showIndent(outfile, level)
            outfile.write('LeaveEventReason=%s,\n' % quote_python(self.LeaveEventReason).encode(ExternalEncoding))
        if self.HoursOnLeave is not None:
            showIndent(outfile, level)
            outfile.write('HoursOnLeave=%f,\n' % self.HoursOnLeave)
        if self.SubstituteAssigned is not None:
            showIndent(outfile, level)
            outfile.write('SubstituteAssigned=%s,\n' % self.SubstituteAssigned)
        if self.StaffReference is not None:
            showIndent(outfile, level)
            outfile.write('StaffReference=model_.StaffReferenceType(\n')
            self.StaffReference.exportLiteral(outfile, level, name_='StaffReference')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(LeaveEvent, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EventDate':
            EventDate_ = child_.text
            EventDate_ = self.gds_validate_string(EventDate_, node, 'EventDate')
            self.EventDate = EventDate_
        elif nodeName_ == 'LeaveEventDescriptor':
            LeaveEventDescriptor_ = child_.text
            LeaveEventDescriptor_ = re_.sub(String_cleanup_pat_, " ", LeaveEventDescriptor_).strip()
            LeaveEventDescriptor_ = self.gds_validate_string(LeaveEventDescriptor_, node, 'LeaveEventDescriptor')
            self.LeaveEventDescriptor = LeaveEventDescriptor_
            self.validate_AttendanceEventDescriptorType(self.LeaveEventDescriptor)    # validate type AttendanceEventDescriptorType
        elif nodeName_ == 'LeaveEventReason':
            LeaveEventReason_ = child_.text
            LeaveEventReason_ = self.gds_validate_string(LeaveEventReason_, node, 'LeaveEventReason')
            self.LeaveEventReason = LeaveEventReason_
            self.validate_LeaveEventReason(self.LeaveEventReason)    # validate type LeaveEventReason
        elif nodeName_ == 'HoursOnLeave':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'HoursOnLeave')
            self.HoursOnLeave = fval_
        elif nodeName_ == 'SubstituteAssigned':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'SubstituteAssigned')
            self.SubstituteAssigned = ival_
        elif nodeName_ == 'StaffReference':
            obj_ = StaffReferenceType.factory()
            obj_.build(child_)
            self.set_StaffReference(obj_)
        super(LeaveEvent, self).buildChildren(child_, node, nodeName_, True)
# end class LeaveEvent


class LearningObjective(ComplexObjectType):
    """This entity represents identified learning objectives for courses in
    specific grades."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, Objective=None, ObjectiveDescription=None, AcademicSubject=None, ObjectiveGradeLevel=None, StudentExpectationReference=None, LearningObjectiveReference=None):
        super(LearningObjective, self).__init__(id, )
        self.Objective = Objective
        self.ObjectiveDescription = ObjectiveDescription
        self.AcademicSubject = AcademicSubject
        self.ObjectiveGradeLevel = ObjectiveGradeLevel
        if StudentExpectationReference is None:
            self.StudentExpectationReference = []
        else:
            self.StudentExpectationReference = StudentExpectationReference
        if LearningObjectiveReference is None:
            self.LearningObjectiveReference = []
        else:
            self.LearningObjectiveReference = LearningObjectiveReference
    def factory(*args_, **kwargs_):
        if LearningObjective.subclass:
            return LearningObjective.subclass(*args_, **kwargs_)
        else:
            return LearningObjective(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Objective(self): return self.Objective
    def set_Objective(self, Objective): self.Objective = Objective
    def validate_ObjectiveType(self, value):
        # Validate type ObjectiveType, a restriction on xs:string.
        pass
    def get_ObjectiveDescription(self): return self.ObjectiveDescription
    def set_ObjectiveDescription(self, ObjectiveDescription): self.ObjectiveDescription = ObjectiveDescription
    def validate_ObjectiveDescription(self, value):
        # Validate type ObjectiveDescription, a restriction on xs:string.
        pass
    def get_AcademicSubject(self): return self.AcademicSubject
    def set_AcademicSubject(self, AcademicSubject): self.AcademicSubject = AcademicSubject
    def validate_AcademicSubjectType(self, value):
        # Validate type AcademicSubjectType, a restriction on xs:token.
        pass
    def get_ObjectiveGradeLevel(self): return self.ObjectiveGradeLevel
    def set_ObjectiveGradeLevel(self, ObjectiveGradeLevel): self.ObjectiveGradeLevel = ObjectiveGradeLevel
    def validate_GradeLevelType(self, value):
        # Validate type GradeLevelType, a restriction on xs:token.
        pass
    def get_StudentExpectationReference(self): return self.StudentExpectationReference
    def set_StudentExpectationReference(self, StudentExpectationReference): self.StudentExpectationReference = StudentExpectationReference
    def add_StudentExpectationReference(self, value): self.StudentExpectationReference.append(value)
    def insert_StudentExpectationReference(self, index, value): self.StudentExpectationReference[index] = value
    def get_LearningObjectiveReference(self): return self.LearningObjectiveReference
    def set_LearningObjectiveReference(self, LearningObjectiveReference): self.LearningObjectiveReference = LearningObjectiveReference
    def add_LearningObjectiveReference(self, value): self.LearningObjectiveReference.append(value)
    def insert_LearningObjectiveReference(self, index, value): self.LearningObjectiveReference[index] = value
    def export(self, outfile, level, namespace_='', name_='LearningObjective', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LearningObjective')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LearningObjective'):
        super(LearningObjective, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LearningObjective')
    def exportChildren(self, outfile, level, namespace_='', name_='LearningObjective', fromsubclass_=False):
        super(LearningObjective, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.Objective is not None:
            showIndent(outfile, level)
            outfile.write('<%sObjective>%s</%sObjective>\n' % (namespace_, self.gds_format_string(quote_xml(self.Objective).encode(ExternalEncoding), input_name='Objective'), namespace_))
        if self.ObjectiveDescription is not None:
            showIndent(outfile, level)
            outfile.write('<%sObjectiveDescription>%s</%sObjectiveDescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.ObjectiveDescription).encode(ExternalEncoding), input_name='ObjectiveDescription'), namespace_))
        if self.AcademicSubject is not None:
            showIndent(outfile, level)
            outfile.write('<%sAcademicSubject>%s</%sAcademicSubject>\n' % (namespace_, self.gds_format_string(quote_xml(self.AcademicSubject).encode(ExternalEncoding), input_name='AcademicSubject'), namespace_))
        if self.ObjectiveGradeLevel is not None:
            showIndent(outfile, level)
            outfile.write('<%sObjectiveGradeLevel>%s</%sObjectiveGradeLevel>\n' % (namespace_, self.gds_format_string(quote_xml(self.ObjectiveGradeLevel).encode(ExternalEncoding), input_name='ObjectiveGradeLevel'), namespace_))
        for StudentExpectationReference_ in self.StudentExpectationReference:
            StudentExpectationReference_.export(outfile, level, namespace_, name_='StudentExpectationReference')
        for LearningObjectiveReference_ in self.LearningObjectiveReference:
            LearningObjectiveReference_.export(outfile, level, namespace_, name_='LearningObjectiveReference')
    def hasContent_(self):
        if (
            self.Objective is not None or
            self.ObjectiveDescription is not None or
            self.AcademicSubject is not None or
            self.ObjectiveGradeLevel is not None or
            self.StudentExpectationReference or
            self.LearningObjectiveReference or
            super(LearningObjective, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LearningObjective'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LearningObjective, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LearningObjective, self).exportLiteralChildren(outfile, level, name_)
        if self.Objective is not None:
            showIndent(outfile, level)
            outfile.write('Objective=%s,\n' % quote_python(self.Objective).encode(ExternalEncoding))
        if self.ObjectiveDescription is not None:
            showIndent(outfile, level)
            outfile.write('ObjectiveDescription=%s,\n' % quote_python(self.ObjectiveDescription).encode(ExternalEncoding))
        if self.AcademicSubject is not None:
            showIndent(outfile, level)
            outfile.write('AcademicSubject=%s,\n' % quote_python(self.AcademicSubject).encode(ExternalEncoding))
        if self.ObjectiveGradeLevel is not None:
            showIndent(outfile, level)
            outfile.write('ObjectiveGradeLevel=%s,\n' % quote_python(self.ObjectiveGradeLevel).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('StudentExpectationReference=[\n')
        level += 1
        for StudentExpectationReference_ in self.StudentExpectationReference:
            showIndent(outfile, level)
            outfile.write('model_.StudentExpectationReferenceType(\n')
            StudentExpectationReference_.exportLiteral(outfile, level, name_='StudentExpectationReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LearningObjectiveReference=[\n')
        level += 1
        for LearningObjectiveReference_ in self.LearningObjectiveReference:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            LearningObjectiveReference_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(LearningObjective, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Objective':
            Objective_ = child_.text
            Objective_ = self.gds_validate_string(Objective_, node, 'Objective')
            self.Objective = Objective_
            self.validate_ObjectiveType(self.Objective)    # validate type ObjectiveType
        elif nodeName_ == 'ObjectiveDescription':
            ObjectiveDescription_ = child_.text
            ObjectiveDescription_ = self.gds_validate_string(ObjectiveDescription_, node, 'ObjectiveDescription')
            self.ObjectiveDescription = ObjectiveDescription_
            self.validate_ObjectiveDescription(self.ObjectiveDescription)    # validate type ObjectiveDescription
        elif nodeName_ == 'AcademicSubject':
            AcademicSubject_ = child_.text
            AcademicSubject_ = re_.sub(String_cleanup_pat_, " ", AcademicSubject_).strip()
            AcademicSubject_ = self.gds_validate_string(AcademicSubject_, node, 'AcademicSubject')
            self.AcademicSubject = AcademicSubject_
            self.validate_AcademicSubjectType(self.AcademicSubject)    # validate type AcademicSubjectType
        elif nodeName_ == 'ObjectiveGradeLevel':
            ObjectiveGradeLevel_ = child_.text
            ObjectiveGradeLevel_ = re_.sub(String_cleanup_pat_, " ", ObjectiveGradeLevel_).strip()
            ObjectiveGradeLevel_ = self.gds_validate_string(ObjectiveGradeLevel_, node, 'ObjectiveGradeLevel')
            self.ObjectiveGradeLevel = ObjectiveGradeLevel_
            self.validate_GradeLevelType(self.ObjectiveGradeLevel)    # validate type GradeLevelType
        elif nodeName_ == 'StudentExpectationReference':
            obj_ = StudentExpectationReferenceType.factory()
            obj_.build(child_)
            self.StudentExpectationReference.append(obj_)
        elif nodeName_ == 'LearningObjectiveReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.LearningObjectiveReference.append(obj_)
        super(LearningObjective, self).buildChildren(child_, node, nodeName_, True)
# end class LearningObjective


class GradingPeriod(ComplexObjectType):
    """This entity represents the time span for which grades are reported."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, GradingPeriod=None, BeginDate=None, EndDate=None, TotalInstructionalDays=None, CalendarDateReference=None):
        super(GradingPeriod, self).__init__(id, )
        self.GradingPeriod = GradingPeriod
        self.BeginDate = BeginDate
        self.EndDate = EndDate
        self.TotalInstructionalDays = TotalInstructionalDays
        if CalendarDateReference is None:
            self.CalendarDateReference = []
        else:
            self.CalendarDateReference = CalendarDateReference
    def factory(*args_, **kwargs_):
        if GradingPeriod.subclass:
            return GradingPeriod.subclass(*args_, **kwargs_)
        else:
            return GradingPeriod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GradingPeriod(self): return self.GradingPeriod
    def set_GradingPeriod(self, GradingPeriod): self.GradingPeriod = GradingPeriod
    def validate_GradingPeriodType(self, value):
        # Validate type GradingPeriodType, a restriction on xs:token.
        pass
    def get_BeginDate(self): return self.BeginDate
    def set_BeginDate(self, BeginDate): self.BeginDate = BeginDate
    def get_EndDate(self): return self.EndDate
    def set_EndDate(self, EndDate): self.EndDate = EndDate
    def get_TotalInstructionalDays(self): return self.TotalInstructionalDays
    def set_TotalInstructionalDays(self, TotalInstructionalDays): self.TotalInstructionalDays = TotalInstructionalDays
    def get_CalendarDateReference(self): return self.CalendarDateReference
    def set_CalendarDateReference(self, CalendarDateReference): self.CalendarDateReference = CalendarDateReference
    def add_CalendarDateReference(self, value): self.CalendarDateReference.append(value)
    def insert_CalendarDateReference(self, index, value): self.CalendarDateReference[index] = value
    def export(self, outfile, level, namespace_='', name_='GradingPeriod', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GradingPeriod')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GradingPeriod'):
        super(GradingPeriod, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GradingPeriod')
    def exportChildren(self, outfile, level, namespace_='', name_='GradingPeriod', fromsubclass_=False):
        super(GradingPeriod, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.GradingPeriod is not None:
            showIndent(outfile, level)
            outfile.write('<%sGradingPeriod>%s</%sGradingPeriod>\n' % (namespace_, self.gds_format_string(quote_xml(self.GradingPeriod).encode(ExternalEncoding), input_name='GradingPeriod'), namespace_))
        if self.BeginDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sBeginDate>%s</%sBeginDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.BeginDate).encode(ExternalEncoding), input_name='BeginDate'), namespace_))
        if self.EndDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sEndDate>%s</%sEndDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.EndDate).encode(ExternalEncoding), input_name='EndDate'), namespace_))
        if self.TotalInstructionalDays is not None:
            showIndent(outfile, level)
            outfile.write('<%sTotalInstructionalDays>%s</%sTotalInstructionalDays>\n' % (namespace_, self.gds_format_integer(self.TotalInstructionalDays, input_name='TotalInstructionalDays'), namespace_))
        for CalendarDateReference_ in self.CalendarDateReference:
            CalendarDateReference_.export(outfile, level, namespace_, name_='CalendarDateReference')
    def hasContent_(self):
        if (
            self.GradingPeriod is not None or
            self.BeginDate is not None or
            self.EndDate is not None or
            self.TotalInstructionalDays is not None or
            self.CalendarDateReference or
            super(GradingPeriod, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GradingPeriod'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GradingPeriod, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GradingPeriod, self).exportLiteralChildren(outfile, level, name_)
        if self.GradingPeriod is not None:
            showIndent(outfile, level)
            outfile.write('GradingPeriod=%s,\n' % quote_python(self.GradingPeriod).encode(ExternalEncoding))
        if self.BeginDate is not None:
            showIndent(outfile, level)
            outfile.write('BeginDate=%s,\n' % quote_python(self.BeginDate).encode(ExternalEncoding))
        if self.EndDate is not None:
            showIndent(outfile, level)
            outfile.write('EndDate=%s,\n' % quote_python(self.EndDate).encode(ExternalEncoding))
        if self.TotalInstructionalDays is not None:
            showIndent(outfile, level)
            outfile.write('TotalInstructionalDays=%d,\n' % self.TotalInstructionalDays)
        showIndent(outfile, level)
        outfile.write('CalendarDateReference=[\n')
        level += 1
        for CalendarDateReference_ in self.CalendarDateReference:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            CalendarDateReference_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(GradingPeriod, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GradingPeriod':
            GradingPeriod_ = child_.text
            GradingPeriod_ = re_.sub(String_cleanup_pat_, " ", GradingPeriod_).strip()
            GradingPeriod_ = self.gds_validate_string(GradingPeriod_, node, 'GradingPeriod')
            self.GradingPeriod = GradingPeriod_
            self.validate_GradingPeriodType(self.GradingPeriod)    # validate type GradingPeriodType
        elif nodeName_ == 'BeginDate':
            BeginDate_ = child_.text
            BeginDate_ = self.gds_validate_string(BeginDate_, node, 'BeginDate')
            self.BeginDate = BeginDate_
        elif nodeName_ == 'EndDate':
            EndDate_ = child_.text
            EndDate_ = self.gds_validate_string(EndDate_, node, 'EndDate')
            self.EndDate = EndDate_
        elif nodeName_ == 'TotalInstructionalDays':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TotalInstructionalDays')
            self.TotalInstructionalDays = ival_
        elif nodeName_ == 'CalendarDateReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.CalendarDateReference.append(obj_)
        super(GradingPeriod, self).buildChildren(child_, node, nodeName_, True)
# end class GradingPeriod


class Grade(ComplexObjectType):
    """This educational entity represents an overall score or assessment
    tied to a course over a period of time (i.e., the grading
    period). Student grades are usually a compilation of marks and
    other scores."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, LetterGradeEarned=None, NumericGradeEarned=None, DiagnosticStatement=None, GradeType=None, StudentSectionAssociationReference=None, GradingPeriodReference=None):
        super(Grade, self).__init__(id, )
        self.LetterGradeEarned = LetterGradeEarned
        self.NumericGradeEarned = NumericGradeEarned
        self.DiagnosticStatement = DiagnosticStatement
        self.GradeType = GradeType
        self.StudentSectionAssociationReference = StudentSectionAssociationReference
        self.GradingPeriodReference = GradingPeriodReference
    def factory(*args_, **kwargs_):
        if Grade.subclass:
            return Grade.subclass(*args_, **kwargs_)
        else:
            return Grade(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LetterGradeEarned(self): return self.LetterGradeEarned
    def set_LetterGradeEarned(self, LetterGradeEarned): self.LetterGradeEarned = LetterGradeEarned
    def get_NumericGradeEarned(self): return self.NumericGradeEarned
    def set_NumericGradeEarned(self, NumericGradeEarned): self.NumericGradeEarned = NumericGradeEarned
    def get_DiagnosticStatement(self): return self.DiagnosticStatement
    def set_DiagnosticStatement(self, DiagnosticStatement): self.DiagnosticStatement = DiagnosticStatement
    def validate_text(self, value):
        # Validate type text, a restriction on xs:token.
        pass
    def get_GradeType(self): return self.GradeType
    def set_GradeType(self, GradeType): self.GradeType = GradeType
    def validate_GradeType(self, value):
        # Validate type GradeType, a restriction on xs:token.
        pass
    def get_StudentSectionAssociationReference(self): return self.StudentSectionAssociationReference
    def set_StudentSectionAssociationReference(self, StudentSectionAssociationReference): self.StudentSectionAssociationReference = StudentSectionAssociationReference
    def get_GradingPeriodReference(self): return self.GradingPeriodReference
    def set_GradingPeriodReference(self, GradingPeriodReference): self.GradingPeriodReference = GradingPeriodReference
    def export(self, outfile, level, namespace_='', name_='Grade', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Grade')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Grade'):
        super(Grade, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Grade')
    def exportChildren(self, outfile, level, namespace_='', name_='Grade', fromsubclass_=False):
        super(Grade, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.LetterGradeEarned is not None:
            showIndent(outfile, level)
            outfile.write('<%sLetterGradeEarned>%s</%sLetterGradeEarned>\n' % (namespace_, self.gds_format_string(quote_xml(self.LetterGradeEarned).encode(ExternalEncoding), input_name='LetterGradeEarned'), namespace_))
        if self.NumericGradeEarned is not None:
            showIndent(outfile, level)
            outfile.write('<%sNumericGradeEarned>%s</%sNumericGradeEarned>\n' % (namespace_, self.gds_format_integer(self.NumericGradeEarned, input_name='NumericGradeEarned'), namespace_))
        if self.DiagnosticStatement is not None:
            showIndent(outfile, level)
            outfile.write('<%sDiagnosticStatement>%s</%sDiagnosticStatement>\n' % (namespace_, self.gds_format_string(quote_xml(self.DiagnosticStatement).encode(ExternalEncoding), input_name='DiagnosticStatement'), namespace_))
        if self.GradeType is not None:
            showIndent(outfile, level)
            outfile.write('<%sGradeType>%s</%sGradeType>\n' % (namespace_, self.gds_format_string(quote_xml(self.GradeType).encode(ExternalEncoding), input_name='GradeType'), namespace_))
        if self.StudentSectionAssociationReference:
            self.StudentSectionAssociationReference.export(outfile, level, namespace_, name_='StudentSectionAssociationReference', )
        if self.GradingPeriodReference:
            self.GradingPeriodReference.export(outfile, level, namespace_, name_='GradingPeriodReference', )
    def hasContent_(self):
        if (
            self.LetterGradeEarned is not None or
            self.NumericGradeEarned is not None or
            self.DiagnosticStatement is not None or
            self.GradeType is not None or
            self.StudentSectionAssociationReference is not None or
            self.GradingPeriodReference is not None or
            super(Grade, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Grade'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Grade, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Grade, self).exportLiteralChildren(outfile, level, name_)
        if self.LetterGradeEarned is not None:
            showIndent(outfile, level)
            outfile.write('LetterGradeEarned=%s,\n' % quote_python(self.LetterGradeEarned).encode(ExternalEncoding))
        if self.NumericGradeEarned is not None:
            showIndent(outfile, level)
            outfile.write('NumericGradeEarned=%d,\n' % self.NumericGradeEarned)
        if self.DiagnosticStatement is not None:
            showIndent(outfile, level)
            outfile.write('DiagnosticStatement=%s,\n' % quote_python(self.DiagnosticStatement).encode(ExternalEncoding))
        if self.GradeType is not None:
            showIndent(outfile, level)
            outfile.write('GradeType=%s,\n' % quote_python(self.GradeType).encode(ExternalEncoding))
        if self.StudentSectionAssociationReference is not None:
            showIndent(outfile, level)
            outfile.write('StudentSectionAssociationReference=model_.StudentSectionAssociationReferenceType(\n')
            self.StudentSectionAssociationReference.exportLiteral(outfile, level, name_='StudentSectionAssociationReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GradingPeriodReference is not None:
            showIndent(outfile, level)
            outfile.write('GradingPeriodReference=model_.GradingPeriodReferenceType(\n')
            self.GradingPeriodReference.exportLiteral(outfile, level, name_='GradingPeriodReference')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Grade, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LetterGradeEarned':
            LetterGradeEarned_ = child_.text
            LetterGradeEarned_ = self.gds_validate_string(LetterGradeEarned_, node, 'LetterGradeEarned')
            self.LetterGradeEarned = LetterGradeEarned_
        elif nodeName_ == 'NumericGradeEarned':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumericGradeEarned')
            self.NumericGradeEarned = ival_
        elif nodeName_ == 'DiagnosticStatement':
            DiagnosticStatement_ = child_.text
            DiagnosticStatement_ = re_.sub(String_cleanup_pat_, " ", DiagnosticStatement_).strip()
            DiagnosticStatement_ = self.gds_validate_string(DiagnosticStatement_, node, 'DiagnosticStatement')
            self.DiagnosticStatement = DiagnosticStatement_
            self.validate_text(self.DiagnosticStatement)    # validate type text
        elif nodeName_ == 'GradeType':
            GradeType_ = child_.text
            GradeType_ = re_.sub(String_cleanup_pat_, " ", GradeType_).strip()
            GradeType_ = self.gds_validate_string(GradeType_, node, 'GradeType')
            self.GradeType = GradeType_
            self.validate_GradeType(self.GradeType)    # validate type GradeType
        elif nodeName_ == 'StudentSectionAssociationReference':
            obj_ = StudentSectionAssociationReferenceType.factory()
            obj_.build(child_)
            self.set_StudentSectionAssociationReference(obj_)
        elif nodeName_ == 'GradingPeriodReference':
            obj_ = GradingPeriodReferenceType.factory()
            obj_.build(child_)
            self.set_GradingPeriodReference(obj_)
        super(Grade, self).buildChildren(child_, node, nodeName_, True)
# end class Grade


class EducationOrganization(ComplexObjectType):
    """This entity represents any public or private institution,
    organization, or agency that provides instructional or support
    services to students or staff at any level."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, StateOrganizationId=None, EducationOrgIdentificationCode=None, NameOfInstitution=None, ShortNameOfInstitution=None, OrganizationCategory=None, Address=None, Telephone=None, WebSite=None, OperationalStatus=None, AccountabilityRatings=None, ProgramReference=None, EducationOrganizationPeerReference=None, extensiontype_=None):
        super(EducationOrganization, self).__init__(id, extensiontype_, )
        self.StateOrganizationId = StateOrganizationId
        if EducationOrgIdentificationCode is None:
            self.EducationOrgIdentificationCode = []
        else:
            self.EducationOrgIdentificationCode = EducationOrgIdentificationCode
        self.NameOfInstitution = NameOfInstitution
        self.ShortNameOfInstitution = ShortNameOfInstitution
        self.OrganizationCategory = OrganizationCategory
        if Address is None:
            self.Address = []
        else:
            self.Address = Address
        if Telephone is None:
            self.Telephone = []
        else:
            self.Telephone = Telephone
        self.WebSite = WebSite
        self.OperationalStatus = OperationalStatus
        if AccountabilityRatings is None:
            self.AccountabilityRatings = []
        else:
            self.AccountabilityRatings = AccountabilityRatings
        if ProgramReference is None:
            self.ProgramReference = []
        else:
            self.ProgramReference = ProgramReference
        if EducationOrganizationPeerReference is None:
            self.EducationOrganizationPeerReference = []
        else:
            self.EducationOrganizationPeerReference = EducationOrganizationPeerReference
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if EducationOrganization.subclass:
            return EducationOrganization.subclass(*args_, **kwargs_)
        else:
            return EducationOrganization(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StateOrganizationId(self): return self.StateOrganizationId
    def set_StateOrganizationId(self, StateOrganizationId): self.StateOrganizationId = StateOrganizationId
    def validate_IdentificationCode(self, value):
        # Validate type IdentificationCode, a restriction on xs:string.
        pass
    def get_EducationOrgIdentificationCode(self): return self.EducationOrgIdentificationCode
    def set_EducationOrgIdentificationCode(self, EducationOrgIdentificationCode): self.EducationOrgIdentificationCode = EducationOrgIdentificationCode
    def add_EducationOrgIdentificationCode(self, value): self.EducationOrgIdentificationCode.append(value)
    def insert_EducationOrgIdentificationCode(self, index, value): self.EducationOrgIdentificationCode[index] = value
    def get_NameOfInstitution(self): return self.NameOfInstitution
    def set_NameOfInstitution(self, NameOfInstitution): self.NameOfInstitution = NameOfInstitution
    def validate_NameOfInstitution(self, value):
        # Validate type NameOfInstitution, a restriction on xs:string.
        pass
    def get_ShortNameOfInstitution(self): return self.ShortNameOfInstitution
    def set_ShortNameOfInstitution(self, ShortNameOfInstitution): self.ShortNameOfInstitution = ShortNameOfInstitution
    def get_OrganizationCategory(self): return self.OrganizationCategory
    def set_OrganizationCategory(self, OrganizationCategory): self.OrganizationCategory = OrganizationCategory
    def validate_EducationOrganizationCategoryType(self, value):
        # Validate type EducationOrganizationCategoryType, a restriction on xs:token.
        pass
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def add_Address(self, value): self.Address.append(value)
    def insert_Address(self, index, value): self.Address[index] = value
    def get_Telephone(self): return self.Telephone
    def set_Telephone(self, Telephone): self.Telephone = Telephone
    def add_Telephone(self, value): self.Telephone.append(value)
    def insert_Telephone(self, index, value): self.Telephone[index] = value
    def get_WebSite(self): return self.WebSite
    def set_WebSite(self, WebSite): self.WebSite = WebSite
    def validate_WebSite(self, value):
        # Validate type WebSite, a restriction on xs:string.
        pass
    def get_OperationalStatus(self): return self.OperationalStatus
    def set_OperationalStatus(self, OperationalStatus): self.OperationalStatus = OperationalStatus
    def validate_OperationalStatusType(self, value):
        # Validate type OperationalStatusType, a restriction on xs:token.
        pass
    def get_AccountabilityRatings(self): return self.AccountabilityRatings
    def set_AccountabilityRatings(self, AccountabilityRatings): self.AccountabilityRatings = AccountabilityRatings
    def add_AccountabilityRatings(self, value): self.AccountabilityRatings.append(value)
    def insert_AccountabilityRatings(self, index, value): self.AccountabilityRatings[index] = value
    def get_ProgramReference(self): return self.ProgramReference
    def set_ProgramReference(self, ProgramReference): self.ProgramReference = ProgramReference
    def add_ProgramReference(self, value): self.ProgramReference.append(value)
    def insert_ProgramReference(self, index, value): self.ProgramReference[index] = value
    def get_EducationOrganizationPeerReference(self): return self.EducationOrganizationPeerReference
    def set_EducationOrganizationPeerReference(self, EducationOrganizationPeerReference): self.EducationOrganizationPeerReference = EducationOrganizationPeerReference
    def add_EducationOrganizationPeerReference(self, value): self.EducationOrganizationPeerReference.append(value)
    def insert_EducationOrganizationPeerReference(self, index, value): self.EducationOrganizationPeerReference[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='EducationOrganization', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EducationOrganization')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EducationOrganization'):
        super(EducationOrganization, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EducationOrganization')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='EducationOrganization', fromsubclass_=False):
        super(EducationOrganization, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.StateOrganizationId is not None:
            showIndent(outfile, level)
            outfile.write('<%sStateOrganizationId>%s</%sStateOrganizationId>\n' % (namespace_, self.gds_format_string(quote_xml(self.StateOrganizationId).encode(ExternalEncoding), input_name='StateOrganizationId'), namespace_))
        for EducationOrgIdentificationCode_ in self.EducationOrgIdentificationCode:
            EducationOrgIdentificationCode_.export(outfile, level, namespace_, name_='EducationOrgIdentificationCode')
        if self.NameOfInstitution is not None:
            showIndent(outfile, level)
            outfile.write('<%sNameOfInstitution>%s</%sNameOfInstitution>\n' % (namespace_, self.gds_format_string(quote_xml(self.NameOfInstitution).encode(ExternalEncoding), input_name='NameOfInstitution'), namespace_))
        if self.ShortNameOfInstitution is not None:
            showIndent(outfile, level)
            outfile.write('<%sShortNameOfInstitution>%s</%sShortNameOfInstitution>\n' % (namespace_, self.gds_format_string(quote_xml(self.ShortNameOfInstitution).encode(ExternalEncoding), input_name='ShortNameOfInstitution'), namespace_))
        if self.OrganizationCategory is not None:
            showIndent(outfile, level)
            outfile.write('<%sOrganizationCategory>%s</%sOrganizationCategory>\n' % (namespace_, self.gds_format_string(quote_xml(self.OrganizationCategory).encode(ExternalEncoding), input_name='OrganizationCategory'), namespace_))
        for Address_ in self.Address:
            Address_.export(outfile, level, namespace_, name_='Address')
        for Telephone_ in self.Telephone:
            Telephone_.export(outfile, level, namespace_, name_='Telephone')
        if self.WebSite is not None:
            showIndent(outfile, level)
            outfile.write('<%sWebSite>%s</%sWebSite>\n' % (namespace_, self.gds_format_string(quote_xml(self.WebSite).encode(ExternalEncoding), input_name='WebSite'), namespace_))
        if self.OperationalStatus is not None:
            showIndent(outfile, level)
            outfile.write('<%sOperationalStatus>%s</%sOperationalStatus>\n' % (namespace_, self.gds_format_string(quote_xml(self.OperationalStatus).encode(ExternalEncoding), input_name='OperationalStatus'), namespace_))
        for AccountabilityRatings_ in self.AccountabilityRatings:
            AccountabilityRatings_.export(outfile, level, namespace_, name_='AccountabilityRatings')
        for ProgramReference_ in self.ProgramReference:
            ProgramReference_.export(outfile, level, namespace_, name_='ProgramReference')
        for EducationOrganizationPeerReference_ in self.EducationOrganizationPeerReference:
            EducationOrganizationPeerReference_.export(outfile, level, namespace_, name_='EducationOrganizationPeerReference')
    def hasContent_(self):
        if (
            self.StateOrganizationId is not None or
            self.EducationOrgIdentificationCode or
            self.NameOfInstitution is not None or
            self.ShortNameOfInstitution is not None or
            self.OrganizationCategory is not None or
            self.Address or
            self.Telephone or
            self.WebSite is not None or
            self.OperationalStatus is not None or
            self.AccountabilityRatings or
            self.ProgramReference or
            self.EducationOrganizationPeerReference or
            super(EducationOrganization, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EducationOrganization'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EducationOrganization, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EducationOrganization, self).exportLiteralChildren(outfile, level, name_)
        if self.StateOrganizationId is not None:
            showIndent(outfile, level)
            outfile.write('StateOrganizationId=%s,\n' % quote_python(self.StateOrganizationId).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('EducationOrgIdentificationCode=[\n')
        level += 1
        for EducationOrgIdentificationCode_ in self.EducationOrgIdentificationCode:
            showIndent(outfile, level)
            outfile.write('model_.EducationOrgIdentificationCode(\n')
            EducationOrgIdentificationCode_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.NameOfInstitution is not None:
            showIndent(outfile, level)
            outfile.write('NameOfInstitution=%s,\n' % quote_python(self.NameOfInstitution).encode(ExternalEncoding))
        if self.ShortNameOfInstitution is not None:
            showIndent(outfile, level)
            outfile.write('ShortNameOfInstitution=%s,\n' % quote_python(self.ShortNameOfInstitution).encode(ExternalEncoding))
        if self.OrganizationCategory is not None:
            showIndent(outfile, level)
            outfile.write('OrganizationCategory=%s,\n' % quote_python(self.OrganizationCategory).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Address=[\n')
        level += 1
        for Address_ in self.Address:
            showIndent(outfile, level)
            outfile.write('model_.Address(\n')
            Address_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Telephone=[\n')
        level += 1
        for Telephone_ in self.Telephone:
            showIndent(outfile, level)
            outfile.write('model_.InstitutionTelephone(\n')
            Telephone_.exportLiteral(outfile, level, name_='InstitutionTelephone')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.WebSite is not None:
            showIndent(outfile, level)
            outfile.write('WebSite=%s,\n' % quote_python(self.WebSite).encode(ExternalEncoding))
        if self.OperationalStatus is not None:
            showIndent(outfile, level)
            outfile.write('OperationalStatus=%s,\n' % quote_python(self.OperationalStatus).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('AccountabilityRatings=[\n')
        level += 1
        for AccountabilityRatings_ in self.AccountabilityRatings:
            showIndent(outfile, level)
            outfile.write('model_.AccountabilityRating(\n')
            AccountabilityRatings_.exportLiteral(outfile, level, name_='AccountabilityRating')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ProgramReference=[\n')
        level += 1
        for ProgramReference_ in self.ProgramReference:
            showIndent(outfile, level)
            outfile.write('model_.ProgramReferenceType(\n')
            ProgramReference_.exportLiteral(outfile, level, name_='ProgramReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('EducationOrganizationPeerReference=[\n')
        level += 1
        for EducationOrganizationPeerReference_ in self.EducationOrganizationPeerReference:
            showIndent(outfile, level)
            outfile.write('model_.EducationalOrgReferenceType(\n')
            EducationOrganizationPeerReference_.exportLiteral(outfile, level, name_='EducationalOrgReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(EducationOrganization, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StateOrganizationId':
            StateOrganizationId_ = child_.text
            StateOrganizationId_ = self.gds_validate_string(StateOrganizationId_, node, 'StateOrganizationId')
            self.StateOrganizationId = StateOrganizationId_
            self.validate_IdentificationCode(self.StateOrganizationId)    # validate type IdentificationCode
        elif nodeName_ == 'EducationOrgIdentificationCode':
            obj_ = EducationOrgIdentificationCode.factory()
            obj_.build(child_)
            self.EducationOrgIdentificationCode.append(obj_)
        elif nodeName_ == 'NameOfInstitution':
            NameOfInstitution_ = child_.text
            NameOfInstitution_ = self.gds_validate_string(NameOfInstitution_, node, 'NameOfInstitution')
            self.NameOfInstitution = NameOfInstitution_
            self.validate_NameOfInstitution(self.NameOfInstitution)    # validate type NameOfInstitution
        elif nodeName_ == 'ShortNameOfInstitution':
            ShortNameOfInstitution_ = child_.text
            ShortNameOfInstitution_ = self.gds_validate_string(ShortNameOfInstitution_, node, 'ShortNameOfInstitution')
            self.ShortNameOfInstitution = ShortNameOfInstitution_
            self.validate_NameOfInstitution(self.ShortNameOfInstitution)    # validate type NameOfInstitution
        elif nodeName_ == 'OrganizationCategory':
            OrganizationCategory_ = child_.text
            OrganizationCategory_ = re_.sub(String_cleanup_pat_, " ", OrganizationCategory_).strip()
            OrganizationCategory_ = self.gds_validate_string(OrganizationCategory_, node, 'OrganizationCategory')
            self.OrganizationCategory = OrganizationCategory_
            self.validate_EducationOrganizationCategoryType(self.OrganizationCategory)    # validate type EducationOrganizationCategoryType
        elif nodeName_ == 'Address':
            obj_ = Address.factory()
            obj_.build(child_)
            self.Address.append(obj_)
        elif nodeName_ == 'Telephone':
            obj_ = InstitutionTelephone.factory()
            obj_.build(child_)
            self.Telephone.append(obj_)
        elif nodeName_ == 'WebSite':
            WebSite_ = child_.text
            WebSite_ = self.gds_validate_string(WebSite_, node, 'WebSite')
            self.WebSite = WebSite_
            self.validate_WebSite(self.WebSite)    # validate type WebSite
        elif nodeName_ == 'OperationalStatus':
            OperationalStatus_ = child_.text
            OperationalStatus_ = re_.sub(String_cleanup_pat_, " ", OperationalStatus_).strip()
            OperationalStatus_ = self.gds_validate_string(OperationalStatus_, node, 'OperationalStatus')
            self.OperationalStatus = OperationalStatus_
            self.validate_OperationalStatusType(self.OperationalStatus)    # validate type OperationalStatusType
        elif nodeName_ == 'AccountabilityRatings':
            obj_ = AccountabilityRating.factory()
            obj_.build(child_)
            self.AccountabilityRatings.append(obj_)
        elif nodeName_ == 'ProgramReference':
            obj_ = ProgramReferenceType.factory()
            obj_.build(child_)
            self.ProgramReference.append(obj_)
        elif nodeName_ == 'EducationOrganizationPeerReference':
            obj_ = EducationalOrgReferenceType.factory()
            obj_.build(child_)
            self.EducationOrganizationPeerReference.append(obj_)
        super(EducationOrganization, self).buildChildren(child_, node, nodeName_, True)
# end class EducationOrganization


class DisciplineIncident(ComplexObjectType):
    """This event entity represents an occurrence of an infraction ranging
    from a minor problem behavior that disrupts the orderly
    functioning of a school or classroom (such as tardiness) to a
    criminal act that results in the involvement of a law
    enforcement official (such as robbery). A single event (e.g., a
    fight) is one incident regardless of how many perpetrators or
    victims are involved. Discipline incidents are events classified
    as warranting discipline action."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, IncidentIdentifier=None, IncidentDate=None, IncidentTime=None, IncidentLocation=None, ReporterDescription=None, ReporterName=None, IncidentBehaviors=None, SecondaryIncidentBehaviors=None, Weapons=None, ReportedToLawEnforcement=None, CaseNumber=None, SchoolReference=None, StaffReference=None, DisciplineActionReference=None):
        super(DisciplineIncident, self).__init__(id, )
        self.IncidentIdentifier = IncidentIdentifier
        self.IncidentDate = IncidentDate
        self.IncidentTime = IncidentTime
        self.IncidentLocation = IncidentLocation
        self.ReporterDescription = ReporterDescription
        self.ReporterName = ReporterName
        if IncidentBehaviors is None:
            self.IncidentBehaviors = []
        else:
            self.IncidentBehaviors = IncidentBehaviors
        if SecondaryIncidentBehaviors is None:
            self.SecondaryIncidentBehaviors = []
        else:
            self.SecondaryIncidentBehaviors = SecondaryIncidentBehaviors
        self.Weapons = Weapons
        self.ReportedToLawEnforcement = ReportedToLawEnforcement
        self.CaseNumber = CaseNumber
        self.SchoolReference = SchoolReference
        self.StaffReference = StaffReference
        if DisciplineActionReference is None:
            self.DisciplineActionReference = []
        else:
            self.DisciplineActionReference = DisciplineActionReference
    def factory(*args_, **kwargs_):
        if DisciplineIncident.subclass:
            return DisciplineIncident.subclass(*args_, **kwargs_)
        else:
            return DisciplineIncident(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IncidentIdentifier(self): return self.IncidentIdentifier
    def set_IncidentIdentifier(self, IncidentIdentifier): self.IncidentIdentifier = IncidentIdentifier
    def validate_IncidentIdentifier(self, value):
        # Validate type IncidentIdentifier, a restriction on xs:string.
        pass
    def get_IncidentDate(self): return self.IncidentDate
    def set_IncidentDate(self, IncidentDate): self.IncidentDate = IncidentDate
    def get_IncidentTime(self): return self.IncidentTime
    def set_IncidentTime(self, IncidentTime): self.IncidentTime = IncidentTime
    def get_IncidentLocation(self): return self.IncidentLocation
    def set_IncidentLocation(self, IncidentLocation): self.IncidentLocation = IncidentLocation
    def validate_IncidentLocationType(self, value):
        # Validate type IncidentLocationType, a restriction on xs:token.
        pass
    def get_ReporterDescription(self): return self.ReporterDescription
    def set_ReporterDescription(self, ReporterDescription): self.ReporterDescription = ReporterDescription
    def validate_ReporterDescriptionType(self, value):
        # Validate type ReporterDescriptionType, a restriction on xs:token.
        pass
    def get_ReporterName(self): return self.ReporterName
    def set_ReporterName(self, ReporterName): self.ReporterName = ReporterName
    def validate_ReporterName(self, value):
        # Validate type ReporterName, a restriction on xs:string.
        pass
    def get_IncidentBehaviors(self): return self.IncidentBehaviors
    def set_IncidentBehaviors(self, IncidentBehaviors): self.IncidentBehaviors = IncidentBehaviors
    def add_IncidentBehaviors(self, value): self.IncidentBehaviors.append(value)
    def insert_IncidentBehaviors(self, index, value): self.IncidentBehaviors[index] = value
    def get_SecondaryIncidentBehaviors(self): return self.SecondaryIncidentBehaviors
    def set_SecondaryIncidentBehaviors(self, SecondaryIncidentBehaviors): self.SecondaryIncidentBehaviors = SecondaryIncidentBehaviors
    def add_SecondaryIncidentBehaviors(self, value): self.SecondaryIncidentBehaviors.append(value)
    def insert_SecondaryIncidentBehaviors(self, index, value): self.SecondaryIncidentBehaviors[index] = value
    def get_Weapons(self): return self.Weapons
    def set_Weapons(self, Weapons): self.Weapons = Weapons
    def get_ReportedToLawEnforcement(self): return self.ReportedToLawEnforcement
    def set_ReportedToLawEnforcement(self, ReportedToLawEnforcement): self.ReportedToLawEnforcement = ReportedToLawEnforcement
    def get_CaseNumber(self): return self.CaseNumber
    def set_CaseNumber(self, CaseNumber): self.CaseNumber = CaseNumber
    def validate_CaseNumber(self, value):
        # Validate type CaseNumber, a restriction on xs:string.
        pass
    def get_SchoolReference(self): return self.SchoolReference
    def set_SchoolReference(self, SchoolReference): self.SchoolReference = SchoolReference
    def get_StaffReference(self): return self.StaffReference
    def set_StaffReference(self, StaffReference): self.StaffReference = StaffReference
    def get_DisciplineActionReference(self): return self.DisciplineActionReference
    def set_DisciplineActionReference(self, DisciplineActionReference): self.DisciplineActionReference = DisciplineActionReference
    def add_DisciplineActionReference(self, value): self.DisciplineActionReference.append(value)
    def insert_DisciplineActionReference(self, index, value): self.DisciplineActionReference[index] = value
    def export(self, outfile, level, namespace_='', name_='DisciplineIncident', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DisciplineIncident')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DisciplineIncident'):
        super(DisciplineIncident, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DisciplineIncident')
    def exportChildren(self, outfile, level, namespace_='', name_='DisciplineIncident', fromsubclass_=False):
        super(DisciplineIncident, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.IncidentIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('<%sIncidentIdentifier>%s</%sIncidentIdentifier>\n' % (namespace_, self.gds_format_string(quote_xml(self.IncidentIdentifier).encode(ExternalEncoding), input_name='IncidentIdentifier'), namespace_))
        if self.IncidentDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sIncidentDate>%s</%sIncidentDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.IncidentDate).encode(ExternalEncoding), input_name='IncidentDate'), namespace_))
        if self.IncidentTime:
            self.IncidentTime.export(outfile, level, namespace_, name_='IncidentTime', )
        if self.IncidentLocation is not None:
            showIndent(outfile, level)
            outfile.write('<%sIncidentLocation>%s</%sIncidentLocation>\n' % (namespace_, self.gds_format_string(quote_xml(self.IncidentLocation).encode(ExternalEncoding), input_name='IncidentLocation'), namespace_))
        if self.ReporterDescription is not None:
            showIndent(outfile, level)
            outfile.write('<%sReporterDescription>%s</%sReporterDescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.ReporterDescription).encode(ExternalEncoding), input_name='ReporterDescription'), namespace_))
        if self.ReporterName is not None:
            showIndent(outfile, level)
            outfile.write('<%sReporterName>%s</%sReporterName>\n' % (namespace_, self.gds_format_string(quote_xml(self.ReporterName).encode(ExternalEncoding), input_name='ReporterName'), namespace_))
        for IncidentBehaviors_ in self.IncidentBehaviors:
            IncidentBehaviors_.export(outfile, level, namespace_, name_='IncidentBehaviors')
        for SecondaryIncidentBehaviors_ in self.SecondaryIncidentBehaviors:
            SecondaryIncidentBehaviors_.export(outfile, level, namespace_, name_='SecondaryIncidentBehaviors')
        if self.Weapons:
            self.Weapons.export(outfile, level, namespace_, name_='Weapons')
        if self.ReportedToLawEnforcement is not None:
            showIndent(outfile, level)
            outfile.write('<%sReportedToLawEnforcement>%s</%sReportedToLawEnforcement>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.ReportedToLawEnforcement)), input_name='ReportedToLawEnforcement'), namespace_))
        if self.CaseNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sCaseNumber>%s</%sCaseNumber>\n' % (namespace_, self.gds_format_string(quote_xml(self.CaseNumber).encode(ExternalEncoding), input_name='CaseNumber'), namespace_))
        if self.SchoolReference:
            self.SchoolReference.export(outfile, level, namespace_, name_='SchoolReference', )
        if self.StaffReference:
            self.StaffReference.export(outfile, level, namespace_, name_='StaffReference')
        for DisciplineActionReference_ in self.DisciplineActionReference:
            DisciplineActionReference_.export(outfile, level, namespace_, name_='DisciplineActionReference')
    def hasContent_(self):
        if (
            self.IncidentIdentifier is not None or
            self.IncidentDate is not None or
            self.IncidentTime is not None or
            self.IncidentLocation is not None or
            self.ReporterDescription is not None or
            self.ReporterName is not None or
            self.IncidentBehaviors or
            self.SecondaryIncidentBehaviors or
            self.Weapons is not None or
            self.ReportedToLawEnforcement is not None or
            self.CaseNumber is not None or
            self.SchoolReference is not None or
            self.StaffReference is not None or
            self.DisciplineActionReference or
            super(DisciplineIncident, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DisciplineIncident'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DisciplineIncident, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DisciplineIncident, self).exportLiteralChildren(outfile, level, name_)
        if self.IncidentIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('IncidentIdentifier=%s,\n' % quote_python(self.IncidentIdentifier).encode(ExternalEncoding))
        if self.IncidentDate is not None:
            showIndent(outfile, level)
            outfile.write('IncidentDate=%s,\n' % quote_python(self.IncidentDate).encode(ExternalEncoding))
        if self.IncidentTime is not None:
            showIndent(outfile, level)
            outfile.write('IncidentTime=model_.xs_time(\n')
            self.IncidentTime.exportLiteral(outfile, level, name_='IncidentTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IncidentLocation is not None:
            showIndent(outfile, level)
            outfile.write('IncidentLocation=%s,\n' % quote_python(self.IncidentLocation).encode(ExternalEncoding))
        if self.ReporterDescription is not None:
            showIndent(outfile, level)
            outfile.write('ReporterDescription=%s,\n' % quote_python(self.ReporterDescription).encode(ExternalEncoding))
        if self.ReporterName is not None:
            showIndent(outfile, level)
            outfile.write('ReporterName=%s,\n' % quote_python(self.ReporterName).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('IncidentBehaviors=[\n')
        level += 1
        for IncidentBehaviors_ in self.IncidentBehaviors:
            showIndent(outfile, level)
            outfile.write('model_.IncidentBehavior(\n')
            IncidentBehaviors_.exportLiteral(outfile, level, name_='IncidentBehavior')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SecondaryIncidentBehaviors=[\n')
        level += 1
        for SecondaryIncidentBehaviors_ in self.SecondaryIncidentBehaviors:
            showIndent(outfile, level)
            outfile.write('model_.SecondaryIncidentBehavior(\n')
            SecondaryIncidentBehaviors_.exportLiteral(outfile, level, name_='SecondaryIncidentBehavior')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Weapons is not None:
            showIndent(outfile, level)
            outfile.write('Weapons=model_.WeaponsType(\n')
            self.Weapons.exportLiteral(outfile, level, name_='Weapons')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ReportedToLawEnforcement is not None:
            showIndent(outfile, level)
            outfile.write('ReportedToLawEnforcement=%s,\n' % self.ReportedToLawEnforcement)
        if self.CaseNumber is not None:
            showIndent(outfile, level)
            outfile.write('CaseNumber=%s,\n' % quote_python(self.CaseNumber).encode(ExternalEncoding))
        if self.SchoolReference is not None:
            showIndent(outfile, level)
            outfile.write('SchoolReference=model_.EducationalOrgReferenceType(\n')
            self.SchoolReference.exportLiteral(outfile, level, name_='SchoolReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.StaffReference is not None:
            showIndent(outfile, level)
            outfile.write('StaffReference=model_.StaffReferenceType(\n')
            self.StaffReference.exportLiteral(outfile, level, name_='StaffReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('DisciplineActionReference=[\n')
        level += 1
        for DisciplineActionReference_ in self.DisciplineActionReference:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            DisciplineActionReference_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DisciplineIncident, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IncidentIdentifier':
            IncidentIdentifier_ = child_.text
            IncidentIdentifier_ = self.gds_validate_string(IncidentIdentifier_, node, 'IncidentIdentifier')
            self.IncidentIdentifier = IncidentIdentifier_
            self.validate_IncidentIdentifier(self.IncidentIdentifier)    # validate type IncidentIdentifier
        elif nodeName_ == 'IncidentDate':
            IncidentDate_ = child_.text
            IncidentDate_ = self.gds_validate_string(IncidentDate_, node, 'IncidentDate')
            self.IncidentDate = IncidentDate_
        elif nodeName_ == 'IncidentTime':
            obj_ = xs_time.factory()
            obj_.build(child_)
            self.set_IncidentTime(obj_)
        elif nodeName_ == 'IncidentLocation':
            IncidentLocation_ = child_.text
            IncidentLocation_ = re_.sub(String_cleanup_pat_, " ", IncidentLocation_).strip()
            IncidentLocation_ = self.gds_validate_string(IncidentLocation_, node, 'IncidentLocation')
            self.IncidentLocation = IncidentLocation_
            self.validate_IncidentLocationType(self.IncidentLocation)    # validate type IncidentLocationType
        elif nodeName_ == 'ReporterDescription':
            ReporterDescription_ = child_.text
            ReporterDescription_ = re_.sub(String_cleanup_pat_, " ", ReporterDescription_).strip()
            ReporterDescription_ = self.gds_validate_string(ReporterDescription_, node, 'ReporterDescription')
            self.ReporterDescription = ReporterDescription_
            self.validate_ReporterDescriptionType(self.ReporterDescription)    # validate type ReporterDescriptionType
        elif nodeName_ == 'ReporterName':
            ReporterName_ = child_.text
            ReporterName_ = self.gds_validate_string(ReporterName_, node, 'ReporterName')
            self.ReporterName = ReporterName_
            self.validate_ReporterName(self.ReporterName)    # validate type ReporterName
        elif nodeName_ == 'IncidentBehaviors':
            obj_ = IncidentBehavior.factory()
            obj_.build(child_)
            self.IncidentBehaviors.append(obj_)
        elif nodeName_ == 'SecondaryIncidentBehaviors':
            obj_ = SecondaryIncidentBehavior.factory()
            obj_.build(child_)
            self.SecondaryIncidentBehaviors.append(obj_)
        elif nodeName_ == 'Weapons':
            obj_ = WeaponsType.factory()
            obj_.build(child_)
            self.set_Weapons(obj_)
        elif nodeName_ == 'ReportedToLawEnforcement':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ReportedToLawEnforcement')
            self.ReportedToLawEnforcement = ival_
        elif nodeName_ == 'CaseNumber':
            CaseNumber_ = child_.text
            CaseNumber_ = self.gds_validate_string(CaseNumber_, node, 'CaseNumber')
            self.CaseNumber = CaseNumber_
            self.validate_CaseNumber(self.CaseNumber)    # validate type CaseNumber
        elif nodeName_ == 'SchoolReference':
            obj_ = EducationalOrgReferenceType.factory()
            obj_.build(child_)
            self.set_SchoolReference(obj_)
        elif nodeName_ == 'StaffReference':
            obj_ = StaffReferenceType.factory()
            obj_.build(child_)
            self.set_StaffReference(obj_)
        elif nodeName_ == 'DisciplineActionReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.DisciplineActionReference.append(obj_)
        super(DisciplineIncident, self).buildChildren(child_, node, nodeName_, True)
# end class DisciplineIncident


class DisciplineAction(ComplexObjectType):
    """This event entity represents actions taken by an education
    organization after a disruptive event that is recorded as a
    discipline incident."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, DisciplineActionIdentifier=None, DisciplineAction=None, DisciplineDate=None, DisciplineActionLength=None, StudentReference=None, StaffReference=None, ResponsibilitySchoolReference=None, AssignmentSchoolReference=None):
        super(DisciplineAction, self).__init__(id, )
        self.DisciplineActionIdentifier = DisciplineActionIdentifier
        self.DisciplineAction = DisciplineAction
        self.DisciplineDate = DisciplineDate
        self.DisciplineActionLength = DisciplineActionLength
        if StudentReference is None:
            self.StudentReference = []
        else:
            self.StudentReference = StudentReference
        if StaffReference is None:
            self.StaffReference = []
        else:
            self.StaffReference = StaffReference
        self.ResponsibilitySchoolReference = ResponsibilitySchoolReference
        self.AssignmentSchoolReference = AssignmentSchoolReference
    def factory(*args_, **kwargs_):
        if DisciplineAction.subclass:
            return DisciplineAction.subclass(*args_, **kwargs_)
        else:
            return DisciplineAction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DisciplineActionIdentifier(self): return self.DisciplineActionIdentifier
    def set_DisciplineActionIdentifier(self, DisciplineActionIdentifier): self.DisciplineActionIdentifier = DisciplineActionIdentifier
    def validate_DisciplineActionIdentifier(self, value):
        # Validate type DisciplineActionIdentifier, a restriction on xs:string.
        pass
    def get_DisciplineAction(self): return self.DisciplineAction
    def set_DisciplineAction(self, DisciplineAction): self.DisciplineAction = DisciplineAction
    def validate_DisciplineActionType(self, value):
        # Validate type DisciplineActionType, a restriction on xs:token.
        pass
    def get_DisciplineDate(self): return self.DisciplineDate
    def set_DisciplineDate(self, DisciplineDate): self.DisciplineDate = DisciplineDate
    def get_DisciplineActionLength(self): return self.DisciplineActionLength
    def set_DisciplineActionLength(self, DisciplineActionLength): self.DisciplineActionLength = DisciplineActionLength
    def get_StudentReference(self): return self.StudentReference
    def set_StudentReference(self, StudentReference): self.StudentReference = StudentReference
    def add_StudentReference(self, value): self.StudentReference.append(value)
    def insert_StudentReference(self, index, value): self.StudentReference[index] = value
    def get_StaffReference(self): return self.StaffReference
    def set_StaffReference(self, StaffReference): self.StaffReference = StaffReference
    def add_StaffReference(self, value): self.StaffReference.append(value)
    def insert_StaffReference(self, index, value): self.StaffReference[index] = value
    def get_ResponsibilitySchoolReference(self): return self.ResponsibilitySchoolReference
    def set_ResponsibilitySchoolReference(self, ResponsibilitySchoolReference): self.ResponsibilitySchoolReference = ResponsibilitySchoolReference
    def get_AssignmentSchoolReference(self): return self.AssignmentSchoolReference
    def set_AssignmentSchoolReference(self, AssignmentSchoolReference): self.AssignmentSchoolReference = AssignmentSchoolReference
    def export(self, outfile, level, namespace_='', name_='DisciplineAction', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DisciplineAction')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DisciplineAction'):
        super(DisciplineAction, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DisciplineAction')
    def exportChildren(self, outfile, level, namespace_='', name_='DisciplineAction', fromsubclass_=False):
        super(DisciplineAction, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.DisciplineActionIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('<%sDisciplineActionIdentifier>%s</%sDisciplineActionIdentifier>\n' % (namespace_, self.gds_format_string(quote_xml(self.DisciplineActionIdentifier).encode(ExternalEncoding), input_name='DisciplineActionIdentifier'), namespace_))
        if self.DisciplineAction is not None:
            showIndent(outfile, level)
            outfile.write('<%sDisciplineAction>%s</%sDisciplineAction>\n' % (namespace_, self.gds_format_string(quote_xml(self.DisciplineAction).encode(ExternalEncoding), input_name='DisciplineAction'), namespace_))
        if self.DisciplineDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sDisciplineDate>%s</%sDisciplineDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.DisciplineDate).encode(ExternalEncoding), input_name='DisciplineDate'), namespace_))
        if self.DisciplineActionLength is not None:
            showIndent(outfile, level)
            outfile.write('<%sDisciplineActionLength>%s</%sDisciplineActionLength>\n' % (namespace_, self.gds_format_integer(self.DisciplineActionLength, input_name='DisciplineActionLength'), namespace_))
        for StudentReference_ in self.StudentReference:
            StudentReference_.export(outfile, level, namespace_, name_='StudentReference')
        for StaffReference_ in self.StaffReference:
            StaffReference_.export(outfile, level, namespace_, name_='StaffReference')
        if self.ResponsibilitySchoolReference:
            self.ResponsibilitySchoolReference.export(outfile, level, namespace_, name_='ResponsibilitySchoolReference', )
        if self.AssignmentSchoolReference:
            self.AssignmentSchoolReference.export(outfile, level, namespace_, name_='AssignmentSchoolReference')
    def hasContent_(self):
        if (
            self.DisciplineActionIdentifier is not None or
            self.DisciplineAction is not None or
            self.DisciplineDate is not None or
            self.DisciplineActionLength is not None or
            self.StudentReference or
            self.StaffReference or
            self.ResponsibilitySchoolReference is not None or
            self.AssignmentSchoolReference is not None or
            super(DisciplineAction, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DisciplineAction'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DisciplineAction, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DisciplineAction, self).exportLiteralChildren(outfile, level, name_)
        if self.DisciplineActionIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('DisciplineActionIdentifier=%s,\n' % quote_python(self.DisciplineActionIdentifier).encode(ExternalEncoding))
        if self.DisciplineAction is not None:
            showIndent(outfile, level)
            outfile.write('DisciplineAction=%s,\n' % quote_python(self.DisciplineAction).encode(ExternalEncoding))
        if self.DisciplineDate is not None:
            showIndent(outfile, level)
            outfile.write('DisciplineDate=%s,\n' % quote_python(self.DisciplineDate).encode(ExternalEncoding))
        if self.DisciplineActionLength is not None:
            showIndent(outfile, level)
            outfile.write('DisciplineActionLength=%d,\n' % self.DisciplineActionLength)
        showIndent(outfile, level)
        outfile.write('StudentReference=[\n')
        level += 1
        for StudentReference_ in self.StudentReference:
            showIndent(outfile, level)
            outfile.write('model_.StudentReferenceType(\n')
            StudentReference_.exportLiteral(outfile, level, name_='StudentReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('StaffReference=[\n')
        level += 1
        for StaffReference_ in self.StaffReference:
            showIndent(outfile, level)
            outfile.write('model_.StaffReferenceType(\n')
            StaffReference_.exportLiteral(outfile, level, name_='StaffReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ResponsibilitySchoolReference is not None:
            showIndent(outfile, level)
            outfile.write('ResponsibilitySchoolReference=model_.EducationalOrgReferenceType(\n')
            self.ResponsibilitySchoolReference.exportLiteral(outfile, level, name_='ResponsibilitySchoolReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AssignmentSchoolReference is not None:
            showIndent(outfile, level)
            outfile.write('AssignmentSchoolReference=model_.EducationalOrgReferenceType(\n')
            self.AssignmentSchoolReference.exportLiteral(outfile, level, name_='AssignmentSchoolReference')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DisciplineAction, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DisciplineActionIdentifier':
            DisciplineActionIdentifier_ = child_.text
            DisciplineActionIdentifier_ = self.gds_validate_string(DisciplineActionIdentifier_, node, 'DisciplineActionIdentifier')
            self.DisciplineActionIdentifier = DisciplineActionIdentifier_
            self.validate_DisciplineActionIdentifier(self.DisciplineActionIdentifier)    # validate type DisciplineActionIdentifier
        elif nodeName_ == 'DisciplineAction':
            DisciplineAction_ = child_.text
            DisciplineAction_ = re_.sub(String_cleanup_pat_, " ", DisciplineAction_).strip()
            DisciplineAction_ = self.gds_validate_string(DisciplineAction_, node, 'DisciplineAction')
            self.DisciplineAction = DisciplineAction_
            self.validate_DisciplineActionType(self.DisciplineAction)    # validate type DisciplineActionType
        elif nodeName_ == 'DisciplineDate':
            DisciplineDate_ = child_.text
            DisciplineDate_ = self.gds_validate_string(DisciplineDate_, node, 'DisciplineDate')
            self.DisciplineDate = DisciplineDate_
        elif nodeName_ == 'DisciplineActionLength':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DisciplineActionLength')
            self.DisciplineActionLength = ival_
        elif nodeName_ == 'StudentReference':
            obj_ = StudentReferenceType.factory()
            obj_.build(child_)
            self.StudentReference.append(obj_)
        elif nodeName_ == 'StaffReference':
            obj_ = StaffReferenceType.factory()
            obj_.build(child_)
            self.StaffReference.append(obj_)
        elif nodeName_ == 'ResponsibilitySchoolReference':
            obj_ = EducationalOrgReferenceType.factory()
            obj_.build(child_)
            self.set_ResponsibilitySchoolReference(obj_)
        elif nodeName_ == 'AssignmentSchoolReference':
            obj_ = EducationalOrgReferenceType.factory()
            obj_.build(child_)
            self.set_AssignmentSchoolReference(obj_)
        super(DisciplineAction, self).buildChildren(child_, node, nodeName_, True)
# end class DisciplineAction


class Diploma(ComplexObjectType):
    """This educational entity represents the conferring or certification
    by an educational organization that the student has successfully
    completed a particular course of study. It represents the
    electronic version of its physical document counterpart."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, DiplomaAwardDate=None, DiplomaLevel=None, DiplomaType=None, CTECompleter=None, AcademicHonors=None, Recognitions=None, SchoolReference=None):
        super(Diploma, self).__init__(id, )
        self.DiplomaAwardDate = DiplomaAwardDate
        self.DiplomaLevel = DiplomaLevel
        self.DiplomaType = DiplomaType
        self.CTECompleter = CTECompleter
        if AcademicHonors is None:
            self.AcademicHonors = []
        else:
            self.AcademicHonors = AcademicHonors
        if Recognitions is None:
            self.Recognitions = []
        else:
            self.Recognitions = Recognitions
        self.SchoolReference = SchoolReference
    def factory(*args_, **kwargs_):
        if Diploma.subclass:
            return Diploma.subclass(*args_, **kwargs_)
        else:
            return Diploma(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DiplomaAwardDate(self): return self.DiplomaAwardDate
    def set_DiplomaAwardDate(self, DiplomaAwardDate): self.DiplomaAwardDate = DiplomaAwardDate
    def get_DiplomaLevel(self): return self.DiplomaLevel
    def set_DiplomaLevel(self, DiplomaLevel): self.DiplomaLevel = DiplomaLevel
    def validate_DiplomaLevelType(self, value):
        # Validate type DiplomaLevelType, a restriction on xs:token.
        pass
    def get_DiplomaType(self): return self.DiplomaType
    def set_DiplomaType(self, DiplomaType): self.DiplomaType = DiplomaType
    def validate_DiplomaType(self, value):
        # Validate type DiplomaType, a restriction on xs:token.
        pass
    def get_CTECompleter(self): return self.CTECompleter
    def set_CTECompleter(self, CTECompleter): self.CTECompleter = CTECompleter
    def get_AcademicHonors(self): return self.AcademicHonors
    def set_AcademicHonors(self, AcademicHonors): self.AcademicHonors = AcademicHonors
    def add_AcademicHonors(self, value): self.AcademicHonors.append(value)
    def insert_AcademicHonors(self, index, value): self.AcademicHonors[index] = value
    def get_Recognitions(self): return self.Recognitions
    def set_Recognitions(self, Recognitions): self.Recognitions = Recognitions
    def add_Recognitions(self, value): self.Recognitions.append(value)
    def insert_Recognitions(self, index, value): self.Recognitions[index] = value
    def get_SchoolReference(self): return self.SchoolReference
    def set_SchoolReference(self, SchoolReference): self.SchoolReference = SchoolReference
    def export(self, outfile, level, namespace_='', name_='Diploma', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Diploma')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Diploma'):
        super(Diploma, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Diploma')
    def exportChildren(self, outfile, level, namespace_='', name_='Diploma', fromsubclass_=False):
        super(Diploma, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.DiplomaAwardDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sDiplomaAwardDate>%s</%sDiplomaAwardDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.DiplomaAwardDate).encode(ExternalEncoding), input_name='DiplomaAwardDate'), namespace_))
        if self.DiplomaLevel is not None:
            showIndent(outfile, level)
            outfile.write('<%sDiplomaLevel>%s</%sDiplomaLevel>\n' % (namespace_, self.gds_format_string(quote_xml(self.DiplomaLevel).encode(ExternalEncoding), input_name='DiplomaLevel'), namespace_))
        if self.DiplomaType is not None:
            showIndent(outfile, level)
            outfile.write('<%sDiplomaType>%s</%sDiplomaType>\n' % (namespace_, self.gds_format_string(quote_xml(self.DiplomaType).encode(ExternalEncoding), input_name='DiplomaType'), namespace_))
        if self.CTECompleter is not None:
            showIndent(outfile, level)
            outfile.write('<%sCTECompleter>%s</%sCTECompleter>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.CTECompleter)), input_name='CTECompleter'), namespace_))
        for AcademicHonors_ in self.AcademicHonors:
            AcademicHonors_.export(outfile, level, namespace_, name_='AcademicHonors')
        for Recognitions_ in self.Recognitions:
            Recognitions_.export(outfile, level, namespace_, name_='Recognitions')
        if self.SchoolReference:
            self.SchoolReference.export(outfile, level, namespace_, name_='SchoolReference', )
    def hasContent_(self):
        if (
            self.DiplomaAwardDate is not None or
            self.DiplomaLevel is not None or
            self.DiplomaType is not None or
            self.CTECompleter is not None or
            self.AcademicHonors or
            self.Recognitions or
            self.SchoolReference is not None or
            super(Diploma, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Diploma'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Diploma, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Diploma, self).exportLiteralChildren(outfile, level, name_)
        if self.DiplomaAwardDate is not None:
            showIndent(outfile, level)
            outfile.write('DiplomaAwardDate=%s,\n' % quote_python(self.DiplomaAwardDate).encode(ExternalEncoding))
        if self.DiplomaLevel is not None:
            showIndent(outfile, level)
            outfile.write('DiplomaLevel=%s,\n' % quote_python(self.DiplomaLevel).encode(ExternalEncoding))
        if self.DiplomaType is not None:
            showIndent(outfile, level)
            outfile.write('DiplomaType=%s,\n' % quote_python(self.DiplomaType).encode(ExternalEncoding))
        if self.CTECompleter is not None:
            showIndent(outfile, level)
            outfile.write('CTECompleter=%s,\n' % self.CTECompleter)
        showIndent(outfile, level)
        outfile.write('AcademicHonors=[\n')
        level += 1
        for AcademicHonors_ in self.AcademicHonors:
            showIndent(outfile, level)
            outfile.write('model_.AcademicHonor(\n')
            AcademicHonors_.exportLiteral(outfile, level, name_='AcademicHonor')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Recognitions=[\n')
        level += 1
        for Recognitions_ in self.Recognitions:
            showIndent(outfile, level)
            outfile.write('model_.Recognition(\n')
            Recognitions_.exportLiteral(outfile, level, name_='Recognition')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.SchoolReference is not None:
            showIndent(outfile, level)
            outfile.write('SchoolReference=model_.EducationalOrgReferenceType(\n')
            self.SchoolReference.exportLiteral(outfile, level, name_='SchoolReference')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Diploma, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DiplomaAwardDate':
            DiplomaAwardDate_ = child_.text
            DiplomaAwardDate_ = self.gds_validate_string(DiplomaAwardDate_, node, 'DiplomaAwardDate')
            self.DiplomaAwardDate = DiplomaAwardDate_
        elif nodeName_ == 'DiplomaLevel':
            DiplomaLevel_ = child_.text
            DiplomaLevel_ = re_.sub(String_cleanup_pat_, " ", DiplomaLevel_).strip()
            DiplomaLevel_ = self.gds_validate_string(DiplomaLevel_, node, 'DiplomaLevel')
            self.DiplomaLevel = DiplomaLevel_
            self.validate_DiplomaLevelType(self.DiplomaLevel)    # validate type DiplomaLevelType
        elif nodeName_ == 'DiplomaType':
            DiplomaType_ = child_.text
            DiplomaType_ = re_.sub(String_cleanup_pat_, " ", DiplomaType_).strip()
            DiplomaType_ = self.gds_validate_string(DiplomaType_, node, 'DiplomaType')
            self.DiplomaType = DiplomaType_
            self.validate_DiplomaType(self.DiplomaType)    # validate type DiplomaType
        elif nodeName_ == 'CTECompleter':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'CTECompleter')
            self.CTECompleter = ival_
        elif nodeName_ == 'AcademicHonors':
            obj_ = AcademicHonor.factory()
            obj_.build(child_)
            self.AcademicHonors.append(obj_)
        elif nodeName_ == 'Recognitions':
            obj_ = Recognition.factory()
            obj_.build(child_)
            self.Recognitions.append(obj_)
        elif nodeName_ == 'SchoolReference':
            obj_ = EducationalOrgReferenceType.factory()
            obj_.build(child_)
            self.set_SchoolReference(obj_)
        super(Diploma, self).buildChildren(child_, node, nodeName_, True)
# end class Diploma


class CourseTranscript(ComplexObjectType):
    """The final record of a student's performance in their courses."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, CourseAttemptResult=None, CreditsAttempted=None, CreditsEarned=None, AdditionalCreditsEarned=None, GradeLevelWhenTaken=None, MethodCreditEarned=None, FinalLetterGradeEarned=None, FinalNumericGradeEarned=None, CourseRepeatCode=None, CourseReference=None, EducationOrganizationReference=None, StudentAcademicRecordReference=None):
        super(CourseTranscript, self).__init__(id, )
        self.CourseAttemptResult = CourseAttemptResult
        self.CreditsAttempted = CreditsAttempted
        self.CreditsEarned = CreditsEarned
        if AdditionalCreditsEarned is None:
            self.AdditionalCreditsEarned = []
        else:
            self.AdditionalCreditsEarned = AdditionalCreditsEarned
        self.GradeLevelWhenTaken = GradeLevelWhenTaken
        self.MethodCreditEarned = MethodCreditEarned
        self.FinalLetterGradeEarned = FinalLetterGradeEarned
        self.FinalNumericGradeEarned = FinalNumericGradeEarned
        self.CourseRepeatCode = CourseRepeatCode
        self.CourseReference = CourseReference
        if EducationOrganizationReference is None:
            self.EducationOrganizationReference = []
        else:
            self.EducationOrganizationReference = EducationOrganizationReference
        self.StudentAcademicRecordReference = StudentAcademicRecordReference
    def factory(*args_, **kwargs_):
        if CourseTranscript.subclass:
            return CourseTranscript.subclass(*args_, **kwargs_)
        else:
            return CourseTranscript(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CourseAttemptResult(self): return self.CourseAttemptResult
    def set_CourseAttemptResult(self, CourseAttemptResult): self.CourseAttemptResult = CourseAttemptResult
    def validate_CourseAttemptResultType(self, value):
        # Validate type CourseAttemptResultType, a restriction on xs:token.
        pass
    def get_CreditsAttempted(self): return self.CreditsAttempted
    def set_CreditsAttempted(self, CreditsAttempted): self.CreditsAttempted = CreditsAttempted
    def get_CreditsEarned(self): return self.CreditsEarned
    def set_CreditsEarned(self, CreditsEarned): self.CreditsEarned = CreditsEarned
    def get_AdditionalCreditsEarned(self): return self.AdditionalCreditsEarned
    def set_AdditionalCreditsEarned(self, AdditionalCreditsEarned): self.AdditionalCreditsEarned = AdditionalCreditsEarned
    def add_AdditionalCreditsEarned(self, value): self.AdditionalCreditsEarned.append(value)
    def insert_AdditionalCreditsEarned(self, index, value): self.AdditionalCreditsEarned[index] = value
    def get_GradeLevelWhenTaken(self): return self.GradeLevelWhenTaken
    def set_GradeLevelWhenTaken(self, GradeLevelWhenTaken): self.GradeLevelWhenTaken = GradeLevelWhenTaken
    def validate_GradeLevelType(self, value):
        # Validate type GradeLevelType, a restriction on xs:token.
        pass
    def get_MethodCreditEarned(self): return self.MethodCreditEarned
    def set_MethodCreditEarned(self, MethodCreditEarned): self.MethodCreditEarned = MethodCreditEarned
    def validate_MethodCreditEarnedType(self, value):
        # Validate type MethodCreditEarnedType, a restriction on xs:token.
        pass
    def get_FinalLetterGradeEarned(self): return self.FinalLetterGradeEarned
    def set_FinalLetterGradeEarned(self, FinalLetterGradeEarned): self.FinalLetterGradeEarned = FinalLetterGradeEarned
    def get_FinalNumericGradeEarned(self): return self.FinalNumericGradeEarned
    def set_FinalNumericGradeEarned(self, FinalNumericGradeEarned): self.FinalNumericGradeEarned = FinalNumericGradeEarned
    def get_CourseRepeatCode(self): return self.CourseRepeatCode
    def set_CourseRepeatCode(self, CourseRepeatCode): self.CourseRepeatCode = CourseRepeatCode
    def validate_CourseRepeatCodeType(self, value):
        # Validate type CourseRepeatCodeType, a restriction on xs:token.
        pass
    def get_CourseReference(self): return self.CourseReference
    def set_CourseReference(self, CourseReference): self.CourseReference = CourseReference
    def get_EducationOrganizationReference(self): return self.EducationOrganizationReference
    def set_EducationOrganizationReference(self, EducationOrganizationReference): self.EducationOrganizationReference = EducationOrganizationReference
    def add_EducationOrganizationReference(self, value): self.EducationOrganizationReference.append(value)
    def insert_EducationOrganizationReference(self, index, value): self.EducationOrganizationReference[index] = value
    def get_StudentAcademicRecordReference(self): return self.StudentAcademicRecordReference
    def set_StudentAcademicRecordReference(self, StudentAcademicRecordReference): self.StudentAcademicRecordReference = StudentAcademicRecordReference
    def export(self, outfile, level, namespace_='', name_='CourseTranscript', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CourseTranscript')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CourseTranscript'):
        super(CourseTranscript, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CourseTranscript')
    def exportChildren(self, outfile, level, namespace_='', name_='CourseTranscript', fromsubclass_=False):
        super(CourseTranscript, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.CourseAttemptResult is not None:
            showIndent(outfile, level)
            outfile.write('<%sCourseAttemptResult>%s</%sCourseAttemptResult>\n' % (namespace_, self.gds_format_string(quote_xml(self.CourseAttemptResult).encode(ExternalEncoding), input_name='CourseAttemptResult'), namespace_))
        if self.CreditsAttempted:
            self.CreditsAttempted.export(outfile, level, namespace_, name_='CreditsAttempted')
        if self.CreditsEarned:
            self.CreditsEarned.export(outfile, level, namespace_, name_='CreditsEarned', )
        for AdditionalCreditsEarned_ in self.AdditionalCreditsEarned:
            AdditionalCreditsEarned_.export(outfile, level, namespace_, name_='AdditionalCreditsEarned')
        if self.GradeLevelWhenTaken is not None:
            showIndent(outfile, level)
            outfile.write('<%sGradeLevelWhenTaken>%s</%sGradeLevelWhenTaken>\n' % (namespace_, self.gds_format_string(quote_xml(self.GradeLevelWhenTaken).encode(ExternalEncoding), input_name='GradeLevelWhenTaken'), namespace_))
        if self.MethodCreditEarned is not None:
            showIndent(outfile, level)
            outfile.write('<%sMethodCreditEarned>%s</%sMethodCreditEarned>\n' % (namespace_, self.gds_format_string(quote_xml(self.MethodCreditEarned).encode(ExternalEncoding), input_name='MethodCreditEarned'), namespace_))
        if self.FinalLetterGradeEarned is not None:
            showIndent(outfile, level)
            outfile.write('<%sFinalLetterGradeEarned>%s</%sFinalLetterGradeEarned>\n' % (namespace_, self.gds_format_string(quote_xml(self.FinalLetterGradeEarned).encode(ExternalEncoding), input_name='FinalLetterGradeEarned'), namespace_))
        if self.FinalNumericGradeEarned is not None:
            showIndent(outfile, level)
            outfile.write('<%sFinalNumericGradeEarned>%s</%sFinalNumericGradeEarned>\n' % (namespace_, self.gds_format_integer(self.FinalNumericGradeEarned, input_name='FinalNumericGradeEarned'), namespace_))
        if self.CourseRepeatCode is not None:
            showIndent(outfile, level)
            outfile.write('<%sCourseRepeatCode>%s</%sCourseRepeatCode>\n' % (namespace_, self.gds_format_string(quote_xml(self.CourseRepeatCode).encode(ExternalEncoding), input_name='CourseRepeatCode'), namespace_))
        if self.CourseReference:
            self.CourseReference.export(outfile, level, namespace_, name_='CourseReference', )
        for EducationOrganizationReference_ in self.EducationOrganizationReference:
            EducationOrganizationReference_.export(outfile, level, namespace_, name_='EducationOrganizationReference')
        if self.StudentAcademicRecordReference:
            self.StudentAcademicRecordReference.export(outfile, level, namespace_, name_='StudentAcademicRecordReference', )
    def hasContent_(self):
        if (
            self.CourseAttemptResult is not None or
            self.CreditsAttempted is not None or
            self.CreditsEarned is not None or
            self.AdditionalCreditsEarned or
            self.GradeLevelWhenTaken is not None or
            self.MethodCreditEarned is not None or
            self.FinalLetterGradeEarned is not None or
            self.FinalNumericGradeEarned is not None or
            self.CourseRepeatCode is not None or
            self.CourseReference is not None or
            self.EducationOrganizationReference or
            self.StudentAcademicRecordReference is not None or
            super(CourseTranscript, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CourseTranscript'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CourseTranscript, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CourseTranscript, self).exportLiteralChildren(outfile, level, name_)
        if self.CourseAttemptResult is not None:
            showIndent(outfile, level)
            outfile.write('CourseAttemptResult=%s,\n' % quote_python(self.CourseAttemptResult).encode(ExternalEncoding))
        if self.CreditsAttempted is not None:
            showIndent(outfile, level)
            outfile.write('CreditsAttempted=model_.Credits(\n')
            self.CreditsAttempted.exportLiteral(outfile, level, name_='CreditsAttempted')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CreditsEarned is not None:
            showIndent(outfile, level)
            outfile.write('CreditsEarned=model_.Credits(\n')
            self.CreditsEarned.exportLiteral(outfile, level, name_='CreditsEarned')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('AdditionalCreditsEarned=[\n')
        level += 1
        for AdditionalCreditsEarned_ in self.AdditionalCreditsEarned:
            showIndent(outfile, level)
            outfile.write('model_.AdditionalCredits(\n')
            AdditionalCreditsEarned_.exportLiteral(outfile, level, name_='AdditionalCredits')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.GradeLevelWhenTaken is not None:
            showIndent(outfile, level)
            outfile.write('GradeLevelWhenTaken=%s,\n' % quote_python(self.GradeLevelWhenTaken).encode(ExternalEncoding))
        if self.MethodCreditEarned is not None:
            showIndent(outfile, level)
            outfile.write('MethodCreditEarned=%s,\n' % quote_python(self.MethodCreditEarned).encode(ExternalEncoding))
        if self.FinalLetterGradeEarned is not None:
            showIndent(outfile, level)
            outfile.write('FinalLetterGradeEarned=%s,\n' % quote_python(self.FinalLetterGradeEarned).encode(ExternalEncoding))
        if self.FinalNumericGradeEarned is not None:
            showIndent(outfile, level)
            outfile.write('FinalNumericGradeEarned=%d,\n' % self.FinalNumericGradeEarned)
        if self.CourseRepeatCode is not None:
            showIndent(outfile, level)
            outfile.write('CourseRepeatCode=%s,\n' % quote_python(self.CourseRepeatCode).encode(ExternalEncoding))
        if self.CourseReference is not None:
            showIndent(outfile, level)
            outfile.write('CourseReference=model_.CourseReferenceType(\n')
            self.CourseReference.exportLiteral(outfile, level, name_='CourseReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('EducationOrganizationReference=[\n')
        level += 1
        for EducationOrganizationReference_ in self.EducationOrganizationReference:
            showIndent(outfile, level)
            outfile.write('model_.EducationalOrgReferenceType(\n')
            EducationOrganizationReference_.exportLiteral(outfile, level, name_='EducationalOrgReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.StudentAcademicRecordReference is not None:
            showIndent(outfile, level)
            outfile.write('StudentAcademicRecordReference=model_.ReferenceType(\n')
            self.StudentAcademicRecordReference.exportLiteral(outfile, level, name_='StudentAcademicRecordReference')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(CourseTranscript, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CourseAttemptResult':
            CourseAttemptResult_ = child_.text
            CourseAttemptResult_ = re_.sub(String_cleanup_pat_, " ", CourseAttemptResult_).strip()
            CourseAttemptResult_ = self.gds_validate_string(CourseAttemptResult_, node, 'CourseAttemptResult')
            self.CourseAttemptResult = CourseAttemptResult_
            self.validate_CourseAttemptResultType(self.CourseAttemptResult)    # validate type CourseAttemptResultType
        elif nodeName_ == 'CreditsAttempted':
            obj_ = Credits.factory()
            obj_.build(child_)
            self.set_CreditsAttempted(obj_)
        elif nodeName_ == 'CreditsEarned':
            obj_ = Credits.factory()
            obj_.build(child_)
            self.set_CreditsEarned(obj_)
        elif nodeName_ == 'AdditionalCreditsEarned':
            obj_ = AdditionalCredits.factory()
            obj_.build(child_)
            self.AdditionalCreditsEarned.append(obj_)
        elif nodeName_ == 'GradeLevelWhenTaken':
            GradeLevelWhenTaken_ = child_.text
            GradeLevelWhenTaken_ = re_.sub(String_cleanup_pat_, " ", GradeLevelWhenTaken_).strip()
            GradeLevelWhenTaken_ = self.gds_validate_string(GradeLevelWhenTaken_, node, 'GradeLevelWhenTaken')
            self.GradeLevelWhenTaken = GradeLevelWhenTaken_
            self.validate_GradeLevelType(self.GradeLevelWhenTaken)    # validate type GradeLevelType
        elif nodeName_ == 'MethodCreditEarned':
            MethodCreditEarned_ = child_.text
            MethodCreditEarned_ = re_.sub(String_cleanup_pat_, " ", MethodCreditEarned_).strip()
            MethodCreditEarned_ = self.gds_validate_string(MethodCreditEarned_, node, 'MethodCreditEarned')
            self.MethodCreditEarned = MethodCreditEarned_
            self.validate_MethodCreditEarnedType(self.MethodCreditEarned)    # validate type MethodCreditEarnedType
        elif nodeName_ == 'FinalLetterGradeEarned':
            FinalLetterGradeEarned_ = child_.text
            FinalLetterGradeEarned_ = self.gds_validate_string(FinalLetterGradeEarned_, node, 'FinalLetterGradeEarned')
            self.FinalLetterGradeEarned = FinalLetterGradeEarned_
        elif nodeName_ == 'FinalNumericGradeEarned':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'FinalNumericGradeEarned')
            self.FinalNumericGradeEarned = ival_
        elif nodeName_ == 'CourseRepeatCode':
            CourseRepeatCode_ = child_.text
            CourseRepeatCode_ = re_.sub(String_cleanup_pat_, " ", CourseRepeatCode_).strip()
            CourseRepeatCode_ = self.gds_validate_string(CourseRepeatCode_, node, 'CourseRepeatCode')
            self.CourseRepeatCode = CourseRepeatCode_
            self.validate_CourseRepeatCodeType(self.CourseRepeatCode)    # validate type CourseRepeatCodeType
        elif nodeName_ == 'CourseReference':
            obj_ = CourseReferenceType.factory()
            obj_.build(child_)
            self.set_CourseReference(obj_)
        elif nodeName_ == 'EducationOrganizationReference':
            obj_ = EducationalOrgReferenceType.factory()
            obj_.build(child_)
            self.EducationOrganizationReference.append(obj_)
        elif nodeName_ == 'StudentAcademicRecordReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_StudentAcademicRecordReference(obj_)
        super(CourseTranscript, self).buildChildren(child_, node, nodeName_, True)
# end class CourseTranscript


class Course(ComplexObjectType):
    """This educational entity represents the organization of subject
    matter and related learning experiences provided for the
    instruction of students on a regular or systematic basis."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, CourseTitle=None, NumberOfParts=None, LocalCourseCode=None, CourseCode=None, CourseLevel=None, CourseLevelCharacteristics=None, GradesOffered=None, SubjectArea=None, CourseDescription=None, DateCourseAdopted=None, SchoolYear=None, HighSchoolCourseRequirement=None, CourseGPAApplicability=None, EducationOrganizationReference=None, StudentExpectationReference=None):
        super(Course, self).__init__(id, )
        self.CourseTitle = CourseTitle
        self.NumberOfParts = NumberOfParts
        self.LocalCourseCode = LocalCourseCode
        if CourseCode is None:
            self.CourseCode = []
        else:
            self.CourseCode = CourseCode
        self.CourseLevel = CourseLevel
        self.CourseLevelCharacteristics = CourseLevelCharacteristics
        self.GradesOffered = GradesOffered
        self.SubjectArea = SubjectArea
        self.CourseDescription = CourseDescription
        self.DateCourseAdopted = DateCourseAdopted
        self.SchoolYear = SchoolYear
        self.HighSchoolCourseRequirement = HighSchoolCourseRequirement
        self.CourseGPAApplicability = CourseGPAApplicability
        self.EducationOrganizationReference = EducationOrganizationReference
        if StudentExpectationReference is None:
            self.StudentExpectationReference = []
        else:
            self.StudentExpectationReference = StudentExpectationReference
    def factory(*args_, **kwargs_):
        if Course.subclass:
            return Course.subclass(*args_, **kwargs_)
        else:
            return Course(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CourseTitle(self): return self.CourseTitle
    def set_CourseTitle(self, CourseTitle): self.CourseTitle = CourseTitle
    def validate_CourseTitle(self, value):
        # Validate type CourseTitle, a restriction on xs:string.
        pass
    def get_NumberOfParts(self): return self.NumberOfParts
    def set_NumberOfParts(self, NumberOfParts): self.NumberOfParts = NumberOfParts
    def get_LocalCourseCode(self): return self.LocalCourseCode
    def set_LocalCourseCode(self, LocalCourseCode): self.LocalCourseCode = LocalCourseCode
    def validate_LocalCourseCode(self, value):
        # Validate type LocalCourseCode, a restriction on xs:string.
        pass
    def get_CourseCode(self): return self.CourseCode
    def set_CourseCode(self, CourseCode): self.CourseCode = CourseCode
    def add_CourseCode(self, value): self.CourseCode.append(value)
    def insert_CourseCode(self, index, value): self.CourseCode[index] = value
    def get_CourseLevel(self): return self.CourseLevel
    def set_CourseLevel(self, CourseLevel): self.CourseLevel = CourseLevel
    def validate_CourseLevelType(self, value):
        # Validate type CourseLevelType, a restriction on xs:token.
        pass
    def get_CourseLevelCharacteristics(self): return self.CourseLevelCharacteristics
    def set_CourseLevelCharacteristics(self, CourseLevelCharacteristics): self.CourseLevelCharacteristics = CourseLevelCharacteristics
    def get_GradesOffered(self): return self.GradesOffered
    def set_GradesOffered(self, GradesOffered): self.GradesOffered = GradesOffered
    def get_SubjectArea(self): return self.SubjectArea
    def set_SubjectArea(self, SubjectArea): self.SubjectArea = SubjectArea
    def validate_SubjectAreaType(self, value):
        # Validate type SubjectAreaType, a restriction on xs:token.
        pass
    def get_CourseDescription(self): return self.CourseDescription
    def set_CourseDescription(self, CourseDescription): self.CourseDescription = CourseDescription
    def validate_Description(self, value):
        # Validate type Description, a restriction on xs:string.
        pass
    def get_DateCourseAdopted(self): return self.DateCourseAdopted
    def set_DateCourseAdopted(self, DateCourseAdopted): self.DateCourseAdopted = DateCourseAdopted
    def get_SchoolYear(self): return self.SchoolYear
    def set_SchoolYear(self, SchoolYear): self.SchoolYear = SchoolYear
    def validate_SchoolYearType(self, value):
        # Validate type SchoolYearType, a restriction on xs:token.
        pass
    def get_HighSchoolCourseRequirement(self): return self.HighSchoolCourseRequirement
    def set_HighSchoolCourseRequirement(self, HighSchoolCourseRequirement): self.HighSchoolCourseRequirement = HighSchoolCourseRequirement
    def get_CourseGPAApplicability(self): return self.CourseGPAApplicability
    def set_CourseGPAApplicability(self, CourseGPAApplicability): self.CourseGPAApplicability = CourseGPAApplicability
    def validate_CourseGPAApplicabilityType(self, value):
        # Validate type CourseGPAApplicabilityType, a restriction on xs:token.
        pass
    def get_EducationOrganizationReference(self): return self.EducationOrganizationReference
    def set_EducationOrganizationReference(self, EducationOrganizationReference): self.EducationOrganizationReference = EducationOrganizationReference
    def get_StudentExpectationReference(self): return self.StudentExpectationReference
    def set_StudentExpectationReference(self, StudentExpectationReference): self.StudentExpectationReference = StudentExpectationReference
    def add_StudentExpectationReference(self, value): self.StudentExpectationReference.append(value)
    def insert_StudentExpectationReference(self, index, value): self.StudentExpectationReference[index] = value
    def export(self, outfile, level, namespace_='', name_='Course', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Course')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Course'):
        super(Course, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Course')
    def exportChildren(self, outfile, level, namespace_='', name_='Course', fromsubclass_=False):
        super(Course, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.CourseTitle is not None:
            showIndent(outfile, level)
            outfile.write('<%sCourseTitle>%s</%sCourseTitle>\n' % (namespace_, self.gds_format_string(quote_xml(self.CourseTitle).encode(ExternalEncoding), input_name='CourseTitle'), namespace_))
        if self.NumberOfParts is not None:
            showIndent(outfile, level)
            outfile.write('<%sNumberOfParts>%s</%sNumberOfParts>\n' % (namespace_, self.gds_format_integer(self.NumberOfParts, input_name='NumberOfParts'), namespace_))
        if self.LocalCourseCode is not None:
            showIndent(outfile, level)
            outfile.write('<%sLocalCourseCode>%s</%sLocalCourseCode>\n' % (namespace_, self.gds_format_string(quote_xml(self.LocalCourseCode).encode(ExternalEncoding), input_name='LocalCourseCode'), namespace_))
        for CourseCode_ in self.CourseCode:
            CourseCode_.export(outfile, level, namespace_, name_='CourseCode')
        if self.CourseLevel is not None:
            showIndent(outfile, level)
            outfile.write('<%sCourseLevel>%s</%sCourseLevel>\n' % (namespace_, self.gds_format_string(quote_xml(self.CourseLevel).encode(ExternalEncoding), input_name='CourseLevel'), namespace_))
        if self.CourseLevelCharacteristics:
            self.CourseLevelCharacteristics.export(outfile, level, namespace_, name_='CourseLevelCharacteristics')
        if self.GradesOffered:
            self.GradesOffered.export(outfile, level, namespace_, name_='GradesOffered')
        if self.SubjectArea is not None:
            showIndent(outfile, level)
            outfile.write('<%sSubjectArea>%s</%sSubjectArea>\n' % (namespace_, self.gds_format_string(quote_xml(self.SubjectArea).encode(ExternalEncoding), input_name='SubjectArea'), namespace_))
        if self.CourseDescription is not None:
            showIndent(outfile, level)
            outfile.write('<%sCourseDescription>%s</%sCourseDescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.CourseDescription).encode(ExternalEncoding), input_name='CourseDescription'), namespace_))
        if self.DateCourseAdopted is not None:
            showIndent(outfile, level)
            outfile.write('<%sDateCourseAdopted>%s</%sDateCourseAdopted>\n' % (namespace_, self.gds_format_string(quote_xml(self.DateCourseAdopted).encode(ExternalEncoding), input_name='DateCourseAdopted'), namespace_))
        if self.SchoolYear is not None:
            showIndent(outfile, level)
            outfile.write('<%sSchoolYear>%s</%sSchoolYear>\n' % (namespace_, self.gds_format_string(quote_xml(self.SchoolYear).encode(ExternalEncoding), input_name='SchoolYear'), namespace_))
        if self.HighSchoolCourseRequirement is not None:
            showIndent(outfile, level)
            outfile.write('<%sHighSchoolCourseRequirement>%s</%sHighSchoolCourseRequirement>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.HighSchoolCourseRequirement)), input_name='HighSchoolCourseRequirement'), namespace_))
        if self.CourseGPAApplicability is not None:
            showIndent(outfile, level)
            outfile.write('<%sCourseGPAApplicability>%s</%sCourseGPAApplicability>\n' % (namespace_, self.gds_format_string(quote_xml(self.CourseGPAApplicability).encode(ExternalEncoding), input_name='CourseGPAApplicability'), namespace_))
        if self.EducationOrganizationReference:
            self.EducationOrganizationReference.export(outfile, level, namespace_, name_='EducationOrganizationReference', )
        for StudentExpectationReference_ in self.StudentExpectationReference:
            StudentExpectationReference_.export(outfile, level, namespace_, name_='StudentExpectationReference')
    def hasContent_(self):
        if (
            self.CourseTitle is not None or
            self.NumberOfParts is not None or
            self.LocalCourseCode is not None or
            self.CourseCode or
            self.CourseLevel is not None or
            self.CourseLevelCharacteristics is not None or
            self.GradesOffered is not None or
            self.SubjectArea is not None or
            self.CourseDescription is not None or
            self.DateCourseAdopted is not None or
            self.SchoolYear is not None or
            self.HighSchoolCourseRequirement is not None or
            self.CourseGPAApplicability is not None or
            self.EducationOrganizationReference is not None or
            self.StudentExpectationReference or
            super(Course, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Course'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Course, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Course, self).exportLiteralChildren(outfile, level, name_)
        if self.CourseTitle is not None:
            showIndent(outfile, level)
            outfile.write('CourseTitle=%s,\n' % quote_python(self.CourseTitle).encode(ExternalEncoding))
        if self.NumberOfParts is not None:
            showIndent(outfile, level)
            outfile.write('NumberOfParts=%d,\n' % self.NumberOfParts)
        if self.LocalCourseCode is not None:
            showIndent(outfile, level)
            outfile.write('LocalCourseCode=%s,\n' % quote_python(self.LocalCourseCode).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('CourseCode=[\n')
        level += 1
        for CourseCode_ in self.CourseCode:
            showIndent(outfile, level)
            outfile.write('model_.CourseCode(\n')
            CourseCode_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.CourseLevel is not None:
            showIndent(outfile, level)
            outfile.write('CourseLevel=%s,\n' % quote_python(self.CourseLevel).encode(ExternalEncoding))
        if self.CourseLevelCharacteristics is not None:
            showIndent(outfile, level)
            outfile.write('CourseLevelCharacteristics=model_.CourseLevelCharacteristicsType(\n')
            self.CourseLevelCharacteristics.exportLiteral(outfile, level, name_='CourseLevelCharacteristics')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GradesOffered is not None:
            showIndent(outfile, level)
            outfile.write('GradesOffered=model_.GradeLevelsType(\n')
            self.GradesOffered.exportLiteral(outfile, level, name_='GradesOffered')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SubjectArea is not None:
            showIndent(outfile, level)
            outfile.write('SubjectArea=%s,\n' % quote_python(self.SubjectArea).encode(ExternalEncoding))
        if self.CourseDescription is not None:
            showIndent(outfile, level)
            outfile.write('CourseDescription=%s,\n' % quote_python(self.CourseDescription).encode(ExternalEncoding))
        if self.DateCourseAdopted is not None:
            showIndent(outfile, level)
            outfile.write('DateCourseAdopted=%s,\n' % quote_python(self.DateCourseAdopted).encode(ExternalEncoding))
        if self.SchoolYear is not None:
            showIndent(outfile, level)
            outfile.write('SchoolYear=%s,\n' % quote_python(self.SchoolYear).encode(ExternalEncoding))
        if self.HighSchoolCourseRequirement is not None:
            showIndent(outfile, level)
            outfile.write('HighSchoolCourseRequirement=%s,\n' % self.HighSchoolCourseRequirement)
        if self.CourseGPAApplicability is not None:
            showIndent(outfile, level)
            outfile.write('CourseGPAApplicability=%s,\n' % quote_python(self.CourseGPAApplicability).encode(ExternalEncoding))
        if self.EducationOrganizationReference is not None:
            showIndent(outfile, level)
            outfile.write('EducationOrganizationReference=model_.EducationalOrgReferenceType(\n')
            self.EducationOrganizationReference.exportLiteral(outfile, level, name_='EducationOrganizationReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('StudentExpectationReference=[\n')
        level += 1
        for StudentExpectationReference_ in self.StudentExpectationReference:
            showIndent(outfile, level)
            outfile.write('model_.StudentExpectationReferenceType(\n')
            StudentExpectationReference_.exportLiteral(outfile, level, name_='StudentExpectationReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Course, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CourseTitle':
            CourseTitle_ = child_.text
            CourseTitle_ = self.gds_validate_string(CourseTitle_, node, 'CourseTitle')
            self.CourseTitle = CourseTitle_
            self.validate_CourseTitle(self.CourseTitle)    # validate type CourseTitle
        elif nodeName_ == 'NumberOfParts':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumberOfParts')
            self.NumberOfParts = ival_
        elif nodeName_ == 'LocalCourseCode':
            LocalCourseCode_ = child_.text
            LocalCourseCode_ = self.gds_validate_string(LocalCourseCode_, node, 'LocalCourseCode')
            self.LocalCourseCode = LocalCourseCode_
            self.validate_LocalCourseCode(self.LocalCourseCode)    # validate type LocalCourseCode
        elif nodeName_ == 'CourseCode':
            obj_ = CourseCode.factory()
            obj_.build(child_)
            self.CourseCode.append(obj_)
        elif nodeName_ == 'CourseLevel':
            CourseLevel_ = child_.text
            CourseLevel_ = re_.sub(String_cleanup_pat_, " ", CourseLevel_).strip()
            CourseLevel_ = self.gds_validate_string(CourseLevel_, node, 'CourseLevel')
            self.CourseLevel = CourseLevel_
            self.validate_CourseLevelType(self.CourseLevel)    # validate type CourseLevelType
        elif nodeName_ == 'CourseLevelCharacteristics':
            obj_ = CourseLevelCharacteristicsType.factory()
            obj_.build(child_)
            self.set_CourseLevelCharacteristics(obj_)
        elif nodeName_ == 'GradesOffered':
            obj_ = GradeLevelsType.factory()
            obj_.build(child_)
            self.set_GradesOffered(obj_)
        elif nodeName_ == 'SubjectArea':
            SubjectArea_ = child_.text
            SubjectArea_ = re_.sub(String_cleanup_pat_, " ", SubjectArea_).strip()
            SubjectArea_ = self.gds_validate_string(SubjectArea_, node, 'SubjectArea')
            self.SubjectArea = SubjectArea_
            self.validate_SubjectAreaType(self.SubjectArea)    # validate type SubjectAreaType
        elif nodeName_ == 'CourseDescription':
            CourseDescription_ = child_.text
            CourseDescription_ = self.gds_validate_string(CourseDescription_, node, 'CourseDescription')
            self.CourseDescription = CourseDescription_
            self.validate_Description(self.CourseDescription)    # validate type Description
        elif nodeName_ == 'DateCourseAdopted':
            DateCourseAdopted_ = child_.text
            DateCourseAdopted_ = self.gds_validate_string(DateCourseAdopted_, node, 'DateCourseAdopted')
            self.DateCourseAdopted = DateCourseAdopted_
        elif nodeName_ == 'SchoolYear':
            SchoolYear_ = child_.text
            SchoolYear_ = re_.sub(String_cleanup_pat_, " ", SchoolYear_).strip()
            SchoolYear_ = self.gds_validate_string(SchoolYear_, node, 'SchoolYear')
            self.SchoolYear = SchoolYear_
            self.validate_SchoolYearType(self.SchoolYear)    # validate type SchoolYearType
        elif nodeName_ == 'HighSchoolCourseRequirement':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'HighSchoolCourseRequirement')
            self.HighSchoolCourseRequirement = ival_
        elif nodeName_ == 'CourseGPAApplicability':
            CourseGPAApplicability_ = child_.text
            CourseGPAApplicability_ = re_.sub(String_cleanup_pat_, " ", CourseGPAApplicability_).strip()
            CourseGPAApplicability_ = self.gds_validate_string(CourseGPAApplicability_, node, 'CourseGPAApplicability')
            self.CourseGPAApplicability = CourseGPAApplicability_
            self.validate_CourseGPAApplicabilityType(self.CourseGPAApplicability)    # validate type CourseGPAApplicabilityType
        elif nodeName_ == 'EducationOrganizationReference':
            obj_ = EducationalOrgReferenceType.factory()
            obj_.build(child_)
            self.set_EducationOrganizationReference(obj_)
        elif nodeName_ == 'StudentExpectationReference':
            obj_ = StudentExpectationReferenceType.factory()
            obj_.build(child_)
            self.StudentExpectationReference.append(obj_)
        super(Course, self).buildChildren(child_, node, nodeName_, True)
# end class Course


class ContractedStaff(ComplexObjectType):
    """This financial entity represents the sum of the financal
    transactions to date for contracted staff. Contracted staff
    includes "contractors" or "consultants" who perform services for
    an agreed upon fee, or an employee of a management service
    contracted to work on site."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, FiscalYear=None, AmountToDate=None, AccountReference=None, StaffReference=None):
        super(ContractedStaff, self).__init__(id, )
        self.FiscalYear = FiscalYear
        self.AmountToDate = AmountToDate
        self.AccountReference = AccountReference
        self.StaffReference = StaffReference
    def factory(*args_, **kwargs_):
        if ContractedStaff.subclass:
            return ContractedStaff.subclass(*args_, **kwargs_)
        else:
            return ContractedStaff(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FiscalYear(self): return self.FiscalYear
    def set_FiscalYear(self, FiscalYear): self.FiscalYear = FiscalYear
    def get_AmountToDate(self): return self.AmountToDate
    def set_AmountToDate(self, AmountToDate): self.AmountToDate = AmountToDate
    def validate_Currency(self, value):
        # Validate type Currency, a restriction on xs:decimal.
        pass
    def get_AccountReference(self): return self.AccountReference
    def set_AccountReference(self, AccountReference): self.AccountReference = AccountReference
    def get_StaffReference(self): return self.StaffReference
    def set_StaffReference(self, StaffReference): self.StaffReference = StaffReference
    def export(self, outfile, level, namespace_='', name_='ContractedStaff', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContractedStaff')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContractedStaff'):
        super(ContractedStaff, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ContractedStaff')
    def exportChildren(self, outfile, level, namespace_='', name_='ContractedStaff', fromsubclass_=False):
        super(ContractedStaff, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.FiscalYear is not None:
            showIndent(outfile, level)
            outfile.write('<%sFiscalYear>%s</%sFiscalYear>\n' % (namespace_, self.gds_format_integer(self.FiscalYear, input_name='FiscalYear'), namespace_))
        if self.AmountToDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sAmountToDate>%s</%sAmountToDate>\n' % (namespace_, self.gds_format_float(self.AmountToDate, input_name='AmountToDate'), namespace_))
        if self.AccountReference:
            self.AccountReference.export(outfile, level, namespace_, name_='AccountReference', )
        if self.StaffReference:
            self.StaffReference.export(outfile, level, namespace_, name_='StaffReference', )
    def hasContent_(self):
        if (
            self.FiscalYear is not None or
            self.AmountToDate is not None or
            self.AccountReference is not None or
            self.StaffReference is not None or
            super(ContractedStaff, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ContractedStaff'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ContractedStaff, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ContractedStaff, self).exportLiteralChildren(outfile, level, name_)
        if self.FiscalYear is not None:
            showIndent(outfile, level)
            outfile.write('FiscalYear=%d,\n' % self.FiscalYear)
        if self.AmountToDate is not None:
            showIndent(outfile, level)
            outfile.write('AmountToDate=%f,\n' % self.AmountToDate)
        if self.AccountReference is not None:
            showIndent(outfile, level)
            outfile.write('AccountReference=model_.AccountReferenceType(\n')
            self.AccountReference.exportLiteral(outfile, level, name_='AccountReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.StaffReference is not None:
            showIndent(outfile, level)
            outfile.write('StaffReference=model_.StaffReferenceType(\n')
            self.StaffReference.exportLiteral(outfile, level, name_='StaffReference')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(ContractedStaff, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FiscalYear':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'FiscalYear')
            self.FiscalYear = ival_
        elif nodeName_ == 'AmountToDate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AmountToDate')
            self.AmountToDate = fval_
            self.validate_Currency(self.AmountToDate)    # validate type Currency
        elif nodeName_ == 'AccountReference':
            obj_ = AccountReferenceType.factory()
            obj_.build(child_)
            self.set_AccountReference(obj_)
        elif nodeName_ == 'StaffReference':
            obj_ = StaffReferenceType.factory()
            obj_.build(child_)
            self.set_StaffReference(obj_)
        super(ContractedStaff, self).buildChildren(child_, node, nodeName_, True)
# end class ContractedStaff


class Cohort(ComplexObjectType):
    """This entity represents any type of list of designated students for
    tracking, analysis, or intervention."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, CohortIdentifier=None, CohortDescription=None, CohortType=None, CohortScope=None, AcademicSubject=None, EducationOrgReference=None, ProgramReference=None):
        super(Cohort, self).__init__(id, )
        self.CohortIdentifier = CohortIdentifier
        self.CohortDescription = CohortDescription
        self.CohortType = CohortType
        self.CohortScope = CohortScope
        self.AcademicSubject = AcademicSubject
        self.EducationOrgReference = EducationOrgReference
        if ProgramReference is None:
            self.ProgramReference = []
        else:
            self.ProgramReference = ProgramReference
    def factory(*args_, **kwargs_):
        if Cohort.subclass:
            return Cohort.subclass(*args_, **kwargs_)
        else:
            return Cohort(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CohortIdentifier(self): return self.CohortIdentifier
    def set_CohortIdentifier(self, CohortIdentifier): self.CohortIdentifier = CohortIdentifier
    def validate_CohortIdentifier(self, value):
        # Validate type CohortIdentifier, a restriction on xs:string.
        pass
    def get_CohortDescription(self): return self.CohortDescription
    def set_CohortDescription(self, CohortDescription): self.CohortDescription = CohortDescription
    def validate_CohortDescription(self, value):
        # Validate type CohortDescription, a restriction on xs:string.
        pass
    def get_CohortType(self): return self.CohortType
    def set_CohortType(self, CohortType): self.CohortType = CohortType
    def validate_CohortType(self, value):
        # Validate type CohortType, a restriction on xs:token.
        pass
    def get_CohortScope(self): return self.CohortScope
    def set_CohortScope(self, CohortScope): self.CohortScope = CohortScope
    def validate_CohortScopeType(self, value):
        # Validate type CohortScopeType, a restriction on xs:token.
        pass
    def get_AcademicSubject(self): return self.AcademicSubject
    def set_AcademicSubject(self, AcademicSubject): self.AcademicSubject = AcademicSubject
    def validate_AcademicSubjectType(self, value):
        # Validate type AcademicSubjectType, a restriction on xs:token.
        pass
    def get_EducationOrgReference(self): return self.EducationOrgReference
    def set_EducationOrgReference(self, EducationOrgReference): self.EducationOrgReference = EducationOrgReference
    def get_ProgramReference(self): return self.ProgramReference
    def set_ProgramReference(self, ProgramReference): self.ProgramReference = ProgramReference
    def add_ProgramReference(self, value): self.ProgramReference.append(value)
    def insert_ProgramReference(self, index, value): self.ProgramReference[index] = value
    def export(self, outfile, level, namespace_='', name_='Cohort', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Cohort')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Cohort'):
        super(Cohort, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Cohort')
    def exportChildren(self, outfile, level, namespace_='', name_='Cohort', fromsubclass_=False):
        super(Cohort, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.CohortIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('<%sCohortIdentifier>%s</%sCohortIdentifier>\n' % (namespace_, self.gds_format_string(quote_xml(self.CohortIdentifier).encode(ExternalEncoding), input_name='CohortIdentifier'), namespace_))
        if self.CohortDescription is not None:
            showIndent(outfile, level)
            outfile.write('<%sCohortDescription>%s</%sCohortDescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.CohortDescription).encode(ExternalEncoding), input_name='CohortDescription'), namespace_))
        if self.CohortType is not None:
            showIndent(outfile, level)
            outfile.write('<%sCohortType>%s</%sCohortType>\n' % (namespace_, self.gds_format_string(quote_xml(self.CohortType).encode(ExternalEncoding), input_name='CohortType'), namespace_))
        if self.CohortScope is not None:
            showIndent(outfile, level)
            outfile.write('<%sCohortScope>%s</%sCohortScope>\n' % (namespace_, self.gds_format_string(quote_xml(self.CohortScope).encode(ExternalEncoding), input_name='CohortScope'), namespace_))
        if self.AcademicSubject is not None:
            showIndent(outfile, level)
            outfile.write('<%sAcademicSubject>%s</%sAcademicSubject>\n' % (namespace_, self.gds_format_string(quote_xml(self.AcademicSubject).encode(ExternalEncoding), input_name='AcademicSubject'), namespace_))
        if self.EducationOrgReference:
            self.EducationOrgReference.export(outfile, level, namespace_, name_='EducationOrgReference', )
        for ProgramReference_ in self.ProgramReference:
            ProgramReference_.export(outfile, level, namespace_, name_='ProgramReference')
    def hasContent_(self):
        if (
            self.CohortIdentifier is not None or
            self.CohortDescription is not None or
            self.CohortType is not None or
            self.CohortScope is not None or
            self.AcademicSubject is not None or
            self.EducationOrgReference is not None or
            self.ProgramReference or
            super(Cohort, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Cohort'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Cohort, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Cohort, self).exportLiteralChildren(outfile, level, name_)
        if self.CohortIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('CohortIdentifier=%s,\n' % quote_python(self.CohortIdentifier).encode(ExternalEncoding))
        if self.CohortDescription is not None:
            showIndent(outfile, level)
            outfile.write('CohortDescription=%s,\n' % quote_python(self.CohortDescription).encode(ExternalEncoding))
        if self.CohortType is not None:
            showIndent(outfile, level)
            outfile.write('CohortType=%s,\n' % quote_python(self.CohortType).encode(ExternalEncoding))
        if self.CohortScope is not None:
            showIndent(outfile, level)
            outfile.write('CohortScope=%s,\n' % quote_python(self.CohortScope).encode(ExternalEncoding))
        if self.AcademicSubject is not None:
            showIndent(outfile, level)
            outfile.write('AcademicSubject=%s,\n' % quote_python(self.AcademicSubject).encode(ExternalEncoding))
        if self.EducationOrgReference is not None:
            showIndent(outfile, level)
            outfile.write('EducationOrgReference=model_.EducationalOrgReferenceType(\n')
            self.EducationOrgReference.exportLiteral(outfile, level, name_='EducationOrgReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('ProgramReference=[\n')
        level += 1
        for ProgramReference_ in self.ProgramReference:
            showIndent(outfile, level)
            outfile.write('model_.ProgramReferenceType(\n')
            ProgramReference_.exportLiteral(outfile, level, name_='ProgramReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Cohort, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CohortIdentifier':
            CohortIdentifier_ = child_.text
            CohortIdentifier_ = self.gds_validate_string(CohortIdentifier_, node, 'CohortIdentifier')
            self.CohortIdentifier = CohortIdentifier_
            self.validate_CohortIdentifier(self.CohortIdentifier)    # validate type CohortIdentifier
        elif nodeName_ == 'CohortDescription':
            CohortDescription_ = child_.text
            CohortDescription_ = self.gds_validate_string(CohortDescription_, node, 'CohortDescription')
            self.CohortDescription = CohortDescription_
            self.validate_CohortDescription(self.CohortDescription)    # validate type CohortDescription
        elif nodeName_ == 'CohortType':
            CohortType_ = child_.text
            CohortType_ = re_.sub(String_cleanup_pat_, " ", CohortType_).strip()
            CohortType_ = self.gds_validate_string(CohortType_, node, 'CohortType')
            self.CohortType = CohortType_
            self.validate_CohortType(self.CohortType)    # validate type CohortType
        elif nodeName_ == 'CohortScope':
            CohortScope_ = child_.text
            CohortScope_ = re_.sub(String_cleanup_pat_, " ", CohortScope_).strip()
            CohortScope_ = self.gds_validate_string(CohortScope_, node, 'CohortScope')
            self.CohortScope = CohortScope_
            self.validate_CohortScopeType(self.CohortScope)    # validate type CohortScopeType
        elif nodeName_ == 'AcademicSubject':
            AcademicSubject_ = child_.text
            AcademicSubject_ = re_.sub(String_cleanup_pat_, " ", AcademicSubject_).strip()
            AcademicSubject_ = self.gds_validate_string(AcademicSubject_, node, 'AcademicSubject')
            self.AcademicSubject = AcademicSubject_
            self.validate_AcademicSubjectType(self.AcademicSubject)    # validate type AcademicSubjectType
        elif nodeName_ == 'EducationOrgReference':
            obj_ = EducationalOrgReferenceType.factory()
            obj_.build(child_)
            self.set_EducationOrgReference(obj_)
        elif nodeName_ == 'ProgramReference':
            obj_ = ProgramReferenceType.factory()
            obj_.build(child_)
            self.ProgramReference.append(obj_)
        super(Cohort, self).buildChildren(child_, node, nodeName_, True)
# end class Cohort


class ClassPeriod(ComplexObjectType):
    """This entity represents the designation of regularly scheduled series
    of class meetings at designated times and days of the week."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, ClassPeriodName=None, MeetingTimes=None, BellScheduleReference=None):
        super(ClassPeriod, self).__init__(id, )
        self.ClassPeriodName = ClassPeriodName
        if MeetingTimes is None:
            self.MeetingTimes = []
        else:
            self.MeetingTimes = MeetingTimes
        self.BellScheduleReference = BellScheduleReference
    def factory(*args_, **kwargs_):
        if ClassPeriod.subclass:
            return ClassPeriod.subclass(*args_, **kwargs_)
        else:
            return ClassPeriod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ClassPeriodName(self): return self.ClassPeriodName
    def set_ClassPeriodName(self, ClassPeriodName): self.ClassPeriodName = ClassPeriodName
    def validate_ClassPeriodNameType(self, value):
        # Validate type ClassPeriodNameType, a restriction on xs:string.
        pass
    def get_MeetingTimes(self): return self.MeetingTimes
    def set_MeetingTimes(self, MeetingTimes): self.MeetingTimes = MeetingTimes
    def add_MeetingTimes(self, value): self.MeetingTimes.append(value)
    def insert_MeetingTimes(self, index, value): self.MeetingTimes[index] = value
    def get_BellScheduleReference(self): return self.BellScheduleReference
    def set_BellScheduleReference(self, BellScheduleReference): self.BellScheduleReference = BellScheduleReference
    def export(self, outfile, level, namespace_='', name_='ClassPeriod', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClassPeriod')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ClassPeriod'):
        super(ClassPeriod, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ClassPeriod')
    def exportChildren(self, outfile, level, namespace_='', name_='ClassPeriod', fromsubclass_=False):
        super(ClassPeriod, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.ClassPeriodName is not None:
            showIndent(outfile, level)
            outfile.write('<%sClassPeriodName>%s</%sClassPeriodName>\n' % (namespace_, self.gds_format_string(quote_xml(self.ClassPeriodName).encode(ExternalEncoding), input_name='ClassPeriodName'), namespace_))
        for MeetingTimes_ in self.MeetingTimes:
            MeetingTimes_.export(outfile, level, namespace_, name_='MeetingTimes')
        if self.BellScheduleReference:
            self.BellScheduleReference.export(outfile, level, namespace_, name_='BellScheduleReference', )
    def hasContent_(self):
        if (
            self.ClassPeriodName is not None or
            self.MeetingTimes or
            self.BellScheduleReference is not None or
            super(ClassPeriod, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ClassPeriod'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ClassPeriod, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ClassPeriod, self).exportLiteralChildren(outfile, level, name_)
        if self.ClassPeriodName is not None:
            showIndent(outfile, level)
            outfile.write('ClassPeriodName=%s,\n' % quote_python(self.ClassPeriodName).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('MeetingTimes=[\n')
        level += 1
        for MeetingTimes_ in self.MeetingTimes:
            showIndent(outfile, level)
            outfile.write('model_.MeetingTime(\n')
            MeetingTimes_.exportLiteral(outfile, level, name_='MeetingTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.BellScheduleReference is not None:
            showIndent(outfile, level)
            outfile.write('BellScheduleReference=model_.BellScheduleReferenceType(\n')
            self.BellScheduleReference.exportLiteral(outfile, level, name_='BellScheduleReference')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(ClassPeriod, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ClassPeriodName':
            ClassPeriodName_ = child_.text
            ClassPeriodName_ = self.gds_validate_string(ClassPeriodName_, node, 'ClassPeriodName')
            self.ClassPeriodName = ClassPeriodName_
            self.validate_ClassPeriodNameType(self.ClassPeriodName)    # validate type ClassPeriodNameType
        elif nodeName_ == 'MeetingTimes':
            obj_ = MeetingTime.factory()
            obj_.build(child_)
            self.MeetingTimes.append(obj_)
        elif nodeName_ == 'BellScheduleReference':
            obj_ = BellScheduleReferenceType.factory()
            obj_.build(child_)
            self.set_BellScheduleReference(obj_)
        super(ClassPeriod, self).buildChildren(child_, node, nodeName_, True)
# end class ClassPeriod


class CalendarDate(ComplexObjectType):
    """This entity represents a day in the school calendar."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, Date=None, CalendarEvent=None):
        super(CalendarDate, self).__init__(id, )
        self.Date = Date
        self.CalendarEvent = CalendarEvent
    def factory(*args_, **kwargs_):
        if CalendarDate.subclass:
            return CalendarDate.subclass(*args_, **kwargs_)
        else:
            return CalendarDate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def get_CalendarEvent(self): return self.CalendarEvent
    def set_CalendarEvent(self, CalendarEvent): self.CalendarEvent = CalendarEvent
    def validate_CalendarEventType(self, value):
        # Validate type CalendarEventType, a restriction on xs:token.
        pass
    def export(self, outfile, level, namespace_='', name_='CalendarDate', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CalendarDate')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CalendarDate'):
        super(CalendarDate, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CalendarDate')
    def exportChildren(self, outfile, level, namespace_='', name_='CalendarDate', fromsubclass_=False):
        super(CalendarDate, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.Date is not None:
            showIndent(outfile, level)
            outfile.write('<%sDate>%s</%sDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.Date).encode(ExternalEncoding), input_name='Date'), namespace_))
        if self.CalendarEvent is not None:
            showIndent(outfile, level)
            outfile.write('<%sCalendarEvent>%s</%sCalendarEvent>\n' % (namespace_, self.gds_format_string(quote_xml(self.CalendarEvent).encode(ExternalEncoding), input_name='CalendarEvent'), namespace_))
    def hasContent_(self):
        if (
            self.Date is not None or
            self.CalendarEvent is not None or
            super(CalendarDate, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CalendarDate'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CalendarDate, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CalendarDate, self).exportLiteralChildren(outfile, level, name_)
        if self.Date is not None:
            showIndent(outfile, level)
            outfile.write('Date=%s,\n' % quote_python(self.Date).encode(ExternalEncoding))
        if self.CalendarEvent is not None:
            showIndent(outfile, level)
            outfile.write('CalendarEvent=%s,\n' % quote_python(self.CalendarEvent).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(CalendarDate, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Date':
            Date_ = child_.text
            Date_ = self.gds_validate_string(Date_, node, 'Date')
            self.Date = Date_
        elif nodeName_ == 'CalendarEvent':
            CalendarEvent_ = child_.text
            CalendarEvent_ = re_.sub(String_cleanup_pat_, " ", CalendarEvent_).strip()
            CalendarEvent_ = self.gds_validate_string(CalendarEvent_, node, 'CalendarEvent')
            self.CalendarEvent = CalendarEvent_
            self.validate_CalendarEventType(self.CalendarEvent)    # validate type CalendarEventType
        super(CalendarDate, self).buildChildren(child_, node, nodeName_, True)
# end class CalendarDate


class Budget(ComplexObjectType):
    """This financial entity represents the amount of monies allocated to
    be spent or received by an education organization as related to
    a specific account."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, FiscalYear=None, Amount=None, AccountReference=None):
        super(Budget, self).__init__(id, )
        self.FiscalYear = FiscalYear
        self.Amount = Amount
        self.AccountReference = AccountReference
    def factory(*args_, **kwargs_):
        if Budget.subclass:
            return Budget.subclass(*args_, **kwargs_)
        else:
            return Budget(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FiscalYear(self): return self.FiscalYear
    def set_FiscalYear(self, FiscalYear): self.FiscalYear = FiscalYear
    def get_Amount(self): return self.Amount
    def set_Amount(self, Amount): self.Amount = Amount
    def validate_Currency(self, value):
        # Validate type Currency, a restriction on xs:decimal.
        pass
    def get_AccountReference(self): return self.AccountReference
    def set_AccountReference(self, AccountReference): self.AccountReference = AccountReference
    def export(self, outfile, level, namespace_='', name_='Budget', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Budget')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Budget'):
        super(Budget, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Budget')
    def exportChildren(self, outfile, level, namespace_='', name_='Budget', fromsubclass_=False):
        super(Budget, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.FiscalYear is not None:
            showIndent(outfile, level)
            outfile.write('<%sFiscalYear>%s</%sFiscalYear>\n' % (namespace_, self.gds_format_integer(self.FiscalYear, input_name='FiscalYear'), namespace_))
        if self.Amount is not None:
            showIndent(outfile, level)
            outfile.write('<%sAmount>%s</%sAmount>\n' % (namespace_, self.gds_format_float(self.Amount, input_name='Amount'), namespace_))
        if self.AccountReference:
            self.AccountReference.export(outfile, level, namespace_, name_='AccountReference', )
    def hasContent_(self):
        if (
            self.FiscalYear is not None or
            self.Amount is not None or
            self.AccountReference is not None or
            super(Budget, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Budget'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Budget, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Budget, self).exportLiteralChildren(outfile, level, name_)
        if self.FiscalYear is not None:
            showIndent(outfile, level)
            outfile.write('FiscalYear=%d,\n' % self.FiscalYear)
        if self.Amount is not None:
            showIndent(outfile, level)
            outfile.write('Amount=%f,\n' % self.Amount)
        if self.AccountReference is not None:
            showIndent(outfile, level)
            outfile.write('AccountReference=model_.AccountReferenceType(\n')
            self.AccountReference.exportLiteral(outfile, level, name_='AccountReference')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Budget, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FiscalYear':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'FiscalYear')
            self.FiscalYear = ival_
        elif nodeName_ == 'Amount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Amount')
            self.Amount = fval_
            self.validate_Currency(self.Amount)    # validate type Currency
        elif nodeName_ == 'AccountReference':
            obj_ = AccountReferenceType.factory()
            obj_.build(child_)
            self.set_AccountReference(obj_)
        super(Budget, self).buildChildren(child_, node, nodeName_, True)
# end class Budget


class BellSchedule(ComplexObjectType):
    """This entity represents the schedule of class period meeting times."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, GradeLevels=None, SchoolYear=None, WeeksInCycle=None, SchoolReference=None):
        super(BellSchedule, self).__init__(id, )
        self.GradeLevels = GradeLevels
        self.SchoolYear = SchoolYear
        self.WeeksInCycle = WeeksInCycle
        if SchoolReference is None:
            self.SchoolReference = []
        else:
            self.SchoolReference = SchoolReference
    def factory(*args_, **kwargs_):
        if BellSchedule.subclass:
            return BellSchedule.subclass(*args_, **kwargs_)
        else:
            return BellSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GradeLevels(self): return self.GradeLevels
    def set_GradeLevels(self, GradeLevels): self.GradeLevels = GradeLevels
    def get_SchoolYear(self): return self.SchoolYear
    def set_SchoolYear(self, SchoolYear): self.SchoolYear = SchoolYear
    def validate_SchoolYearType(self, value):
        # Validate type SchoolYearType, a restriction on xs:token.
        pass
    def get_WeeksInCycle(self): return self.WeeksInCycle
    def set_WeeksInCycle(self, WeeksInCycle): self.WeeksInCycle = WeeksInCycle
    def get_SchoolReference(self): return self.SchoolReference
    def set_SchoolReference(self, SchoolReference): self.SchoolReference = SchoolReference
    def add_SchoolReference(self, value): self.SchoolReference.append(value)
    def insert_SchoolReference(self, index, value): self.SchoolReference[index] = value
    def export(self, outfile, level, namespace_='', name_='BellSchedule', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BellSchedule')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BellSchedule'):
        super(BellSchedule, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BellSchedule')
    def exportChildren(self, outfile, level, namespace_='', name_='BellSchedule', fromsubclass_=False):
        super(BellSchedule, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.GradeLevels:
            self.GradeLevels.export(outfile, level, namespace_, name_='GradeLevels', )
        if self.SchoolYear is not None:
            showIndent(outfile, level)
            outfile.write('<%sSchoolYear>%s</%sSchoolYear>\n' % (namespace_, self.gds_format_string(quote_xml(self.SchoolYear).encode(ExternalEncoding), input_name='SchoolYear'), namespace_))
        if self.WeeksInCycle is not None:
            showIndent(outfile, level)
            outfile.write('<%sWeeksInCycle>%s</%sWeeksInCycle>\n' % (namespace_, self.gds_format_integer(self.WeeksInCycle, input_name='WeeksInCycle'), namespace_))
        for SchoolReference_ in self.SchoolReference:
            SchoolReference_.export(outfile, level, namespace_, name_='SchoolReference')
    def hasContent_(self):
        if (
            self.GradeLevels is not None or
            self.SchoolYear is not None or
            self.WeeksInCycle is not None or
            self.SchoolReference or
            super(BellSchedule, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BellSchedule'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(BellSchedule, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BellSchedule, self).exportLiteralChildren(outfile, level, name_)
        if self.GradeLevels is not None:
            showIndent(outfile, level)
            outfile.write('GradeLevels=model_.GradeLevelsType(\n')
            self.GradeLevels.exportLiteral(outfile, level, name_='GradeLevels')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SchoolYear is not None:
            showIndent(outfile, level)
            outfile.write('SchoolYear=%s,\n' % quote_python(self.SchoolYear).encode(ExternalEncoding))
        if self.WeeksInCycle is not None:
            showIndent(outfile, level)
            outfile.write('WeeksInCycle=%d,\n' % self.WeeksInCycle)
        showIndent(outfile, level)
        outfile.write('SchoolReference=[\n')
        level += 1
        for SchoolReference_ in self.SchoolReference:
            showIndent(outfile, level)
            outfile.write('model_.EducationalOrgReferenceType(\n')
            SchoolReference_.exportLiteral(outfile, level, name_='EducationalOrgReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(BellSchedule, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GradeLevels':
            obj_ = GradeLevelsType.factory()
            obj_.build(child_)
            self.set_GradeLevels(obj_)
        elif nodeName_ == 'SchoolYear':
            SchoolYear_ = child_.text
            SchoolYear_ = re_.sub(String_cleanup_pat_, " ", SchoolYear_).strip()
            SchoolYear_ = self.gds_validate_string(SchoolYear_, node, 'SchoolYear')
            self.SchoolYear = SchoolYear_
            self.validate_SchoolYearType(self.SchoolYear)    # validate type SchoolYearType
        elif nodeName_ == 'WeeksInCycle':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'WeeksInCycle')
            self.WeeksInCycle = ival_
        elif nodeName_ == 'SchoolReference':
            obj_ = EducationalOrgReferenceType.factory()
            obj_.build(child_)
            self.SchoolReference.append(obj_)
        super(BellSchedule, self).buildChildren(child_, node, nodeName_, True)
# end class BellSchedule


class AttendanceEvent(ComplexObjectType):
    """This event entity represents the recording of whether a student is
    in attendance for a class or in attendance to receive or
    participate in program services."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, EventDate=None, AttendanceEventType=None, AttendanceEventDescriptor=None, AttendanceEventReason=None, EducationalEnvironment=None, StudentReference=None, SectionReference=None):
        super(AttendanceEvent, self).__init__(id, )
        self.EventDate = EventDate
        self.AttendanceEventType = AttendanceEventType
        self.AttendanceEventDescriptor = AttendanceEventDescriptor
        self.AttendanceEventReason = AttendanceEventReason
        self.EducationalEnvironment = EducationalEnvironment
        self.StudentReference = StudentReference
        self.SectionReference = SectionReference
    def factory(*args_, **kwargs_):
        if AttendanceEvent.subclass:
            return AttendanceEvent.subclass(*args_, **kwargs_)
        else:
            return AttendanceEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EventDate(self): return self.EventDate
    def set_EventDate(self, EventDate): self.EventDate = EventDate
    def get_AttendanceEventType(self): return self.AttendanceEventType
    def set_AttendanceEventType(self, AttendanceEventType): self.AttendanceEventType = AttendanceEventType
    def validate_AttendanceEventType(self, value):
        # Validate type AttendanceEventType, a restriction on xs:token.
        pass
    def get_AttendanceEventDescriptor(self): return self.AttendanceEventDescriptor
    def set_AttendanceEventDescriptor(self, AttendanceEventDescriptor): self.AttendanceEventDescriptor = AttendanceEventDescriptor
    def validate_AttendanceEventDescriptorType(self, value):
        # Validate type AttendanceEventDescriptorType, a restriction on xs:token.
        pass
    def get_AttendanceEventReason(self): return self.AttendanceEventReason
    def set_AttendanceEventReason(self, AttendanceEventReason): self.AttendanceEventReason = AttendanceEventReason
    def validate_AttendanceEventReason(self, value):
        # Validate type AttendanceEventReason, a restriction on xs:string.
        pass
    def get_EducationalEnvironment(self): return self.EducationalEnvironment
    def set_EducationalEnvironment(self, EducationalEnvironment): self.EducationalEnvironment = EducationalEnvironment
    def validate_EducationalEnvironmentType(self, value):
        # Validate type EducationalEnvironmentType, a restriction on xs:token.
        pass
    def get_StudentReference(self): return self.StudentReference
    def set_StudentReference(self, StudentReference): self.StudentReference = StudentReference
    def get_SectionReference(self): return self.SectionReference
    def set_SectionReference(self, SectionReference): self.SectionReference = SectionReference
    def export(self, outfile, level, namespace_='', name_='AttendanceEvent', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttendanceEvent')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttendanceEvent'):
        super(AttendanceEvent, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AttendanceEvent')
    def exportChildren(self, outfile, level, namespace_='', name_='AttendanceEvent', fromsubclass_=False):
        super(AttendanceEvent, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.EventDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sEventDate>%s</%sEventDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.EventDate).encode(ExternalEncoding), input_name='EventDate'), namespace_))
        if self.AttendanceEventType is not None:
            showIndent(outfile, level)
            outfile.write('<%sAttendanceEventType>%s</%sAttendanceEventType>\n' % (namespace_, self.gds_format_string(quote_xml(self.AttendanceEventType).encode(ExternalEncoding), input_name='AttendanceEventType'), namespace_))
        if self.AttendanceEventDescriptor is not None:
            showIndent(outfile, level)
            outfile.write('<%sAttendanceEventDescriptor>%s</%sAttendanceEventDescriptor>\n' % (namespace_, self.gds_format_string(quote_xml(self.AttendanceEventDescriptor).encode(ExternalEncoding), input_name='AttendanceEventDescriptor'), namespace_))
        if self.AttendanceEventReason is not None:
            showIndent(outfile, level)
            outfile.write('<%sAttendanceEventReason>%s</%sAttendanceEventReason>\n' % (namespace_, self.gds_format_string(quote_xml(self.AttendanceEventReason).encode(ExternalEncoding), input_name='AttendanceEventReason'), namespace_))
        if self.EducationalEnvironment is not None:
            showIndent(outfile, level)
            outfile.write('<%sEducationalEnvironment>%s</%sEducationalEnvironment>\n' % (namespace_, self.gds_format_string(quote_xml(self.EducationalEnvironment).encode(ExternalEncoding), input_name='EducationalEnvironment'), namespace_))
        if self.StudentReference:
            self.StudentReference.export(outfile, level, namespace_, name_='StudentReference', )
        if self.SectionReference:
            self.SectionReference.export(outfile, level, namespace_, name_='SectionReference')
    def hasContent_(self):
        if (
            self.EventDate is not None or
            self.AttendanceEventType is not None or
            self.AttendanceEventDescriptor is not None or
            self.AttendanceEventReason is not None or
            self.EducationalEnvironment is not None or
            self.StudentReference is not None or
            self.SectionReference is not None or
            super(AttendanceEvent, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AttendanceEvent'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AttendanceEvent, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AttendanceEvent, self).exportLiteralChildren(outfile, level, name_)
        if self.EventDate is not None:
            showIndent(outfile, level)
            outfile.write('EventDate=%s,\n' % quote_python(self.EventDate).encode(ExternalEncoding))
        if self.AttendanceEventType is not None:
            showIndent(outfile, level)
            outfile.write('AttendanceEventType=%s,\n' % quote_python(self.AttendanceEventType).encode(ExternalEncoding))
        if self.AttendanceEventDescriptor is not None:
            showIndent(outfile, level)
            outfile.write('AttendanceEventDescriptor=%s,\n' % quote_python(self.AttendanceEventDescriptor).encode(ExternalEncoding))
        if self.AttendanceEventReason is not None:
            showIndent(outfile, level)
            outfile.write('AttendanceEventReason=%s,\n' % quote_python(self.AttendanceEventReason).encode(ExternalEncoding))
        if self.EducationalEnvironment is not None:
            showIndent(outfile, level)
            outfile.write('EducationalEnvironment=%s,\n' % quote_python(self.EducationalEnvironment).encode(ExternalEncoding))
        if self.StudentReference is not None:
            showIndent(outfile, level)
            outfile.write('StudentReference=model_.StudentReferenceType(\n')
            self.StudentReference.exportLiteral(outfile, level, name_='StudentReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SectionReference is not None:
            showIndent(outfile, level)
            outfile.write('SectionReference=model_.SectionReferenceType(\n')
            self.SectionReference.exportLiteral(outfile, level, name_='SectionReference')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AttendanceEvent, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EventDate':
            EventDate_ = child_.text
            EventDate_ = self.gds_validate_string(EventDate_, node, 'EventDate')
            self.EventDate = EventDate_
        elif nodeName_ == 'AttendanceEventType':
            AttendanceEventType_ = child_.text
            AttendanceEventType_ = re_.sub(String_cleanup_pat_, " ", AttendanceEventType_).strip()
            AttendanceEventType_ = self.gds_validate_string(AttendanceEventType_, node, 'AttendanceEventType')
            self.AttendanceEventType = AttendanceEventType_
            self.validate_AttendanceEventType(self.AttendanceEventType)    # validate type AttendanceEventType
        elif nodeName_ == 'AttendanceEventDescriptor':
            AttendanceEventDescriptor_ = child_.text
            AttendanceEventDescriptor_ = re_.sub(String_cleanup_pat_, " ", AttendanceEventDescriptor_).strip()
            AttendanceEventDescriptor_ = self.gds_validate_string(AttendanceEventDescriptor_, node, 'AttendanceEventDescriptor')
            self.AttendanceEventDescriptor = AttendanceEventDescriptor_
            self.validate_AttendanceEventDescriptorType(self.AttendanceEventDescriptor)    # validate type AttendanceEventDescriptorType
        elif nodeName_ == 'AttendanceEventReason':
            AttendanceEventReason_ = child_.text
            AttendanceEventReason_ = self.gds_validate_string(AttendanceEventReason_, node, 'AttendanceEventReason')
            self.AttendanceEventReason = AttendanceEventReason_
            self.validate_AttendanceEventReason(self.AttendanceEventReason)    # validate type AttendanceEventReason
        elif nodeName_ == 'EducationalEnvironment':
            EducationalEnvironment_ = child_.text
            EducationalEnvironment_ = re_.sub(String_cleanup_pat_, " ", EducationalEnvironment_).strip()
            EducationalEnvironment_ = self.gds_validate_string(EducationalEnvironment_, node, 'EducationalEnvironment')
            self.EducationalEnvironment = EducationalEnvironment_
            self.validate_EducationalEnvironmentType(self.EducationalEnvironment)    # validate type EducationalEnvironmentType
        elif nodeName_ == 'StudentReference':
            obj_ = StudentReferenceType.factory()
            obj_.build(child_)
            self.set_StudentReference(obj_)
        elif nodeName_ == 'SectionReference':
            obj_ = SectionReferenceType.factory()
            obj_.build(child_)
            self.set_SectionReference(obj_)
        super(AttendanceEvent, self).buildChildren(child_, node, nodeName_, True)
# end class AttendanceEvent


class AssessmentRatingStandard(ComplexObjectType):
    """Defines various levels or thresholds for performance on the test."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, RatingStandardName=None, MinimumScore=None, MaximumScore=None):
        super(AssessmentRatingStandard, self).__init__(id, )
        self.RatingStandardName = RatingStandardName
        self.MinimumScore = MinimumScore
        self.MaximumScore = MaximumScore
    def factory(*args_, **kwargs_):
        if AssessmentRatingStandard.subclass:
            return AssessmentRatingStandard.subclass(*args_, **kwargs_)
        else:
            return AssessmentRatingStandard(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RatingStandardName(self): return self.RatingStandardName
    def set_RatingStandardName(self, RatingStandardName): self.RatingStandardName = RatingStandardName
    def validate_RatingStandardNameType(self, value):
        # Validate type RatingStandardNameType, a restriction on xs:token.
        pass
    def get_MinimumScore(self): return self.MinimumScore
    def set_MinimumScore(self, MinimumScore): self.MinimumScore = MinimumScore
    def get_MaximumScore(self): return self.MaximumScore
    def set_MaximumScore(self, MaximumScore): self.MaximumScore = MaximumScore
    def export(self, outfile, level, namespace_='', name_='AssessmentRatingStandard', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssessmentRatingStandard')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AssessmentRatingStandard'):
        super(AssessmentRatingStandard, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AssessmentRatingStandard')
    def exportChildren(self, outfile, level, namespace_='', name_='AssessmentRatingStandard', fromsubclass_=False):
        super(AssessmentRatingStandard, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.RatingStandardName is not None:
            showIndent(outfile, level)
            outfile.write('<%sRatingStandardName>%s</%sRatingStandardName>\n' % (namespace_, self.gds_format_string(quote_xml(self.RatingStandardName).encode(ExternalEncoding), input_name='RatingStandardName'), namespace_))
        if self.MinimumScore is not None:
            showIndent(outfile, level)
            outfile.write('<%sMinimumScore>%s</%sMinimumScore>\n' % (namespace_, self.gds_format_integer(self.MinimumScore, input_name='MinimumScore'), namespace_))
        if self.MaximumScore is not None:
            showIndent(outfile, level)
            outfile.write('<%sMaximumScore>%s</%sMaximumScore>\n' % (namespace_, self.gds_format_integer(self.MaximumScore, input_name='MaximumScore'), namespace_))
    def hasContent_(self):
        if (
            self.RatingStandardName is not None or
            self.MinimumScore is not None or
            self.MaximumScore is not None or
            super(AssessmentRatingStandard, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AssessmentRatingStandard'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AssessmentRatingStandard, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AssessmentRatingStandard, self).exportLiteralChildren(outfile, level, name_)
        if self.RatingStandardName is not None:
            showIndent(outfile, level)
            outfile.write('RatingStandardName=%s,\n' % quote_python(self.RatingStandardName).encode(ExternalEncoding))
        if self.MinimumScore is not None:
            showIndent(outfile, level)
            outfile.write('MinimumScore=%d,\n' % self.MinimumScore)
        if self.MaximumScore is not None:
            showIndent(outfile, level)
            outfile.write('MaximumScore=%d,\n' % self.MaximumScore)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AssessmentRatingStandard, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RatingStandardName':
            RatingStandardName_ = child_.text
            RatingStandardName_ = re_.sub(String_cleanup_pat_, " ", RatingStandardName_).strip()
            RatingStandardName_ = self.gds_validate_string(RatingStandardName_, node, 'RatingStandardName')
            self.RatingStandardName = RatingStandardName_
            self.validate_RatingStandardNameType(self.RatingStandardName)    # validate type RatingStandardNameType
        elif nodeName_ == 'MinimumScore':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MinimumScore')
            self.MinimumScore = ival_
        elif nodeName_ == 'MaximumScore':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MaximumScore')
            self.MaximumScore = ival_
        super(AssessmentRatingStandard, self).buildChildren(child_, node, nodeName_, True)
# end class AssessmentRatingStandard


class AssessmentItem(ComplexObjectType):
    """One of many single measures that make up an assessment."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, IdentificationCode=None, ItemCategory=None, MaxRawScore=None, CorrectResponse=None, StudentExpectationReference=None, Nomenclature=None):
        super(AssessmentItem, self).__init__(id, )
        self.IdentificationCode = IdentificationCode
        self.ItemCategory = ItemCategory
        self.MaxRawScore = MaxRawScore
        self.CorrectResponse = CorrectResponse
        if StudentExpectationReference is None:
            self.StudentExpectationReference = []
        else:
            self.StudentExpectationReference = StudentExpectationReference
        self.Nomenclature = Nomenclature
    def factory(*args_, **kwargs_):
        if AssessmentItem.subclass:
            return AssessmentItem.subclass(*args_, **kwargs_)
        else:
            return AssessmentItem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IdentificationCode(self): return self.IdentificationCode
    def set_IdentificationCode(self, IdentificationCode): self.IdentificationCode = IdentificationCode
    def validate_IdentificationCode(self, value):
        # Validate type IdentificationCode, a restriction on xs:string.
        pass
    def get_ItemCategory(self): return self.ItemCategory
    def set_ItemCategory(self, ItemCategory): self.ItemCategory = ItemCategory
    def validate_ItemCategoryType(self, value):
        # Validate type ItemCategoryType, a restriction on xs:token.
        pass
    def get_MaxRawScore(self): return self.MaxRawScore
    def set_MaxRawScore(self, MaxRawScore): self.MaxRawScore = MaxRawScore
    def get_CorrectResponse(self): return self.CorrectResponse
    def set_CorrectResponse(self, CorrectResponse): self.CorrectResponse = CorrectResponse
    def validate_CorrectResponse(self, value):
        # Validate type CorrectResponse, a restriction on xs:string.
        pass
    def get_StudentExpectationReference(self): return self.StudentExpectationReference
    def set_StudentExpectationReference(self, StudentExpectationReference): self.StudentExpectationReference = StudentExpectationReference
    def add_StudentExpectationReference(self, value): self.StudentExpectationReference.append(value)
    def insert_StudentExpectationReference(self, index, value): self.StudentExpectationReference[index] = value
    def get_Nomenclature(self): return self.Nomenclature
    def set_Nomenclature(self, Nomenclature): self.Nomenclature = Nomenclature
    def validate_Nomenclature(self, value):
        # Validate type Nomenclature, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='AssessmentItem', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssessmentItem')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AssessmentItem'):
        super(AssessmentItem, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AssessmentItem')
    def exportChildren(self, outfile, level, namespace_='', name_='AssessmentItem', fromsubclass_=False):
        super(AssessmentItem, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.IdentificationCode is not None:
            showIndent(outfile, level)
            outfile.write('<%sIdentificationCode>%s</%sIdentificationCode>\n' % (namespace_, self.gds_format_string(quote_xml(self.IdentificationCode).encode(ExternalEncoding), input_name='IdentificationCode'), namespace_))
        if self.ItemCategory is not None:
            showIndent(outfile, level)
            outfile.write('<%sItemCategory>%s</%sItemCategory>\n' % (namespace_, self.gds_format_string(quote_xml(self.ItemCategory).encode(ExternalEncoding), input_name='ItemCategory'), namespace_))
        if self.MaxRawScore is not None:
            showIndent(outfile, level)
            outfile.write('<%sMaxRawScore>%s</%sMaxRawScore>\n' % (namespace_, self.gds_format_integer(self.MaxRawScore, input_name='MaxRawScore'), namespace_))
        if self.CorrectResponse is not None:
            showIndent(outfile, level)
            outfile.write('<%sCorrectResponse>%s</%sCorrectResponse>\n' % (namespace_, self.gds_format_string(quote_xml(self.CorrectResponse).encode(ExternalEncoding), input_name='CorrectResponse'), namespace_))
        for StudentExpectationReference_ in self.StudentExpectationReference:
            StudentExpectationReference_.export(outfile, level, namespace_, name_='StudentExpectationReference')
        if self.Nomenclature is not None:
            showIndent(outfile, level)
            outfile.write('<%sNomenclature>%s</%sNomenclature>\n' % (namespace_, self.gds_format_string(quote_xml(self.Nomenclature).encode(ExternalEncoding), input_name='Nomenclature'), namespace_))
    def hasContent_(self):
        if (
            self.IdentificationCode is not None or
            self.ItemCategory is not None or
            self.MaxRawScore is not None or
            self.CorrectResponse is not None or
            self.StudentExpectationReference or
            self.Nomenclature is not None or
            super(AssessmentItem, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AssessmentItem'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AssessmentItem, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AssessmentItem, self).exportLiteralChildren(outfile, level, name_)
        if self.IdentificationCode is not None:
            showIndent(outfile, level)
            outfile.write('IdentificationCode=%s,\n' % quote_python(self.IdentificationCode).encode(ExternalEncoding))
        if self.ItemCategory is not None:
            showIndent(outfile, level)
            outfile.write('ItemCategory=%s,\n' % quote_python(self.ItemCategory).encode(ExternalEncoding))
        if self.MaxRawScore is not None:
            showIndent(outfile, level)
            outfile.write('MaxRawScore=%d,\n' % self.MaxRawScore)
        if self.CorrectResponse is not None:
            showIndent(outfile, level)
            outfile.write('CorrectResponse=%s,\n' % quote_python(self.CorrectResponse).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('StudentExpectationReference=[\n')
        level += 1
        for StudentExpectationReference_ in self.StudentExpectationReference:
            showIndent(outfile, level)
            outfile.write('model_.StudentExpectationReferenceType(\n')
            StudentExpectationReference_.exportLiteral(outfile, level, name_='StudentExpectationReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Nomenclature is not None:
            showIndent(outfile, level)
            outfile.write('Nomenclature=%s,\n' % quote_python(self.Nomenclature).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AssessmentItem, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IdentificationCode':
            IdentificationCode_ = child_.text
            IdentificationCode_ = self.gds_validate_string(IdentificationCode_, node, 'IdentificationCode')
            self.IdentificationCode = IdentificationCode_
            self.validate_IdentificationCode(self.IdentificationCode)    # validate type IdentificationCode
        elif nodeName_ == 'ItemCategory':
            ItemCategory_ = child_.text
            ItemCategory_ = re_.sub(String_cleanup_pat_, " ", ItemCategory_).strip()
            ItemCategory_ = self.gds_validate_string(ItemCategory_, node, 'ItemCategory')
            self.ItemCategory = ItemCategory_
            self.validate_ItemCategoryType(self.ItemCategory)    # validate type ItemCategoryType
        elif nodeName_ == 'MaxRawScore':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MaxRawScore')
            self.MaxRawScore = ival_
        elif nodeName_ == 'CorrectResponse':
            CorrectResponse_ = child_.text
            CorrectResponse_ = self.gds_validate_string(CorrectResponse_, node, 'CorrectResponse')
            self.CorrectResponse = CorrectResponse_
            self.validate_CorrectResponse(self.CorrectResponse)    # validate type CorrectResponse
        elif nodeName_ == 'StudentExpectationReference':
            obj_ = StudentExpectationReferenceType.factory()
            obj_.build(child_)
            self.StudentExpectationReference.append(obj_)
        elif nodeName_ == 'Nomenclature':
            Nomenclature_ = child_.text
            Nomenclature_ = self.gds_validate_string(Nomenclature_, node, 'Nomenclature')
            self.Nomenclature = Nomenclature_
            self.validate_Nomenclature(self.Nomenclature)    # validate type Nomenclature
        super(AssessmentItem, self).buildChildren(child_, node, nodeName_, True)
# end class AssessmentItem


class AssessmentFamily(ComplexObjectType):
    """A logical grouping or association of assessments that share a common
    purpose, heritage, or content standard. There may be hierarchies
    of Assessment Families."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, AssessmentFamilyTitle=None, AssessmentFamilyIdentificationCode=None, AssessmentCategory=None, AcademicSubject=None, GradeLevelAssessed=None, LowestGradeLevelAssessed=None, ContentStandard=None, Version=None, RevisionDate=None, AssessmentFamilyReference=None, Nomenclature=None):
        super(AssessmentFamily, self).__init__(id, )
        self.AssessmentFamilyTitle = AssessmentFamilyTitle
        if AssessmentFamilyIdentificationCode is None:
            self.AssessmentFamilyIdentificationCode = []
        else:
            self.AssessmentFamilyIdentificationCode = AssessmentFamilyIdentificationCode
        self.AssessmentCategory = AssessmentCategory
        self.AcademicSubject = AcademicSubject
        self.GradeLevelAssessed = GradeLevelAssessed
        self.LowestGradeLevelAssessed = LowestGradeLevelAssessed
        self.ContentStandard = ContentStandard
        self.Version = Version
        self.RevisionDate = RevisionDate
        self.AssessmentFamilyReference = AssessmentFamilyReference
        self.Nomenclature = Nomenclature
    def factory(*args_, **kwargs_):
        if AssessmentFamily.subclass:
            return AssessmentFamily.subclass(*args_, **kwargs_)
        else:
            return AssessmentFamily(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AssessmentFamilyTitle(self): return self.AssessmentFamilyTitle
    def set_AssessmentFamilyTitle(self, AssessmentFamilyTitle): self.AssessmentFamilyTitle = AssessmentFamilyTitle
    def validate_AssessmentTitle(self, value):
        # Validate type AssessmentTitle, a restriction on xs:string.
        pass
    def get_AssessmentFamilyIdentificationCode(self): return self.AssessmentFamilyIdentificationCode
    def set_AssessmentFamilyIdentificationCode(self, AssessmentFamilyIdentificationCode): self.AssessmentFamilyIdentificationCode = AssessmentFamilyIdentificationCode
    def add_AssessmentFamilyIdentificationCode(self, value): self.AssessmentFamilyIdentificationCode.append(value)
    def insert_AssessmentFamilyIdentificationCode(self, index, value): self.AssessmentFamilyIdentificationCode[index] = value
    def get_AssessmentCategory(self): return self.AssessmentCategory
    def set_AssessmentCategory(self, AssessmentCategory): self.AssessmentCategory = AssessmentCategory
    def validate_AssessmentCategoryType(self, value):
        # Validate type AssessmentCategoryType, a restriction on xs:token.
        pass
    def get_AcademicSubject(self): return self.AcademicSubject
    def set_AcademicSubject(self, AcademicSubject): self.AcademicSubject = AcademicSubject
    def validate_AcademicSubjectType(self, value):
        # Validate type AcademicSubjectType, a restriction on xs:token.
        pass
    def get_GradeLevelAssessed(self): return self.GradeLevelAssessed
    def set_GradeLevelAssessed(self, GradeLevelAssessed): self.GradeLevelAssessed = GradeLevelAssessed
    def validate_GradeLevelType(self, value):
        # Validate type GradeLevelType, a restriction on xs:token.
        pass
    def get_LowestGradeLevelAssessed(self): return self.LowestGradeLevelAssessed
    def set_LowestGradeLevelAssessed(self, LowestGradeLevelAssessed): self.LowestGradeLevelAssessed = LowestGradeLevelAssessed
    def get_ContentStandard(self): return self.ContentStandard
    def set_ContentStandard(self, ContentStandard): self.ContentStandard = ContentStandard
    def validate_ContentStandardType(self, value):
        # Validate type ContentStandardType, a restriction on xs:token.
        pass
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def validate_Version(self, value):
        # Validate type Version, a restriction on xs:int.
        pass
    def get_RevisionDate(self): return self.RevisionDate
    def set_RevisionDate(self, RevisionDate): self.RevisionDate = RevisionDate
    def get_AssessmentFamilyReference(self): return self.AssessmentFamilyReference
    def set_AssessmentFamilyReference(self, AssessmentFamilyReference): self.AssessmentFamilyReference = AssessmentFamilyReference
    def get_Nomenclature(self): return self.Nomenclature
    def set_Nomenclature(self, Nomenclature): self.Nomenclature = Nomenclature
    def validate_Nomenclature(self, value):
        # Validate type Nomenclature, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='AssessmentFamily', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssessmentFamily')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AssessmentFamily'):
        super(AssessmentFamily, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AssessmentFamily')
    def exportChildren(self, outfile, level, namespace_='', name_='AssessmentFamily', fromsubclass_=False):
        super(AssessmentFamily, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.AssessmentFamilyTitle is not None:
            showIndent(outfile, level)
            outfile.write('<%sAssessmentFamilyTitle>%s</%sAssessmentFamilyTitle>\n' % (namespace_, self.gds_format_string(quote_xml(self.AssessmentFamilyTitle).encode(ExternalEncoding), input_name='AssessmentFamilyTitle'), namespace_))
        for AssessmentFamilyIdentificationCode_ in self.AssessmentFamilyIdentificationCode:
            AssessmentFamilyIdentificationCode_.export(outfile, level, namespace_, name_='AssessmentFamilyIdentificationCode')
        if self.AssessmentCategory is not None:
            showIndent(outfile, level)
            outfile.write('<%sAssessmentCategory>%s</%sAssessmentCategory>\n' % (namespace_, self.gds_format_string(quote_xml(self.AssessmentCategory).encode(ExternalEncoding), input_name='AssessmentCategory'), namespace_))
        if self.AcademicSubject is not None:
            showIndent(outfile, level)
            outfile.write('<%sAcademicSubject>%s</%sAcademicSubject>\n' % (namespace_, self.gds_format_string(quote_xml(self.AcademicSubject).encode(ExternalEncoding), input_name='AcademicSubject'), namespace_))
        if self.GradeLevelAssessed is not None:
            showIndent(outfile, level)
            outfile.write('<%sGradeLevelAssessed>%s</%sGradeLevelAssessed>\n' % (namespace_, self.gds_format_string(quote_xml(self.GradeLevelAssessed).encode(ExternalEncoding), input_name='GradeLevelAssessed'), namespace_))
        if self.LowestGradeLevelAssessed is not None:
            showIndent(outfile, level)
            outfile.write('<%sLowestGradeLevelAssessed>%s</%sLowestGradeLevelAssessed>\n' % (namespace_, self.gds_format_string(quote_xml(self.LowestGradeLevelAssessed).encode(ExternalEncoding), input_name='LowestGradeLevelAssessed'), namespace_))
        if self.ContentStandard is not None:
            showIndent(outfile, level)
            outfile.write('<%sContentStandard>%s</%sContentStandard>\n' % (namespace_, self.gds_format_string(quote_xml(self.ContentStandard).encode(ExternalEncoding), input_name='ContentStandard'), namespace_))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('<%sVersion>%s</%sVersion>\n' % (namespace_, self.gds_format_integer(self.Version, input_name='Version'), namespace_))
        if self.RevisionDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sRevisionDate>%s</%sRevisionDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.RevisionDate).encode(ExternalEncoding), input_name='RevisionDate'), namespace_))
        if self.AssessmentFamilyReference:
            self.AssessmentFamilyReference.export(outfile, level, namespace_, name_='AssessmentFamilyReference')
        if self.Nomenclature is not None:
            showIndent(outfile, level)
            outfile.write('<%sNomenclature>%s</%sNomenclature>\n' % (namespace_, self.gds_format_string(quote_xml(self.Nomenclature).encode(ExternalEncoding), input_name='Nomenclature'), namespace_))
    def hasContent_(self):
        if (
            self.AssessmentFamilyTitle is not None or
            self.AssessmentFamilyIdentificationCode or
            self.AssessmentCategory is not None or
            self.AcademicSubject is not None or
            self.GradeLevelAssessed is not None or
            self.LowestGradeLevelAssessed is not None or
            self.ContentStandard is not None or
            self.Version is not None or
            self.RevisionDate is not None or
            self.AssessmentFamilyReference is not None or
            self.Nomenclature is not None or
            super(AssessmentFamily, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AssessmentFamily'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AssessmentFamily, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AssessmentFamily, self).exportLiteralChildren(outfile, level, name_)
        if self.AssessmentFamilyTitle is not None:
            showIndent(outfile, level)
            outfile.write('AssessmentFamilyTitle=%s,\n' % quote_python(self.AssessmentFamilyTitle).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('AssessmentFamilyIdentificationCode=[\n')
        level += 1
        for AssessmentFamilyIdentificationCode_ in self.AssessmentFamilyIdentificationCode:
            showIndent(outfile, level)
            outfile.write('model_.AssessmentIdentificationCode(\n')
            AssessmentFamilyIdentificationCode_.exportLiteral(outfile, level, name_='AssessmentIdentificationCode')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.AssessmentCategory is not None:
            showIndent(outfile, level)
            outfile.write('AssessmentCategory=%s,\n' % quote_python(self.AssessmentCategory).encode(ExternalEncoding))
        if self.AcademicSubject is not None:
            showIndent(outfile, level)
            outfile.write('AcademicSubject=%s,\n' % quote_python(self.AcademicSubject).encode(ExternalEncoding))
        if self.GradeLevelAssessed is not None:
            showIndent(outfile, level)
            outfile.write('GradeLevelAssessed=%s,\n' % quote_python(self.GradeLevelAssessed).encode(ExternalEncoding))
        if self.LowestGradeLevelAssessed is not None:
            showIndent(outfile, level)
            outfile.write('LowestGradeLevelAssessed=%s,\n' % quote_python(self.LowestGradeLevelAssessed).encode(ExternalEncoding))
        if self.ContentStandard is not None:
            showIndent(outfile, level)
            outfile.write('ContentStandard=%s,\n' % quote_python(self.ContentStandard).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%d,\n' % self.Version)
        if self.RevisionDate is not None:
            showIndent(outfile, level)
            outfile.write('RevisionDate=%s,\n' % quote_python(self.RevisionDate).encode(ExternalEncoding))
        if self.AssessmentFamilyReference is not None:
            showIndent(outfile, level)
            outfile.write('AssessmentFamilyReference=model_.AssessmentFamilyReferenceType(\n')
            self.AssessmentFamilyReference.exportLiteral(outfile, level, name_='AssessmentFamilyReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Nomenclature is not None:
            showIndent(outfile, level)
            outfile.write('Nomenclature=%s,\n' % quote_python(self.Nomenclature).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AssessmentFamily, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AssessmentFamilyTitle':
            AssessmentFamilyTitle_ = child_.text
            AssessmentFamilyTitle_ = self.gds_validate_string(AssessmentFamilyTitle_, node, 'AssessmentFamilyTitle')
            self.AssessmentFamilyTitle = AssessmentFamilyTitle_
            self.validate_AssessmentTitle(self.AssessmentFamilyTitle)    # validate type AssessmentTitle
        elif nodeName_ == 'AssessmentFamilyIdentificationCode':
            obj_ = AssessmentIdentificationCode.factory()
            obj_.build(child_)
            self.AssessmentFamilyIdentificationCode.append(obj_)
        elif nodeName_ == 'AssessmentCategory':
            AssessmentCategory_ = child_.text
            AssessmentCategory_ = re_.sub(String_cleanup_pat_, " ", AssessmentCategory_).strip()
            AssessmentCategory_ = self.gds_validate_string(AssessmentCategory_, node, 'AssessmentCategory')
            self.AssessmentCategory = AssessmentCategory_
            self.validate_AssessmentCategoryType(self.AssessmentCategory)    # validate type AssessmentCategoryType
        elif nodeName_ == 'AcademicSubject':
            AcademicSubject_ = child_.text
            AcademicSubject_ = re_.sub(String_cleanup_pat_, " ", AcademicSubject_).strip()
            AcademicSubject_ = self.gds_validate_string(AcademicSubject_, node, 'AcademicSubject')
            self.AcademicSubject = AcademicSubject_
            self.validate_AcademicSubjectType(self.AcademicSubject)    # validate type AcademicSubjectType
        elif nodeName_ == 'GradeLevelAssessed':
            GradeLevelAssessed_ = child_.text
            GradeLevelAssessed_ = re_.sub(String_cleanup_pat_, " ", GradeLevelAssessed_).strip()
            GradeLevelAssessed_ = self.gds_validate_string(GradeLevelAssessed_, node, 'GradeLevelAssessed')
            self.GradeLevelAssessed = GradeLevelAssessed_
            self.validate_GradeLevelType(self.GradeLevelAssessed)    # validate type GradeLevelType
        elif nodeName_ == 'LowestGradeLevelAssessed':
            LowestGradeLevelAssessed_ = child_.text
            LowestGradeLevelAssessed_ = re_.sub(String_cleanup_pat_, " ", LowestGradeLevelAssessed_).strip()
            LowestGradeLevelAssessed_ = self.gds_validate_string(LowestGradeLevelAssessed_, node, 'LowestGradeLevelAssessed')
            self.LowestGradeLevelAssessed = LowestGradeLevelAssessed_
            self.validate_GradeLevelType(self.LowestGradeLevelAssessed)    # validate type GradeLevelType
        elif nodeName_ == 'ContentStandard':
            ContentStandard_ = child_.text
            ContentStandard_ = re_.sub(String_cleanup_pat_, " ", ContentStandard_).strip()
            ContentStandard_ = self.gds_validate_string(ContentStandard_, node, 'ContentStandard')
            self.ContentStandard = ContentStandard_
            self.validate_ContentStandardType(self.ContentStandard)    # validate type ContentStandardType
        elif nodeName_ == 'Version':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Version')
            self.Version = ival_
            self.validate_Version(self.Version)    # validate type Version
        elif nodeName_ == 'RevisionDate':
            RevisionDate_ = child_.text
            RevisionDate_ = self.gds_validate_string(RevisionDate_, node, 'RevisionDate')
            self.RevisionDate = RevisionDate_
        elif nodeName_ == 'AssessmentFamilyReference':
            obj_ = AssessmentFamilyReferenceType.factory()
            obj_.build(child_)
            self.set_AssessmentFamilyReference(obj_)
        elif nodeName_ == 'Nomenclature':
            Nomenclature_ = child_.text
            Nomenclature_ = self.gds_validate_string(Nomenclature_, node, 'Nomenclature')
            self.Nomenclature = Nomenclature_
            self.validate_Nomenclature(self.Nomenclature)    # validate type Nomenclature
        super(AssessmentFamily, self).buildChildren(child_, node, nodeName_, True)
# end class AssessmentFamily


class Assessment(ComplexObjectType):
    """A tool, instrument, process, or exhibition composed of a systematic
    sampling of behavior for measuring a student's competence,
    knowledge, skills or behavior. An assessment can be used to
    measure differences in individuals or groups and changes in
    performance from one occasion to the next."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, AssessmentTitle=None, AssessmentIdentificationCode=None, AssessmentCategory=None, AcademicSubject=None, GradeLevelAssessed=None, LowestGradeLevelAssessed=None, TimeOfYear=None, ContentStandard=None, Version=None, RevisionDate=None, MaxRawScore=None, AssessmentItemReference=None, AssessmentRatingStandardReference=None, ObjectiveAssessmentReference=None, AssessmentFamilyReference=None, Nomenclature=None):
        super(Assessment, self).__init__(id, )
        self.AssessmentTitle = AssessmentTitle
        if AssessmentIdentificationCode is None:
            self.AssessmentIdentificationCode = []
        else:
            self.AssessmentIdentificationCode = AssessmentIdentificationCode
        self.AssessmentCategory = AssessmentCategory
        self.AcademicSubject = AcademicSubject
        self.GradeLevelAssessed = GradeLevelAssessed
        self.LowestGradeLevelAssessed = LowestGradeLevelAssessed
        self.TimeOfYear = TimeOfYear
        self.ContentStandard = ContentStandard
        self.Version = Version
        self.RevisionDate = RevisionDate
        self.MaxRawScore = MaxRawScore
        if AssessmentItemReference is None:
            self.AssessmentItemReference = []
        else:
            self.AssessmentItemReference = AssessmentItemReference
        if AssessmentRatingStandardReference is None:
            self.AssessmentRatingStandardReference = []
        else:
            self.AssessmentRatingStandardReference = AssessmentRatingStandardReference
        if ObjectiveAssessmentReference is None:
            self.ObjectiveAssessmentReference = []
        else:
            self.ObjectiveAssessmentReference = ObjectiveAssessmentReference
        self.AssessmentFamilyReference = AssessmentFamilyReference
        self.Nomenclature = Nomenclature
    def factory(*args_, **kwargs_):
        if Assessment.subclass:
            return Assessment.subclass(*args_, **kwargs_)
        else:
            return Assessment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AssessmentTitle(self): return self.AssessmentTitle
    def set_AssessmentTitle(self, AssessmentTitle): self.AssessmentTitle = AssessmentTitle
    def validate_AssessmentTitle(self, value):
        # Validate type AssessmentTitle, a restriction on xs:string.
        pass
    def get_AssessmentIdentificationCode(self): return self.AssessmentIdentificationCode
    def set_AssessmentIdentificationCode(self, AssessmentIdentificationCode): self.AssessmentIdentificationCode = AssessmentIdentificationCode
    def add_AssessmentIdentificationCode(self, value): self.AssessmentIdentificationCode.append(value)
    def insert_AssessmentIdentificationCode(self, index, value): self.AssessmentIdentificationCode[index] = value
    def get_AssessmentCategory(self): return self.AssessmentCategory
    def set_AssessmentCategory(self, AssessmentCategory): self.AssessmentCategory = AssessmentCategory
    def validate_AssessmentCategoryType(self, value):
        # Validate type AssessmentCategoryType, a restriction on xs:token.
        pass
    def get_AcademicSubject(self): return self.AcademicSubject
    def set_AcademicSubject(self, AcademicSubject): self.AcademicSubject = AcademicSubject
    def validate_AcademicSubjectType(self, value):
        # Validate type AcademicSubjectType, a restriction on xs:token.
        pass
    def get_GradeLevelAssessed(self): return self.GradeLevelAssessed
    def set_GradeLevelAssessed(self, GradeLevelAssessed): self.GradeLevelAssessed = GradeLevelAssessed
    def validate_GradeLevelType(self, value):
        # Validate type GradeLevelType, a restriction on xs:token.
        pass
    def get_LowestGradeLevelAssessed(self): return self.LowestGradeLevelAssessed
    def set_LowestGradeLevelAssessed(self, LowestGradeLevelAssessed): self.LowestGradeLevelAssessed = LowestGradeLevelAssessed
    def get_TimeOfYear(self): return self.TimeOfYear
    def set_TimeOfYear(self, TimeOfYear): self.TimeOfYear = TimeOfYear
    def validate_TimeOfYearType(self, value):
        # Validate type TimeOfYearType, a restriction on xs:token.
        pass
    def get_ContentStandard(self): return self.ContentStandard
    def set_ContentStandard(self, ContentStandard): self.ContentStandard = ContentStandard
    def validate_ContentStandardType(self, value):
        # Validate type ContentStandardType, a restriction on xs:token.
        pass
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def validate_Version(self, value):
        # Validate type Version, a restriction on xs:int.
        pass
    def get_RevisionDate(self): return self.RevisionDate
    def set_RevisionDate(self, RevisionDate): self.RevisionDate = RevisionDate
    def get_MaxRawScore(self): return self.MaxRawScore
    def set_MaxRawScore(self, MaxRawScore): self.MaxRawScore = MaxRawScore
    def get_AssessmentItemReference(self): return self.AssessmentItemReference
    def set_AssessmentItemReference(self, AssessmentItemReference): self.AssessmentItemReference = AssessmentItemReference
    def add_AssessmentItemReference(self, value): self.AssessmentItemReference.append(value)
    def insert_AssessmentItemReference(self, index, value): self.AssessmentItemReference[index] = value
    def get_AssessmentRatingStandardReference(self): return self.AssessmentRatingStandardReference
    def set_AssessmentRatingStandardReference(self, AssessmentRatingStandardReference): self.AssessmentRatingStandardReference = AssessmentRatingStandardReference
    def add_AssessmentRatingStandardReference(self, value): self.AssessmentRatingStandardReference.append(value)
    def insert_AssessmentRatingStandardReference(self, index, value): self.AssessmentRatingStandardReference[index] = value
    def get_ObjectiveAssessmentReference(self): return self.ObjectiveAssessmentReference
    def set_ObjectiveAssessmentReference(self, ObjectiveAssessmentReference): self.ObjectiveAssessmentReference = ObjectiveAssessmentReference
    def add_ObjectiveAssessmentReference(self, value): self.ObjectiveAssessmentReference.append(value)
    def insert_ObjectiveAssessmentReference(self, index, value): self.ObjectiveAssessmentReference[index] = value
    def get_AssessmentFamilyReference(self): return self.AssessmentFamilyReference
    def set_AssessmentFamilyReference(self, AssessmentFamilyReference): self.AssessmentFamilyReference = AssessmentFamilyReference
    def get_Nomenclature(self): return self.Nomenclature
    def set_Nomenclature(self, Nomenclature): self.Nomenclature = Nomenclature
    def validate_Nomenclature(self, value):
        # Validate type Nomenclature, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='Assessment', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Assessment')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Assessment'):
        super(Assessment, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Assessment')
    def exportChildren(self, outfile, level, namespace_='', name_='Assessment', fromsubclass_=False):
        super(Assessment, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.AssessmentTitle is not None:
            showIndent(outfile, level)
            outfile.write('<%sAssessmentTitle>%s</%sAssessmentTitle>\n' % (namespace_, self.gds_format_string(quote_xml(self.AssessmentTitle).encode(ExternalEncoding), input_name='AssessmentTitle'), namespace_))
        for AssessmentIdentificationCode_ in self.AssessmentIdentificationCode:
            AssessmentIdentificationCode_.export(outfile, level, namespace_, name_='AssessmentIdentificationCode')
        if self.AssessmentCategory is not None:
            showIndent(outfile, level)
            outfile.write('<%sAssessmentCategory>%s</%sAssessmentCategory>\n' % (namespace_, self.gds_format_string(quote_xml(self.AssessmentCategory).encode(ExternalEncoding), input_name='AssessmentCategory'), namespace_))
        if self.AcademicSubject is not None:
            showIndent(outfile, level)
            outfile.write('<%sAcademicSubject>%s</%sAcademicSubject>\n' % (namespace_, self.gds_format_string(quote_xml(self.AcademicSubject).encode(ExternalEncoding), input_name='AcademicSubject'), namespace_))
        if self.GradeLevelAssessed is not None:
            showIndent(outfile, level)
            outfile.write('<%sGradeLevelAssessed>%s</%sGradeLevelAssessed>\n' % (namespace_, self.gds_format_string(quote_xml(self.GradeLevelAssessed).encode(ExternalEncoding), input_name='GradeLevelAssessed'), namespace_))
        if self.LowestGradeLevelAssessed is not None:
            showIndent(outfile, level)
            outfile.write('<%sLowestGradeLevelAssessed>%s</%sLowestGradeLevelAssessed>\n' % (namespace_, self.gds_format_string(quote_xml(self.LowestGradeLevelAssessed).encode(ExternalEncoding), input_name='LowestGradeLevelAssessed'), namespace_))
        if self.TimeOfYear is not None:
            showIndent(outfile, level)
            outfile.write('<%sTimeOfYear>%s</%sTimeOfYear>\n' % (namespace_, self.gds_format_string(quote_xml(self.TimeOfYear).encode(ExternalEncoding), input_name='TimeOfYear'), namespace_))
        if self.ContentStandard is not None:
            showIndent(outfile, level)
            outfile.write('<%sContentStandard>%s</%sContentStandard>\n' % (namespace_, self.gds_format_string(quote_xml(self.ContentStandard).encode(ExternalEncoding), input_name='ContentStandard'), namespace_))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('<%sVersion>%s</%sVersion>\n' % (namespace_, self.gds_format_integer(self.Version, input_name='Version'), namespace_))
        if self.RevisionDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sRevisionDate>%s</%sRevisionDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.RevisionDate).encode(ExternalEncoding), input_name='RevisionDate'), namespace_))
        if self.MaxRawScore is not None:
            showIndent(outfile, level)
            outfile.write('<%sMaxRawScore>%s</%sMaxRawScore>\n' % (namespace_, self.gds_format_integer(self.MaxRawScore, input_name='MaxRawScore'), namespace_))
        for AssessmentItemReference_ in self.AssessmentItemReference:
            AssessmentItemReference_.export(outfile, level, namespace_, name_='AssessmentItemReference')
        for AssessmentRatingStandardReference_ in self.AssessmentRatingStandardReference:
            AssessmentRatingStandardReference_.export(outfile, level, namespace_, name_='AssessmentRatingStandardReference')
        for ObjectiveAssessmentReference_ in self.ObjectiveAssessmentReference:
            ObjectiveAssessmentReference_.export(outfile, level, namespace_, name_='ObjectiveAssessmentReference')
        if self.AssessmentFamilyReference:
            self.AssessmentFamilyReference.export(outfile, level, namespace_, name_='AssessmentFamilyReference')
        if self.Nomenclature is not None:
            showIndent(outfile, level)
            outfile.write('<%sNomenclature>%s</%sNomenclature>\n' % (namespace_, self.gds_format_string(quote_xml(self.Nomenclature).encode(ExternalEncoding), input_name='Nomenclature'), namespace_))
    def hasContent_(self):
        if (
            self.AssessmentTitle is not None or
            self.AssessmentIdentificationCode or
            self.AssessmentCategory is not None or
            self.AcademicSubject is not None or
            self.GradeLevelAssessed is not None or
            self.LowestGradeLevelAssessed is not None or
            self.TimeOfYear is not None or
            self.ContentStandard is not None or
            self.Version is not None or
            self.RevisionDate is not None or
            self.MaxRawScore is not None or
            self.AssessmentItemReference or
            self.AssessmentRatingStandardReference or
            self.ObjectiveAssessmentReference or
            self.AssessmentFamilyReference is not None or
            self.Nomenclature is not None or
            super(Assessment, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Assessment'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Assessment, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Assessment, self).exportLiteralChildren(outfile, level, name_)
        if self.AssessmentTitle is not None:
            showIndent(outfile, level)
            outfile.write('AssessmentTitle=%s,\n' % quote_python(self.AssessmentTitle).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('AssessmentIdentificationCode=[\n')
        level += 1
        for AssessmentIdentificationCode_ in self.AssessmentIdentificationCode:
            showIndent(outfile, level)
            outfile.write('model_.AssessmentIdentificationCode(\n')
            AssessmentIdentificationCode_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.AssessmentCategory is not None:
            showIndent(outfile, level)
            outfile.write('AssessmentCategory=%s,\n' % quote_python(self.AssessmentCategory).encode(ExternalEncoding))
        if self.AcademicSubject is not None:
            showIndent(outfile, level)
            outfile.write('AcademicSubject=%s,\n' % quote_python(self.AcademicSubject).encode(ExternalEncoding))
        if self.GradeLevelAssessed is not None:
            showIndent(outfile, level)
            outfile.write('GradeLevelAssessed=%s,\n' % quote_python(self.GradeLevelAssessed).encode(ExternalEncoding))
        if self.LowestGradeLevelAssessed is not None:
            showIndent(outfile, level)
            outfile.write('LowestGradeLevelAssessed=%s,\n' % quote_python(self.LowestGradeLevelAssessed).encode(ExternalEncoding))
        if self.TimeOfYear is not None:
            showIndent(outfile, level)
            outfile.write('TimeOfYear=%s,\n' % quote_python(self.TimeOfYear).encode(ExternalEncoding))
        if self.ContentStandard is not None:
            showIndent(outfile, level)
            outfile.write('ContentStandard=%s,\n' % quote_python(self.ContentStandard).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%d,\n' % self.Version)
        if self.RevisionDate is not None:
            showIndent(outfile, level)
            outfile.write('RevisionDate=%s,\n' % quote_python(self.RevisionDate).encode(ExternalEncoding))
        if self.MaxRawScore is not None:
            showIndent(outfile, level)
            outfile.write('MaxRawScore=%d,\n' % self.MaxRawScore)
        showIndent(outfile, level)
        outfile.write('AssessmentItemReference=[\n')
        level += 1
        for AssessmentItemReference_ in self.AssessmentItemReference:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            AssessmentItemReference_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AssessmentRatingStandardReference=[\n')
        level += 1
        for AssessmentRatingStandardReference_ in self.AssessmentRatingStandardReference:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            AssessmentRatingStandardReference_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ObjectiveAssessmentReference=[\n')
        level += 1
        for ObjectiveAssessmentReference_ in self.ObjectiveAssessmentReference:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            ObjectiveAssessmentReference_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.AssessmentFamilyReference is not None:
            showIndent(outfile, level)
            outfile.write('AssessmentFamilyReference=model_.AssessmentFamilyReferenceType(\n')
            self.AssessmentFamilyReference.exportLiteral(outfile, level, name_='AssessmentFamilyReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Nomenclature is not None:
            showIndent(outfile, level)
            outfile.write('Nomenclature=%s,\n' % quote_python(self.Nomenclature).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Assessment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AssessmentTitle':
            AssessmentTitle_ = child_.text
            AssessmentTitle_ = self.gds_validate_string(AssessmentTitle_, node, 'AssessmentTitle')
            self.AssessmentTitle = AssessmentTitle_
            self.validate_AssessmentTitle(self.AssessmentTitle)    # validate type AssessmentTitle
        elif nodeName_ == 'AssessmentIdentificationCode':
            obj_ = AssessmentIdentificationCode.factory()
            obj_.build(child_)
            self.AssessmentIdentificationCode.append(obj_)
        elif nodeName_ == 'AssessmentCategory':
            AssessmentCategory_ = child_.text
            AssessmentCategory_ = re_.sub(String_cleanup_pat_, " ", AssessmentCategory_).strip()
            AssessmentCategory_ = self.gds_validate_string(AssessmentCategory_, node, 'AssessmentCategory')
            self.AssessmentCategory = AssessmentCategory_
            self.validate_AssessmentCategoryType(self.AssessmentCategory)    # validate type AssessmentCategoryType
        elif nodeName_ == 'AcademicSubject':
            AcademicSubject_ = child_.text
            AcademicSubject_ = re_.sub(String_cleanup_pat_, " ", AcademicSubject_).strip()
            AcademicSubject_ = self.gds_validate_string(AcademicSubject_, node, 'AcademicSubject')
            self.AcademicSubject = AcademicSubject_
            self.validate_AcademicSubjectType(self.AcademicSubject)    # validate type AcademicSubjectType
        elif nodeName_ == 'GradeLevelAssessed':
            GradeLevelAssessed_ = child_.text
            GradeLevelAssessed_ = re_.sub(String_cleanup_pat_, " ", GradeLevelAssessed_).strip()
            GradeLevelAssessed_ = self.gds_validate_string(GradeLevelAssessed_, node, 'GradeLevelAssessed')
            self.GradeLevelAssessed = GradeLevelAssessed_
            self.validate_GradeLevelType(self.GradeLevelAssessed)    # validate type GradeLevelType
        elif nodeName_ == 'LowestGradeLevelAssessed':
            LowestGradeLevelAssessed_ = child_.text
            LowestGradeLevelAssessed_ = re_.sub(String_cleanup_pat_, " ", LowestGradeLevelAssessed_).strip()
            LowestGradeLevelAssessed_ = self.gds_validate_string(LowestGradeLevelAssessed_, node, 'LowestGradeLevelAssessed')
            self.LowestGradeLevelAssessed = LowestGradeLevelAssessed_
            self.validate_GradeLevelType(self.LowestGradeLevelAssessed)    # validate type GradeLevelType
        elif nodeName_ == 'TimeOfYear':
            TimeOfYear_ = child_.text
            TimeOfYear_ = re_.sub(String_cleanup_pat_, " ", TimeOfYear_).strip()
            TimeOfYear_ = self.gds_validate_string(TimeOfYear_, node, 'TimeOfYear')
            self.TimeOfYear = TimeOfYear_
            self.validate_TimeOfYearType(self.TimeOfYear)    # validate type TimeOfYearType
        elif nodeName_ == 'ContentStandard':
            ContentStandard_ = child_.text
            ContentStandard_ = re_.sub(String_cleanup_pat_, " ", ContentStandard_).strip()
            ContentStandard_ = self.gds_validate_string(ContentStandard_, node, 'ContentStandard')
            self.ContentStandard = ContentStandard_
            self.validate_ContentStandardType(self.ContentStandard)    # validate type ContentStandardType
        elif nodeName_ == 'Version':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Version')
            self.Version = ival_
            self.validate_Version(self.Version)    # validate type Version
        elif nodeName_ == 'RevisionDate':
            RevisionDate_ = child_.text
            RevisionDate_ = self.gds_validate_string(RevisionDate_, node, 'RevisionDate')
            self.RevisionDate = RevisionDate_
        elif nodeName_ == 'MaxRawScore':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MaxRawScore')
            self.MaxRawScore = ival_
        elif nodeName_ == 'AssessmentItemReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.AssessmentItemReference.append(obj_)
        elif nodeName_ == 'AssessmentRatingStandardReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.AssessmentRatingStandardReference.append(obj_)
        elif nodeName_ == 'ObjectiveAssessmentReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ObjectiveAssessmentReference.append(obj_)
        elif nodeName_ == 'AssessmentFamilyReference':
            obj_ = AssessmentFamilyReferenceType.factory()
            obj_.build(child_)
            self.set_AssessmentFamilyReference(obj_)
        elif nodeName_ == 'Nomenclature':
            Nomenclature_ = child_.text
            Nomenclature_ = self.gds_validate_string(Nomenclature_, node, 'Nomenclature')
            self.Nomenclature = Nomenclature_
            self.validate_Nomenclature(self.Nomenclature)    # validate type Nomenclature
        super(Assessment, self).buildChildren(child_, node, nodeName_, True)
# end class Assessment


class Actual(ComplexObjectType):
    """This financial entity represents the sum of the financal
    transactions to date relating to a specific account."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, FiscalYear=None, AmountToDate=None, AccountReference=None):
        super(Actual, self).__init__(id, )
        self.FiscalYear = FiscalYear
        self.AmountToDate = AmountToDate
        self.AccountReference = AccountReference
    def factory(*args_, **kwargs_):
        if Actual.subclass:
            return Actual.subclass(*args_, **kwargs_)
        else:
            return Actual(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FiscalYear(self): return self.FiscalYear
    def set_FiscalYear(self, FiscalYear): self.FiscalYear = FiscalYear
    def get_AmountToDate(self): return self.AmountToDate
    def set_AmountToDate(self, AmountToDate): self.AmountToDate = AmountToDate
    def validate_Currency(self, value):
        # Validate type Currency, a restriction on xs:decimal.
        pass
    def get_AccountReference(self): return self.AccountReference
    def set_AccountReference(self, AccountReference): self.AccountReference = AccountReference
    def export(self, outfile, level, namespace_='', name_='Actual', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Actual')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Actual'):
        super(Actual, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Actual')
    def exportChildren(self, outfile, level, namespace_='', name_='Actual', fromsubclass_=False):
        super(Actual, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.FiscalYear is not None:
            showIndent(outfile, level)
            outfile.write('<%sFiscalYear>%s</%sFiscalYear>\n' % (namespace_, self.gds_format_integer(self.FiscalYear, input_name='FiscalYear'), namespace_))
        if self.AmountToDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sAmountToDate>%s</%sAmountToDate>\n' % (namespace_, self.gds_format_float(self.AmountToDate, input_name='AmountToDate'), namespace_))
        if self.AccountReference:
            self.AccountReference.export(outfile, level, namespace_, name_='AccountReference', )
    def hasContent_(self):
        if (
            self.FiscalYear is not None or
            self.AmountToDate is not None or
            self.AccountReference is not None or
            super(Actual, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Actual'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Actual, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Actual, self).exportLiteralChildren(outfile, level, name_)
        if self.FiscalYear is not None:
            showIndent(outfile, level)
            outfile.write('FiscalYear=%d,\n' % self.FiscalYear)
        if self.AmountToDate is not None:
            showIndent(outfile, level)
            outfile.write('AmountToDate=%f,\n' % self.AmountToDate)
        if self.AccountReference is not None:
            showIndent(outfile, level)
            outfile.write('AccountReference=model_.AccountReferenceType(\n')
            self.AccountReference.exportLiteral(outfile, level, name_='AccountReference')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Actual, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FiscalYear':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'FiscalYear')
            self.FiscalYear = ival_
        elif nodeName_ == 'AmountToDate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AmountToDate')
            self.AmountToDate = fval_
            self.validate_Currency(self.AmountToDate)    # validate type Currency
        elif nodeName_ == 'AccountReference':
            obj_ = AccountReferenceType.factory()
            obj_.build(child_)
            self.set_AccountReference(obj_)
        super(Actual, self).buildChildren(child_, node, nodeName_, True)
# end class Actual


class Account(ComplexObjectType):
    """This financial entity represents a funding source combined with its
    purpose and type of transaction. It provides a formal record of
    the debits and credits relating to the specific account."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, Fund=None, Function=None, Object=None, EducationOrganizationReference=None):
        super(Account, self).__init__(id, )
        self.Fund = Fund
        self.Function = Function
        self.Object = Object
        self.EducationOrganizationReference = EducationOrganizationReference
    def factory(*args_, **kwargs_):
        if Account.subclass:
            return Account.subclass(*args_, **kwargs_)
        else:
            return Account(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Fund(self): return self.Fund
    def set_Fund(self, Fund): self.Fund = Fund
    def validate_FundType(self, value):
        # Validate type FundType, a restriction on xs:string.
        pass
    def get_Function(self): return self.Function
    def set_Function(self, Function): self.Function = Function
    def validate_FunctionType(self, value):
        # Validate type FunctionType, a restriction on xs:string.
        pass
    def get_Object(self): return self.Object
    def set_Object(self, Object): self.Object = Object
    def validate_ObjectType(self, value):
        # Validate type ObjectType, a restriction on xs:string.
        pass
    def get_EducationOrganizationReference(self): return self.EducationOrganizationReference
    def set_EducationOrganizationReference(self, EducationOrganizationReference): self.EducationOrganizationReference = EducationOrganizationReference
    def export(self, outfile, level, namespace_='', name_='Account', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Account')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Account'):
        super(Account, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Account')
    def exportChildren(self, outfile, level, namespace_='', name_='Account', fromsubclass_=False):
        super(Account, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.Fund is not None:
            showIndent(outfile, level)
            outfile.write('<%sFund>%s</%sFund>\n' % (namespace_, self.gds_format_string(quote_xml(self.Fund).encode(ExternalEncoding), input_name='Fund'), namespace_))
        if self.Function is not None:
            showIndent(outfile, level)
            outfile.write('<%sFunction>%s</%sFunction>\n' % (namespace_, self.gds_format_string(quote_xml(self.Function).encode(ExternalEncoding), input_name='Function'), namespace_))
        if self.Object is not None:
            showIndent(outfile, level)
            outfile.write('<%sObject>%s</%sObject>\n' % (namespace_, self.gds_format_string(quote_xml(self.Object).encode(ExternalEncoding), input_name='Object'), namespace_))
        if self.EducationOrganizationReference:
            self.EducationOrganizationReference.export(outfile, level, namespace_, name_='EducationOrganizationReference', )
    def hasContent_(self):
        if (
            self.Fund is not None or
            self.Function is not None or
            self.Object is not None or
            self.EducationOrganizationReference is not None or
            super(Account, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Account'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Account, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Account, self).exportLiteralChildren(outfile, level, name_)
        if self.Fund is not None:
            showIndent(outfile, level)
            outfile.write('Fund=%s,\n' % quote_python(self.Fund).encode(ExternalEncoding))
        if self.Function is not None:
            showIndent(outfile, level)
            outfile.write('Function=%s,\n' % quote_python(self.Function).encode(ExternalEncoding))
        if self.Object is not None:
            showIndent(outfile, level)
            outfile.write('Object=%s,\n' % quote_python(self.Object).encode(ExternalEncoding))
        if self.EducationOrganizationReference is not None:
            showIndent(outfile, level)
            outfile.write('EducationOrganizationReference=model_.EducationalOrgReferenceType(\n')
            self.EducationOrganizationReference.exportLiteral(outfile, level, name_='EducationOrganizationReference')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Account, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Fund':
            Fund_ = child_.text
            Fund_ = self.gds_validate_string(Fund_, node, 'Fund')
            self.Fund = Fund_
            self.validate_FundType(self.Fund)    # validate type FundType
        elif nodeName_ == 'Function':
            Function_ = child_.text
            Function_ = self.gds_validate_string(Function_, node, 'Function')
            self.Function = Function_
            self.validate_FunctionType(self.Function)    # validate type FunctionType
        elif nodeName_ == 'Object':
            Object_ = child_.text
            Object_ = self.gds_validate_string(Object_, node, 'Object')
            self.Object = Object_
            self.validate_ObjectType(self.Object)    # validate type ObjectType
        elif nodeName_ == 'EducationOrganizationReference':
            obj_ = EducationalOrgReferenceType.factory()
            obj_.build(child_)
            self.set_EducationOrganizationReference(obj_)
        super(Account, self).buildChildren(child_, node, nodeName_, True)
# end class Account


class AcademicWeek(ComplexObjectType):
    """This entity represents the academic weeks for a school year,
    optionally captured to support analyses."""
    subclass = None
    superclass = ComplexObjectType
    def __init__(self, id=None, WeekIdentifier=None, BeginDate=None, EndDate=None, TotalInstructionalDays=None, Term=None, CalendarDateReference=None):
        super(AcademicWeek, self).__init__(id, )
        self.WeekIdentifier = WeekIdentifier
        self.BeginDate = BeginDate
        self.EndDate = EndDate
        self.TotalInstructionalDays = TotalInstructionalDays
        self.Term = Term
        if CalendarDateReference is None:
            self.CalendarDateReference = []
        else:
            self.CalendarDateReference = CalendarDateReference
    def factory(*args_, **kwargs_):
        if AcademicWeek.subclass:
            return AcademicWeek.subclass(*args_, **kwargs_)
        else:
            return AcademicWeek(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WeekIdentifier(self): return self.WeekIdentifier
    def set_WeekIdentifier(self, WeekIdentifier): self.WeekIdentifier = WeekIdentifier
    def validate_WeekIdentifier(self, value):
        # Validate type WeekIdentifier, a restriction on xs:string.
        pass
    def get_BeginDate(self): return self.BeginDate
    def set_BeginDate(self, BeginDate): self.BeginDate = BeginDate
    def get_EndDate(self): return self.EndDate
    def set_EndDate(self, EndDate): self.EndDate = EndDate
    def get_TotalInstructionalDays(self): return self.TotalInstructionalDays
    def set_TotalInstructionalDays(self, TotalInstructionalDays): self.TotalInstructionalDays = TotalInstructionalDays
    def get_Term(self): return self.Term
    def set_Term(self, Term): self.Term = Term
    def validate_TermType(self, value):
        # Validate type TermType, a restriction on xs:token.
        pass
    def get_CalendarDateReference(self): return self.CalendarDateReference
    def set_CalendarDateReference(self, CalendarDateReference): self.CalendarDateReference = CalendarDateReference
    def add_CalendarDateReference(self, value): self.CalendarDateReference.append(value)
    def insert_CalendarDateReference(self, index, value): self.CalendarDateReference[index] = value
    def export(self, outfile, level, namespace_='', name_='AcademicWeek', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AcademicWeek')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AcademicWeek'):
        super(AcademicWeek, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AcademicWeek')
    def exportChildren(self, outfile, level, namespace_='', name_='AcademicWeek', fromsubclass_=False):
        super(AcademicWeek, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.WeekIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('<%sWeekIdentifier>%s</%sWeekIdentifier>\n' % (namespace_, self.gds_format_string(quote_xml(self.WeekIdentifier).encode(ExternalEncoding), input_name='WeekIdentifier'), namespace_))
        if self.BeginDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sBeginDate>%s</%sBeginDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.BeginDate).encode(ExternalEncoding), input_name='BeginDate'), namespace_))
        if self.EndDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sEndDate>%s</%sEndDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.EndDate).encode(ExternalEncoding), input_name='EndDate'), namespace_))
        if self.TotalInstructionalDays is not None:
            showIndent(outfile, level)
            outfile.write('<%sTotalInstructionalDays>%s</%sTotalInstructionalDays>\n' % (namespace_, self.gds_format_integer(self.TotalInstructionalDays, input_name='TotalInstructionalDays'), namespace_))
        if self.Term is not None:
            showIndent(outfile, level)
            outfile.write('<%sTerm>%s</%sTerm>\n' % (namespace_, self.gds_format_string(quote_xml(self.Term).encode(ExternalEncoding), input_name='Term'), namespace_))
        for CalendarDateReference_ in self.CalendarDateReference:
            CalendarDateReference_.export(outfile, level, namespace_, name_='CalendarDateReference')
    def hasContent_(self):
        if (
            self.WeekIdentifier is not None or
            self.BeginDate is not None or
            self.EndDate is not None or
            self.TotalInstructionalDays is not None or
            self.Term is not None or
            self.CalendarDateReference or
            super(AcademicWeek, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AcademicWeek'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AcademicWeek, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AcademicWeek, self).exportLiteralChildren(outfile, level, name_)
        if self.WeekIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('WeekIdentifier=%s,\n' % quote_python(self.WeekIdentifier).encode(ExternalEncoding))
        if self.BeginDate is not None:
            showIndent(outfile, level)
            outfile.write('BeginDate=%s,\n' % quote_python(self.BeginDate).encode(ExternalEncoding))
        if self.EndDate is not None:
            showIndent(outfile, level)
            outfile.write('EndDate=%s,\n' % quote_python(self.EndDate).encode(ExternalEncoding))
        if self.TotalInstructionalDays is not None:
            showIndent(outfile, level)
            outfile.write('TotalInstructionalDays=%d,\n' % self.TotalInstructionalDays)
        if self.Term is not None:
            showIndent(outfile, level)
            outfile.write('Term=%s,\n' % quote_python(self.Term).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('CalendarDateReference=[\n')
        level += 1
        for CalendarDateReference_ in self.CalendarDateReference:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            CalendarDateReference_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AcademicWeek, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WeekIdentifier':
            WeekIdentifier_ = child_.text
            WeekIdentifier_ = self.gds_validate_string(WeekIdentifier_, node, 'WeekIdentifier')
            self.WeekIdentifier = WeekIdentifier_
            self.validate_WeekIdentifier(self.WeekIdentifier)    # validate type WeekIdentifier
        elif nodeName_ == 'BeginDate':
            BeginDate_ = child_.text
            BeginDate_ = self.gds_validate_string(BeginDate_, node, 'BeginDate')
            self.BeginDate = BeginDate_
        elif nodeName_ == 'EndDate':
            EndDate_ = child_.text
            EndDate_ = self.gds_validate_string(EndDate_, node, 'EndDate')
            self.EndDate = EndDate_
        elif nodeName_ == 'TotalInstructionalDays':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TotalInstructionalDays')
            self.TotalInstructionalDays = ival_
        elif nodeName_ == 'Term':
            Term_ = child_.text
            Term_ = re_.sub(String_cleanup_pat_, " ", Term_).strip()
            Term_ = self.gds_validate_string(Term_, node, 'Term')
            self.Term = Term_
            self.validate_TermType(self.Term)    # validate type TermType
        elif nodeName_ == 'CalendarDateReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.CalendarDateReference.append(obj_)
        super(AcademicWeek, self).buildChildren(child_, node, nodeName_, True)
# end class AcademicWeek


class Teacher(Staff):
    """This entity represents a person that is employed by an LEA or other
    educational unit engaged in student instruction. These persons
    are instructional-type staff members. In the data model, a
    teacher entity is a staff member with additional properties."""
    subclass = None
    superclass = Staff
    def __init__(self, id=None, StaffUniqueStateId=None, StaffIdentificationCode=None, Name=None, OtherName=None, Sex=None, BirthDate=None, Address=None, Telephone=None, ElectronicMail=None, HispanicLatinoEthnicity=None, OldEthnicity=None, Race=None, HighestLevelOfEducationCompleted=None, YearsOfPriorProfessionalExperience=None, YearsOfPriorTeachingExperience=None, Credentials=None, TeacherUniqueStateId=None, HighlyQualifiedTeacher=None):
        super(Teacher, self).__init__(id, StaffUniqueStateId, StaffIdentificationCode, Name, OtherName, Sex, BirthDate, Address, Telephone, ElectronicMail, HispanicLatinoEthnicity, OldEthnicity, Race, HighestLevelOfEducationCompleted, YearsOfPriorProfessionalExperience, YearsOfPriorTeachingExperience, Credentials, )
        self.TeacherUniqueStateId = TeacherUniqueStateId
        self.HighlyQualifiedTeacher = HighlyQualifiedTeacher
    def factory(*args_, **kwargs_):
        if Teacher.subclass:
            return Teacher.subclass(*args_, **kwargs_)
        else:
            return Teacher(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TeacherUniqueStateId(self): return self.TeacherUniqueStateId
    def set_TeacherUniqueStateId(self, TeacherUniqueStateId): self.TeacherUniqueStateId = TeacherUniqueStateId
    def validate_UniqueStateIdentifier(self, value):
        # Validate type UniqueStateIdentifier, a restriction on xs:int.
        pass
    def get_HighlyQualifiedTeacher(self): return self.HighlyQualifiedTeacher
    def set_HighlyQualifiedTeacher(self, HighlyQualifiedTeacher): self.HighlyQualifiedTeacher = HighlyQualifiedTeacher
    def export(self, outfile, level, namespace_='', name_='Teacher', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Teacher')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Teacher'):
        super(Teacher, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Teacher')
    def exportChildren(self, outfile, level, namespace_='', name_='Teacher', fromsubclass_=False):
        super(Teacher, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.TeacherUniqueStateId is not None:
            showIndent(outfile, level)
            outfile.write('<%sTeacherUniqueStateId>%s</%sTeacherUniqueStateId>\n' % (namespace_, self.gds_format_integer(self.TeacherUniqueStateId, input_name='TeacherUniqueStateId'), namespace_))
        if self.HighlyQualifiedTeacher is not None:
            showIndent(outfile, level)
            outfile.write('<%sHighlyQualifiedTeacher>%s</%sHighlyQualifiedTeacher>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.HighlyQualifiedTeacher)), input_name='HighlyQualifiedTeacher'), namespace_))
    def hasContent_(self):
        if (
            self.TeacherUniqueStateId is not None or
            self.HighlyQualifiedTeacher is not None or
            super(Teacher, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Teacher'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Teacher, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Teacher, self).exportLiteralChildren(outfile, level, name_)
        if self.TeacherUniqueStateId is not None:
            showIndent(outfile, level)
            outfile.write('TeacherUniqueStateId=%d,\n' % self.TeacherUniqueStateId)
        if self.HighlyQualifiedTeacher is not None:
            showIndent(outfile, level)
            outfile.write('HighlyQualifiedTeacher=%s,\n' % self.HighlyQualifiedTeacher)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Teacher, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TeacherUniqueStateId':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TeacherUniqueStateId')
            self.TeacherUniqueStateId = ival_
            self.validate_UniqueStateIdentifier(self.TeacherUniqueStateId)    # validate type UniqueStateIdentifier
        elif nodeName_ == 'HighlyQualifiedTeacher':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'HighlyQualifiedTeacher')
            self.HighlyQualifiedTeacher = ival_
        super(Teacher, self).buildChildren(child_, node, nodeName_, True)
# end class Teacher


class StateEducationAgency(EducationOrganization):
    """The agency of the state charged with primary responsibility for
    coordinating and supervising public instruction, including the
    setting of standards for elementary and secondary instruction
    programs."""
    subclass = None
    superclass = EducationOrganization
    def __init__(self, id=None, StateOrganizationId=None, EducationOrgIdentificationCode=None, NameOfInstitution=None, ShortNameOfInstitution=None, OrganizationCategory=None, Address=None, Telephone=None, WebSite=None, OperationalStatus=None, AccountabilityRatings=None, ProgramReference=None, EducationOrganizationPeerReference=None):
        super(StateEducationAgency, self).__init__(id, StateOrganizationId, EducationOrgIdentificationCode, NameOfInstitution, ShortNameOfInstitution, OrganizationCategory, Address, Telephone, WebSite, OperationalStatus, AccountabilityRatings, ProgramReference, EducationOrganizationPeerReference, )
        pass
    def factory(*args_, **kwargs_):
        if StateEducationAgency.subclass:
            return StateEducationAgency.subclass(*args_, **kwargs_)
        else:
            return StateEducationAgency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='StateEducationAgency', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StateEducationAgency')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StateEducationAgency'):
        super(StateEducationAgency, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StateEducationAgency')
    def exportChildren(self, outfile, level, namespace_='', name_='StateEducationAgency', fromsubclass_=False):
        super(StateEducationAgency, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(StateEducationAgency, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StateEducationAgency'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StateEducationAgency, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StateEducationAgency, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(StateEducationAgency, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(StateEducationAgency, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class StateEducationAgency


class School(EducationOrganization):
    """This entity represents an educational organization that includes
    staff and students who participate in classes and educational
    activity groups."""
    subclass = None
    superclass = EducationOrganization
    def __init__(self, id=None, StateOrganizationId=None, EducationOrgIdentificationCode=None, NameOfInstitution=None, ShortNameOfInstitution=None, OrganizationCategory=None, Address=None, Telephone=None, WebSite=None, OperationalStatus=None, AccountabilityRatings=None, ProgramReference=None, EducationOrganizationPeerReference=None, GradesOffered=None, SchoolCategories=None, SchoolType=None, CharterStatus=None, TitleIPartASchoolDesignation=None, MagnetSpecialProgramEmphasisSchool=None, AdministrativeFundingControl=None, LocalEducationAgencyReference=None, ClassPeriodReference=None, LocationReference=None, EducationOrganizationFeederReference=None):
        super(School, self).__init__(id, StateOrganizationId, EducationOrgIdentificationCode, NameOfInstitution, ShortNameOfInstitution, OrganizationCategory, Address, Telephone, WebSite, OperationalStatus, AccountabilityRatings, ProgramReference, EducationOrganizationPeerReference, )
        self.GradesOffered = GradesOffered
        self.SchoolCategories = SchoolCategories
        self.SchoolType = SchoolType
        self.CharterStatus = CharterStatus
        self.TitleIPartASchoolDesignation = TitleIPartASchoolDesignation
        self.MagnetSpecialProgramEmphasisSchool = MagnetSpecialProgramEmphasisSchool
        self.AdministrativeFundingControl = AdministrativeFundingControl
        self.LocalEducationAgencyReference = LocalEducationAgencyReference
        if ClassPeriodReference is None:
            self.ClassPeriodReference = []
        else:
            self.ClassPeriodReference = ClassPeriodReference
        if LocationReference is None:
            self.LocationReference = []
        else:
            self.LocationReference = LocationReference
        if EducationOrganizationFeederReference is None:
            self.EducationOrganizationFeederReference = []
        else:
            self.EducationOrganizationFeederReference = EducationOrganizationFeederReference
    def factory(*args_, **kwargs_):
        if School.subclass:
            return School.subclass(*args_, **kwargs_)
        else:
            return School(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GradesOffered(self): return self.GradesOffered
    def set_GradesOffered(self, GradesOffered): self.GradesOffered = GradesOffered
    def get_SchoolCategories(self): return self.SchoolCategories
    def set_SchoolCategories(self, SchoolCategories): self.SchoolCategories = SchoolCategories
    def get_SchoolType(self): return self.SchoolType
    def set_SchoolType(self, SchoolType): self.SchoolType = SchoolType
    def validate_SchoolType(self, value):
        # Validate type SchoolType, a restriction on xs:token.
        pass
    def get_CharterStatus(self): return self.CharterStatus
    def set_CharterStatus(self, CharterStatus): self.CharterStatus = CharterStatus
    def validate_CharterStatusType(self, value):
        # Validate type CharterStatusType, a restriction on xs:token.
        pass
    def get_TitleIPartASchoolDesignation(self): return self.TitleIPartASchoolDesignation
    def set_TitleIPartASchoolDesignation(self, TitleIPartASchoolDesignation): self.TitleIPartASchoolDesignation = TitleIPartASchoolDesignation
    def validate_TitleIPartASchoolDesignationType(self, value):
        # Validate type TitleIPartASchoolDesignationType, a restriction on xs:token.
        pass
    def get_MagnetSpecialProgramEmphasisSchool(self): return self.MagnetSpecialProgramEmphasisSchool
    def set_MagnetSpecialProgramEmphasisSchool(self, MagnetSpecialProgramEmphasisSchool): self.MagnetSpecialProgramEmphasisSchool = MagnetSpecialProgramEmphasisSchool
    def validate_MagnetSpecialProgramEmphasisSchoolType(self, value):
        # Validate type MagnetSpecialProgramEmphasisSchoolType, a restriction on xs:token.
        pass
    def get_AdministrativeFundingControl(self): return self.AdministrativeFundingControl
    def set_AdministrativeFundingControl(self, AdministrativeFundingControl): self.AdministrativeFundingControl = AdministrativeFundingControl
    def validate_AdministrativeFundingControlType(self, value):
        # Validate type AdministrativeFundingControlType, a restriction on xs:token.
        pass
    def get_LocalEducationAgencyReference(self): return self.LocalEducationAgencyReference
    def set_LocalEducationAgencyReference(self, LocalEducationAgencyReference): self.LocalEducationAgencyReference = LocalEducationAgencyReference
    def get_ClassPeriodReference(self): return self.ClassPeriodReference
    def set_ClassPeriodReference(self, ClassPeriodReference): self.ClassPeriodReference = ClassPeriodReference
    def add_ClassPeriodReference(self, value): self.ClassPeriodReference.append(value)
    def insert_ClassPeriodReference(self, index, value): self.ClassPeriodReference[index] = value
    def get_LocationReference(self): return self.LocationReference
    def set_LocationReference(self, LocationReference): self.LocationReference = LocationReference
    def add_LocationReference(self, value): self.LocationReference.append(value)
    def insert_LocationReference(self, index, value): self.LocationReference[index] = value
    def get_EducationOrganizationFeederReference(self): return self.EducationOrganizationFeederReference
    def set_EducationOrganizationFeederReference(self, EducationOrganizationFeederReference): self.EducationOrganizationFeederReference = EducationOrganizationFeederReference
    def add_EducationOrganizationFeederReference(self, value): self.EducationOrganizationFeederReference.append(value)
    def insert_EducationOrganizationFeederReference(self, index, value): self.EducationOrganizationFeederReference[index] = value
    def export(self, outfile, level, namespace_='', name_='School', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='School')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='School'):
        super(School, self).exportAttributes(outfile, level, already_processed, namespace_, name_='School')
    def exportChildren(self, outfile, level, namespace_='', name_='School', fromsubclass_=False):
        super(School, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.GradesOffered:
            self.GradesOffered.export(outfile, level, namespace_, name_='GradesOffered', )
        if self.SchoolCategories:
            self.SchoolCategories.export(outfile, level, namespace_, name_='SchoolCategories', )
        if self.SchoolType is not None:
            showIndent(outfile, level)
            outfile.write('<%sSchoolType>%s</%sSchoolType>\n' % (namespace_, self.gds_format_string(quote_xml(self.SchoolType).encode(ExternalEncoding), input_name='SchoolType'), namespace_))
        if self.CharterStatus is not None:
            showIndent(outfile, level)
            outfile.write('<%sCharterStatus>%s</%sCharterStatus>\n' % (namespace_, self.gds_format_string(quote_xml(self.CharterStatus).encode(ExternalEncoding), input_name='CharterStatus'), namespace_))
        if self.TitleIPartASchoolDesignation is not None:
            showIndent(outfile, level)
            outfile.write('<%sTitleIPartASchoolDesignation>%s</%sTitleIPartASchoolDesignation>\n' % (namespace_, self.gds_format_string(quote_xml(self.TitleIPartASchoolDesignation).encode(ExternalEncoding), input_name='TitleIPartASchoolDesignation'), namespace_))
        if self.MagnetSpecialProgramEmphasisSchool is not None:
            showIndent(outfile, level)
            outfile.write('<%sMagnetSpecialProgramEmphasisSchool>%s</%sMagnetSpecialProgramEmphasisSchool>\n' % (namespace_, self.gds_format_string(quote_xml(self.MagnetSpecialProgramEmphasisSchool).encode(ExternalEncoding), input_name='MagnetSpecialProgramEmphasisSchool'), namespace_))
        if self.AdministrativeFundingControl is not None:
            showIndent(outfile, level)
            outfile.write('<%sAdministrativeFundingControl>%s</%sAdministrativeFundingControl>\n' % (namespace_, self.gds_format_string(quote_xml(self.AdministrativeFundingControl).encode(ExternalEncoding), input_name='AdministrativeFundingControl'), namespace_))
        if self.LocalEducationAgencyReference:
            self.LocalEducationAgencyReference.export(outfile, level, namespace_, name_='LocalEducationAgencyReference', )
        for ClassPeriodReference_ in self.ClassPeriodReference:
            ClassPeriodReference_.export(outfile, level, namespace_, name_='ClassPeriodReference')
        for LocationReference_ in self.LocationReference:
            LocationReference_.export(outfile, level, namespace_, name_='LocationReference')
        for EducationOrganizationFeederReference_ in self.EducationOrganizationFeederReference:
            EducationOrganizationFeederReference_.export(outfile, level, namespace_, name_='EducationOrganizationFeederReference')
    def hasContent_(self):
        if (
            self.GradesOffered is not None or
            self.SchoolCategories is not None or
            self.SchoolType is not None or
            self.CharterStatus is not None or
            self.TitleIPartASchoolDesignation is not None or
            self.MagnetSpecialProgramEmphasisSchool is not None or
            self.AdministrativeFundingControl is not None or
            self.LocalEducationAgencyReference is not None or
            self.ClassPeriodReference or
            self.LocationReference or
            self.EducationOrganizationFeederReference or
            super(School, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='School'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(School, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(School, self).exportLiteralChildren(outfile, level, name_)
        if self.GradesOffered is not None:
            showIndent(outfile, level)
            outfile.write('GradesOffered=model_.GradeLevelsType(\n')
            self.GradesOffered.exportLiteral(outfile, level, name_='GradesOffered')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SchoolCategories is not None:
            showIndent(outfile, level)
            outfile.write('SchoolCategories=model_.SchoolCategoriesType(\n')
            self.SchoolCategories.exportLiteral(outfile, level, name_='SchoolCategories')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SchoolType is not None:
            showIndent(outfile, level)
            outfile.write('SchoolType=%s,\n' % quote_python(self.SchoolType).encode(ExternalEncoding))
        if self.CharterStatus is not None:
            showIndent(outfile, level)
            outfile.write('CharterStatus=%s,\n' % quote_python(self.CharterStatus).encode(ExternalEncoding))
        if self.TitleIPartASchoolDesignation is not None:
            showIndent(outfile, level)
            outfile.write('TitleIPartASchoolDesignation=%s,\n' % quote_python(self.TitleIPartASchoolDesignation).encode(ExternalEncoding))
        if self.MagnetSpecialProgramEmphasisSchool is not None:
            showIndent(outfile, level)
            outfile.write('MagnetSpecialProgramEmphasisSchool=%s,\n' % quote_python(self.MagnetSpecialProgramEmphasisSchool).encode(ExternalEncoding))
        if self.AdministrativeFundingControl is not None:
            showIndent(outfile, level)
            outfile.write('AdministrativeFundingControl=%s,\n' % quote_python(self.AdministrativeFundingControl).encode(ExternalEncoding))
        if self.LocalEducationAgencyReference is not None:
            showIndent(outfile, level)
            outfile.write('LocalEducationAgencyReference=model_.EducationalOrgReferenceType(\n')
            self.LocalEducationAgencyReference.exportLiteral(outfile, level, name_='LocalEducationAgencyReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('ClassPeriodReference=[\n')
        level += 1
        for ClassPeriodReference_ in self.ClassPeriodReference:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            ClassPeriodReference_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LocationReference=[\n')
        level += 1
        for LocationReference_ in self.LocationReference:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            LocationReference_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('EducationOrganizationFeederReference=[\n')
        level += 1
        for EducationOrganizationFeederReference_ in self.EducationOrganizationFeederReference:
            showIndent(outfile, level)
            outfile.write('model_.EducationalOrgReferenceType(\n')
            EducationOrganizationFeederReference_.exportLiteral(outfile, level, name_='EducationalOrgReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(School, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GradesOffered':
            obj_ = GradeLevelsType.factory()
            obj_.build(child_)
            self.set_GradesOffered(obj_)
        elif nodeName_ == 'SchoolCategories':
            obj_ = SchoolCategoriesType.factory()
            obj_.build(child_)
            self.set_SchoolCategories(obj_)
        elif nodeName_ == 'SchoolType':
            SchoolType_ = child_.text
            SchoolType_ = re_.sub(String_cleanup_pat_, " ", SchoolType_).strip()
            SchoolType_ = self.gds_validate_string(SchoolType_, node, 'SchoolType')
            self.SchoolType = SchoolType_
            self.validate_SchoolType(self.SchoolType)    # validate type SchoolType
        elif nodeName_ == 'CharterStatus':
            CharterStatus_ = child_.text
            CharterStatus_ = re_.sub(String_cleanup_pat_, " ", CharterStatus_).strip()
            CharterStatus_ = self.gds_validate_string(CharterStatus_, node, 'CharterStatus')
            self.CharterStatus = CharterStatus_
            self.validate_CharterStatusType(self.CharterStatus)    # validate type CharterStatusType
        elif nodeName_ == 'TitleIPartASchoolDesignation':
            TitleIPartASchoolDesignation_ = child_.text
            TitleIPartASchoolDesignation_ = re_.sub(String_cleanup_pat_, " ", TitleIPartASchoolDesignation_).strip()
            TitleIPartASchoolDesignation_ = self.gds_validate_string(TitleIPartASchoolDesignation_, node, 'TitleIPartASchoolDesignation')
            self.TitleIPartASchoolDesignation = TitleIPartASchoolDesignation_
            self.validate_TitleIPartASchoolDesignationType(self.TitleIPartASchoolDesignation)    # validate type TitleIPartASchoolDesignationType
        elif nodeName_ == 'MagnetSpecialProgramEmphasisSchool':
            MagnetSpecialProgramEmphasisSchool_ = child_.text
            MagnetSpecialProgramEmphasisSchool_ = re_.sub(String_cleanup_pat_, " ", MagnetSpecialProgramEmphasisSchool_).strip()
            MagnetSpecialProgramEmphasisSchool_ = self.gds_validate_string(MagnetSpecialProgramEmphasisSchool_, node, 'MagnetSpecialProgramEmphasisSchool')
            self.MagnetSpecialProgramEmphasisSchool = MagnetSpecialProgramEmphasisSchool_
            self.validate_MagnetSpecialProgramEmphasisSchoolType(self.MagnetSpecialProgramEmphasisSchool)    # validate type MagnetSpecialProgramEmphasisSchoolType
        elif nodeName_ == 'AdministrativeFundingControl':
            AdministrativeFundingControl_ = child_.text
            AdministrativeFundingControl_ = re_.sub(String_cleanup_pat_, " ", AdministrativeFundingControl_).strip()
            AdministrativeFundingControl_ = self.gds_validate_string(AdministrativeFundingControl_, node, 'AdministrativeFundingControl')
            self.AdministrativeFundingControl = AdministrativeFundingControl_
            self.validate_AdministrativeFundingControlType(self.AdministrativeFundingControl)    # validate type AdministrativeFundingControlType
        elif nodeName_ == 'LocalEducationAgencyReference':
            obj_ = EducationalOrgReferenceType.factory()
            obj_.build(child_)
            self.set_LocalEducationAgencyReference(obj_)
        elif nodeName_ == 'ClassPeriodReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ClassPeriodReference.append(obj_)
        elif nodeName_ == 'LocationReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.LocationReference.append(obj_)
        elif nodeName_ == 'EducationOrganizationFeederReference':
            obj_ = EducationalOrgReferenceType.factory()
            obj_.build(child_)
            self.EducationOrganizationFeederReference.append(obj_)
        super(School, self).buildChildren(child_, node, nodeName_, True)
# end class School


class LocalEducationAgency(EducationOrganization):
    """This entity represents an administrative unit at the local level
    which exists primarily to operate schools or to contract for
    educational services. It includes school districts, charter
    schools, charter management organizations, or other local
    administrative organizations."""
    subclass = None
    superclass = EducationOrganization
    def __init__(self, id=None, StateOrganizationId=None, EducationOrgIdentificationCode=None, NameOfInstitution=None, ShortNameOfInstitution=None, OrganizationCategory=None, Address=None, Telephone=None, WebSite=None, OperationalStatus=None, AccountabilityRatings=None, ProgramReference=None, EducationOrganizationPeerReference=None, LEACategory=None, CharterStatus=None, EducationServiceCenterReference=None, StateEducationAgencyReference=None):
        super(LocalEducationAgency, self).__init__(id, StateOrganizationId, EducationOrgIdentificationCode, NameOfInstitution, ShortNameOfInstitution, OrganizationCategory, Address, Telephone, WebSite, OperationalStatus, AccountabilityRatings, ProgramReference, EducationOrganizationPeerReference, )
        self.LEACategory = LEACategory
        self.CharterStatus = CharterStatus
        self.EducationServiceCenterReference = EducationServiceCenterReference
        self.StateEducationAgencyReference = StateEducationAgencyReference
    def factory(*args_, **kwargs_):
        if LocalEducationAgency.subclass:
            return LocalEducationAgency.subclass(*args_, **kwargs_)
        else:
            return LocalEducationAgency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LEACategory(self): return self.LEACategory
    def set_LEACategory(self, LEACategory): self.LEACategory = LEACategory
    def validate_LEACategoryType(self, value):
        # Validate type LEACategoryType, a restriction on xs:token.
        pass
    def get_CharterStatus(self): return self.CharterStatus
    def set_CharterStatus(self, CharterStatus): self.CharterStatus = CharterStatus
    def validate_CharterStatusType(self, value):
        # Validate type CharterStatusType, a restriction on xs:token.
        pass
    def get_EducationServiceCenterReference(self): return self.EducationServiceCenterReference
    def set_EducationServiceCenterReference(self, EducationServiceCenterReference): self.EducationServiceCenterReference = EducationServiceCenterReference
    def get_StateEducationAgencyReference(self): return self.StateEducationAgencyReference
    def set_StateEducationAgencyReference(self, StateEducationAgencyReference): self.StateEducationAgencyReference = StateEducationAgencyReference
    def export(self, outfile, level, namespace_='', name_='LocalEducationAgency', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocalEducationAgency')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocalEducationAgency'):
        super(LocalEducationAgency, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LocalEducationAgency')
    def exportChildren(self, outfile, level, namespace_='', name_='LocalEducationAgency', fromsubclass_=False):
        super(LocalEducationAgency, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.LEACategory is not None:
            showIndent(outfile, level)
            outfile.write('<%sLEACategory>%s</%sLEACategory>\n' % (namespace_, self.gds_format_string(quote_xml(self.LEACategory).encode(ExternalEncoding), input_name='LEACategory'), namespace_))
        if self.CharterStatus is not None:
            showIndent(outfile, level)
            outfile.write('<%sCharterStatus>%s</%sCharterStatus>\n' % (namespace_, self.gds_format_string(quote_xml(self.CharterStatus).encode(ExternalEncoding), input_name='CharterStatus'), namespace_))
        if self.EducationServiceCenterReference:
            self.EducationServiceCenterReference.export(outfile, level, namespace_, name_='EducationServiceCenterReference')
        if self.StateEducationAgencyReference:
            self.StateEducationAgencyReference.export(outfile, level, namespace_, name_='StateEducationAgencyReference')
    def hasContent_(self):
        if (
            self.LEACategory is not None or
            self.CharterStatus is not None or
            self.EducationServiceCenterReference is not None or
            self.StateEducationAgencyReference is not None or
            super(LocalEducationAgency, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LocalEducationAgency'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LocalEducationAgency, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LocalEducationAgency, self).exportLiteralChildren(outfile, level, name_)
        if self.LEACategory is not None:
            showIndent(outfile, level)
            outfile.write('LEACategory=%s,\n' % quote_python(self.LEACategory).encode(ExternalEncoding))
        if self.CharterStatus is not None:
            showIndent(outfile, level)
            outfile.write('CharterStatus=%s,\n' % quote_python(self.CharterStatus).encode(ExternalEncoding))
        if self.EducationServiceCenterReference is not None:
            showIndent(outfile, level)
            outfile.write('EducationServiceCenterReference=model_.EducationalOrgReferenceType(\n')
            self.EducationServiceCenterReference.exportLiteral(outfile, level, name_='EducationServiceCenterReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.StateEducationAgencyReference is not None:
            showIndent(outfile, level)
            outfile.write('StateEducationAgencyReference=model_.EducationalOrgReferenceType(\n')
            self.StateEducationAgencyReference.exportLiteral(outfile, level, name_='StateEducationAgencyReference')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(LocalEducationAgency, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LEACategory':
            LEACategory_ = child_.text
            LEACategory_ = re_.sub(String_cleanup_pat_, " ", LEACategory_).strip()
            LEACategory_ = self.gds_validate_string(LEACategory_, node, 'LEACategory')
            self.LEACategory = LEACategory_
            self.validate_LEACategoryType(self.LEACategory)    # validate type LEACategoryType
        elif nodeName_ == 'CharterStatus':
            CharterStatus_ = child_.text
            CharterStatus_ = re_.sub(String_cleanup_pat_, " ", CharterStatus_).strip()
            CharterStatus_ = self.gds_validate_string(CharterStatus_, node, 'CharterStatus')
            self.CharterStatus = CharterStatus_
            self.validate_CharterStatusType(self.CharterStatus)    # validate type CharterStatusType
        elif nodeName_ == 'EducationServiceCenterReference':
            obj_ = EducationalOrgReferenceType.factory()
            obj_.build(child_)
            self.set_EducationServiceCenterReference(obj_)
        elif nodeName_ == 'StateEducationAgencyReference':
            obj_ = EducationalOrgReferenceType.factory()
            obj_.build(child_)
            self.set_StateEducationAgencyReference(obj_)
        super(LocalEducationAgency, self).buildChildren(child_, node, nodeName_, True)
# end class LocalEducationAgency


class EducationServiceCenter(EducationOrganization):
    """This entity represents a regional, multi-services public agency
    authorized by State law to develop, manage, and provide
    services, programs, or other options support (e.g.,
    construction, food services, technology services) to LEAs."""
    subclass = None
    superclass = EducationOrganization
    def __init__(self, id=None, StateOrganizationId=None, EducationOrgIdentificationCode=None, NameOfInstitution=None, ShortNameOfInstitution=None, OrganizationCategory=None, Address=None, Telephone=None, WebSite=None, OperationalStatus=None, AccountabilityRatings=None, ProgramReference=None, EducationOrganizationPeerReference=None, StateEducationAgencyReference=None):
        super(EducationServiceCenter, self).__init__(id, StateOrganizationId, EducationOrgIdentificationCode, NameOfInstitution, ShortNameOfInstitution, OrganizationCategory, Address, Telephone, WebSite, OperationalStatus, AccountabilityRatings, ProgramReference, EducationOrganizationPeerReference, )
        self.StateEducationAgencyReference = StateEducationAgencyReference
    def factory(*args_, **kwargs_):
        if EducationServiceCenter.subclass:
            return EducationServiceCenter.subclass(*args_, **kwargs_)
        else:
            return EducationServiceCenter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StateEducationAgencyReference(self): return self.StateEducationAgencyReference
    def set_StateEducationAgencyReference(self, StateEducationAgencyReference): self.StateEducationAgencyReference = StateEducationAgencyReference
    def export(self, outfile, level, namespace_='', name_='EducationServiceCenter', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EducationServiceCenter')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EducationServiceCenter'):
        super(EducationServiceCenter, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EducationServiceCenter')
    def exportChildren(self, outfile, level, namespace_='', name_='EducationServiceCenter', fromsubclass_=False):
        super(EducationServiceCenter, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.StateEducationAgencyReference:
            self.StateEducationAgencyReference.export(outfile, level, namespace_, name_='StateEducationAgencyReference')
    def hasContent_(self):
        if (
            self.StateEducationAgencyReference is not None or
            super(EducationServiceCenter, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EducationServiceCenter'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EducationServiceCenter, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EducationServiceCenter, self).exportLiteralChildren(outfile, level, name_)
        if self.StateEducationAgencyReference is not None:
            showIndent(outfile, level)
            outfile.write('StateEducationAgencyReference=model_.EducationalOrgReferenceType(\n')
            self.StateEducationAgencyReference.exportLiteral(outfile, level, name_='StateEducationAgencyReference')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(EducationServiceCenter, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StateEducationAgencyReference':
            obj_ = EducationalOrgReferenceType.factory()
            obj_.build(child_)
            self.set_StateEducationAgencyReference(obj_)
        super(EducationServiceCenter, self).buildChildren(child_, node, nodeName_, True)
# end class EducationServiceCenter


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'AcademicWeek'
        rootClass = AcademicWeek
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag, 
        namespacedef_='')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'AcademicWeek'
        rootClass = AcademicWeek
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="AcademicWeek",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'AcademicWeek'
        rootClass = AcademicWeek
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from edfi import *\n\n')
    sys.stdout.write('import edfi as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AcademicHonor",
    "AcademicSubjectsType",
    "AcademicWeek",
    "Account",
    "AccountIdentityType",
    "AccountReferenceType",
    "AccountabilityRating",
    "Actual",
    "AdditionalCredits",
    "Address",
    "Assessment",
    "AssessmentFamily",
    "AssessmentFamilyIdentityType",
    "AssessmentFamilyReferenceType",
    "AssessmentIdentificationCode",
    "AssessmentIdentityType",
    "AssessmentItem",
    "AssessmentItemIdentityType",
    "AssessmentItemReferenceType",
    "AssessmentRatingStandard",
    "AssessmentReferenceType",
    "AssessmentResult",
    "AttendanceEvent",
    "BellSchedule",
    "BellScheduleIdentityType",
    "BellScheduleReferenceType",
    "BirthData",
    "Budget",
    "CTEServicesType",
    "CalendarDate",
    "ClassPeriod",
    "ClassRanking",
    "Cohort",
    "CohortIdentityType",
    "CohortReferenceType",
    "CohortYear",
    "ComplexObjectType",
    "ContractedStaff",
    "Course",
    "CourseCode",
    "CourseIdentityType",
    "CourseLevelCharacteristicsType",
    "CourseReferenceType",
    "CourseTranscript",
    "Credential",
    "Credit",
    "Credits",
    "Diploma",
    "Disability",
    "DisciplineAction",
    "DisciplineIncident",
    "EducationOrgIdentificationCode",
    "EducationOrganization",
    "EducationServiceCenter",
    "EducationalOrgIdentityType",
    "EducationalOrgReferenceType",
    "EducationalPlansType",
    "ElectronicMail",
    "EmploymentPeriod",
    "FinalLetterGradeEarned",
    "GPA",
    "Grade",
    "GradeLevelsType",
    "GradePointAverage",
    "GradingPeriod",
    "GradingPeriodIdentityType",
    "GradingPeriodReferenceType",
    "IncidentBehavior",
    "InstitutionTelephone",
    "LanguagesType",
    "LearningObjective",
    "LearningStyles",
    "LeaveEvent",
    "LetterGradeEarned",
    "LinguisticAccommodationsType",
    "LocalEducationAgency",
    "Location",
    "MeetingDaysType",
    "MeetingTime",
    "Name",
    "NumberOfDaysAbsent",
    "NumberOfDaysInAttendance",
    "NumberOfDaysTardy",
    "NumberOfParts",
    "ObjectiveAssessment",
    "ObjectiveAssessmentIdentityType",
    "ObjectiveAssessmentReferenceType",
    "OpenStaffPosition",
    "OtherName",
    "Parent",
    "Payroll",
    "PostSecondaryEvent",
    "Program",
    "ProgramIdentityType",
    "ProgramParticipation",
    "ProgramReferenceType",
    "RaceType",
    "RatingStandardOutcome",
    "Recognition",
    "ReferenceType",
    "ReportCard",
    "RestraintEvent",
    "RestraintEventReasonsType",
    "School",
    "SchoolCategoriesType",
    "ScoreResult",
    "SecondaryIncidentBehavior",
    "Section",
    "Section504DisabilitiesType",
    "SectionIdentityType",
    "SectionReferenceType",
    "SequenceOfCourse",
    "Session",
    "SpecialAccommodationsType",
    "SpecialEdServicesType",
    "Staff",
    "StaffCohortAssociation",
    "StaffEducationOrgAssignmentAssociation",
    "StaffEducationOrgEmploymentAssociation",
    "StaffIdentificationCode",
    "StaffIdentityType",
    "StaffReferenceType",
    "StateEducationAgency",
    "StreetNumberName",
    "Student",
    "StudentAcademicRecord",
    "StudentAssessment",
    "StudentAssessmentItem",
    "StudentBilingualProgramAssociation",
    "StudentCTEProgramAssociation",
    "StudentCharacteristic",
    "StudentCohortAssociation",
    "StudentDisciplineIncidentAssociation",
    "StudentESLProgramAssociation",
    "StudentExpectation",
    "StudentExpectationIdentityType",
    "StudentExpectationReferenceType",
    "StudentIdentificationCode",
    "StudentIdentityType",
    "StudentIndicator",
    "StudentObjectiveAssessment",
    "StudentParentAssociation",
    "StudentProgramAssociation",
    "StudentReferenceType",
    "StudentSchoolAssociation",
    "StudentSectionAssociation",
    "StudentSectionAssociationIdentityType",
    "StudentSectionAssociationReferenceType",
    "StudentSpecialEdProgramAssociation",
    "StudentSupplementalServiceProgramAssociation",
    "StudentTitleIPartAProgramAssociation",
    "Teacher",
    "TeacherSchoolAssociation",
    "TeacherSectionAssociation",
    "Telephone",
    "TitleIPartAServicesType",
    "TitleIPartASupportServicesType",
    "TotalInstructionalDays",
    "WeaponsType",
    "WeekNumber",
    "WeeksInCycle"
    ]
